<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.webmanifest"><meta name="theme-color" content="#5397d2"><script>
      var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e772d8d7735057378a672ae311e9bf20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
    </script><title>分层架构模式 | 众里千寻</title><meta name="description" content="分层架构模式是最常见的架构模式。这种模式是大多数 Java EE 应用程序的事实标准。分层架构模式与大多数公司中组织结构紧密匹配，使其成为大多数业务应用程序开发工作的自然选择。"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.fa50ff6a.js" as="script"><link rel="preload" href="/assets/css/styles.e0095a00.css" as="style"><link rel="preload" href="/assets/js/3767.b5b9e7ce.js" as="script"><link rel="preload" href="/assets/js/app.8de2a662.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.e0095a00.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><img class="logo" src="/hero-c.png" alt="众里千寻"><span class="site-name can-hide">众里千寻</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link router-link-active" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link router-link-active" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">分层架构模式</p><ul class=""><li><!--[--><a aria-current="page" href="/courses/software-architecture/layered-architecture.html#模式介绍" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="模式介绍"><!--[--><!--]--> 模式介绍 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/layered-architecture.html#一些关键概念" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="一些关键概念"><!--[--><!--]--> 一些关键概念 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/layered-architecture.html#举例说明" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="举例说明"><!--[--><!--]--> 举例说明 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/layered-architecture.html#其他说明" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="其他说明"><!--[--><!--]--> 其他说明 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/layered-architecture.html#思考" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="思考"><!--[--><!--]--> 思考 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><p>分层架构模式，最常见的架构模式。在 Java EE 应用开发实践中，分层架构模式已经是事实上的标准。</p><h2 id="模式介绍" tabindex="-1"><a class="header-anchor" href="#模式介绍" aria-hidden="true">#</a> 模式介绍</h2><p>分层架构模式中的每一层通常是水平的，并且在整个应用中有着特定的角色（比如负责展示、负责业务逻辑等）。虽然不同的业务场景分层不一样，但是分层架构模式通常有四层，表现层（presentation）、业务逻辑层（business）、持久化层（persistence）和数据库层（database），如下图。</p><p><img src="/courses/software-architecture/layered-architecture-c.png" alt="分层架构模式"></p><p>每一层都有特定的职责。比如表现层负责处理 UI 展示以及与浏览器之间的交互，而业务逻辑层则负责处理具体的业务逻辑。每一层都针对其负责的职责进行了一定的抽象，并且仅对此负责。比如业务逻辑层只关心如何处理好业务请求，不关心 UI 究竟是如何展示的。业内有一个专业术语，叫关注点分离（separation of concerns），表达的意思是一样的。</p><h2 id="一些关键概念" tabindex="-1"><a class="header-anchor" href="#一些关键概念" aria-hidden="true">#</a> 一些关键概念</h2><p><img src="/courses/software-architecture/closed-layer-c.png" alt="封闭层"></p><p>上图中，每一层都被标记为是封闭的（closed）。这是分层架构模式中非常重要的一个概念。意思是说，用户请求如果要从上层去到下层，则必须一层一层的穿过中间的所有层。比如一个用户请求必须要先经过表现层，然后经过业务逻辑层，再经过持久化层，最终到达数据库层。</p><p>那为什么不能直接从表现层直接到达数据库层呢？毕竟这样有着更好的性能。这就要引入隔离层（layers of isolation）的概念了。隔离层要求某一层中变化的影响范围尽量保持在当前层内，或者仅仅影响到与之相邻的层。比如数据库层的变化，影响范围尽量保持在数据库层内，或者仅仅影响到持久化层（当持久化层中存在直接通过 SQL 操作数据库的情况时）。</p><p>如果不加这层限制的话，比如允许表现层直接操作数据库，那么当数据库层发生变更时，表现层也会受到影响，这样每一层之间就会存在强烈的耦合。这样就是的整个架构后期很难维护和迭代。</p><p>同时，隔离层也意味着每一层都是独立的，对其它层的内部细节知之甚少。当我们需要重构表现层时，因为每个分层都是独立的，我们可以直接复用业务逻辑层。</p><p>虽然封闭层有助于实现隔离层，因此有助于隔离架构内的变化，但有时开放某些层是有意义的。</p><p>比如，当我们有一些公共服务模块（数据、字符串处理类，审计和日志类等）要提供给业务逻辑层使用。最好的做法是引入一个公共服务层。因为这样可以很好的在架构层面避免其他层使用公共服务层的逻辑。</p><p>但是这么做又有明显的缺点，那就是由于封闭性，所有的用户请求都要从公共服务层经过，而很多时候这是多余的。开放层（open layer）可以帮助我们解决这个问题。</p><p><img src="/courses/software-architecture/open-layer-c.png" alt="开放层"></p><p>如上图所示，公共服务层被标记为开放的，这样业务逻辑层就可以穿过公共服务层直接访问持久化层。</p><p>利用好开放层和封闭层的概念有助于定义清楚架构中的每一层和请求流之间的关系，并为设计人员和开发人员提供必要的信息，以了解架构内的各种层间访问限制。</p><h2 id="举例说明" tabindex="-1"><a class="header-anchor" href="#举例说明" aria-hidden="true">#</a> 举例说明</h2><p>假设一个用户请求查询特定个人的客户信息，如下图所示。黑色箭头表示向下流向数据库以查询客户数据的请求，红色箭头表示向上流向屏幕以显示数据的响应。</p><p><img src="/courses/software-architecture/layered-architecture-example-c.png" alt="分层架构样例"></p><p>在此例中，客户信息由客户数据和订单数据（客户下的订单）组成。客户屏幕负责接受请求并显示客户信息。它不知道数据在哪里，如何查询，或者必须查询多少个数据库表才能获取数据。一旦表现层收到获取特定个人客户信息的请求，它就会将该请求转发到客户委托模块（Customer Delegate）。该模块了解业务层中的哪些模块可以处理该请求，如何访问这些模块以及它需要哪些数据。</p><p>业务逻辑层中的客户对象负责聚合业务请求所需的所有信息（在本例中是获取客户信息）。该模块调用持久层中的 customer dao（数据访问对象）模块获取客户数据，同时调用 order dao 模块获取订单信息。这些模块依次执行 SQL 语句以检索相应的数据并将其传回业务逻辑层中的客户对象。</p><p>一旦客户对象接收到数据，它就会聚合数据并将该信息传回给客户委托模块，然后客户委托模块将该数据传递给客户屏幕以呈现给用户。</p><p>从技术角度来说，每一层的具体实现方式不受限制，可以由团队根据自身的技术特定和实际的业务需求自行决定。</p><h2 id="其他说明" tabindex="-1"><a class="header-anchor" href="#其他说明" aria-hidden="true">#</a> 其他说明</h2><p>分层架构模式是一种可靠的通用模式。但是也有两个问题需要注意。</p><p>第一个问题是反模式问题。比如如果我们的分层中很多都是直接透传，比如表现层访问业务逻辑层，而业务逻辑层实际上什么事情也没做，直接透传给了持久化层，最后达到数据库层，然后数据再同样反向返回回来。</p><p>如何来解决这样的问题呢？可以参考一下二八原则。也就是说，如果有百分之八十的情况下，业务请求在每一层都有处理逻辑的，百分之二十的情况下存在透传场景，那么可以认为分层是合理的。如果超过百分之二十的场景都需要透传，那么可以考虑将某些层标记为开放的。</p><p>第二个问题是分层架构模式通常最后会导致巨石应用的问题。即使我们在每一层都划分了独立模块，可以独立部署。对于某些应用来说，分层架构模式确实在部署、总体健壮性和可靠性、性能和可扩展性方面存在一些潜在问题。</p><h2 id="思考" tabindex="-1"><a class="header-anchor" href="#思考" aria-hidden="true">#</a> 思考</h2><p>分层架构模式是比较常见的架构模式，每一层的职责明确，通常也与人员的组织架构相匹配（康威定律）。同时因为隔离层的特性，结合开放层和封闭层，可以很好的实现业务需求，同时保持一定的独立性。在是否易于测试、是否易于开发等方面表现出了一定的优势。</p><p>但是，因为通常业务实现都具有整体性，即使我们划分的层，每一层划分了独立模块，但是分层架构模式在如何解决模块之间的紧耦合方面没能给出很好的解法，从而最终导致应用在快速响应环境变化、是否易于部署、可扩展性等方面表现出了一定的弱势。</p><p>另外，由于分层的存在，不可避免的对应用性能将产生一定的影响。</p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><!----><!--[--><!--]--></main></div><!----><!----><!--]--></div>
    <script src="/assets/js/runtime~app.fa50ff6a.js" defer></script><script src="/assets/js/3767.b5b9e7ce.js" defer></script><script src="/assets/js/app.8de2a662.js" defer></script>
  </body>
</html>
