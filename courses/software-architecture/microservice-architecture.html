<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.webmanifest"><meta name="theme-color" content="#5397d2"><script>
      var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e772d8d7735057378a672ae311e9bf20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
    </script><title>微服务构模式 | 众里千寻</title><meta name="description" content="作为单体应用和面向服务架构模式的替代方案，微服务架构模式在业界迅速普及。本文介绍微服务架构的核心概念，以及选择该架构需要考虑的取舍问题。"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.fa50ff6a.js" as="script"><link rel="preload" href="/assets/css/styles.e0095a00.css" as="style"><link rel="preload" href="/assets/js/3767.b5b9e7ce.js" as="script"><link rel="preload" href="/assets/js/app.8de2a662.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.e0095a00.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><img class="logo" src="/hero-c.png" alt="众里千寻"><span class="site-name can-hide">众里千寻</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link router-link-active" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link router-link-active" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">微服务构模式</p><ul class=""><li><!--[--><a aria-current="page" href="/courses/software-architecture/microservice-architecture.html#模式介绍" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="模式介绍"><!--[--><!--]--> 模式介绍 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/microservice-architecture.html#拓扑结构" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="拓扑结构"><!--[--><!--]--> 拓扑结构 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/courses/software-architecture/microservice-architecture.html#基于-api-rest-的拓扑" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="基于 API REST 的拓扑"><!--[--><!--]--> 基于 API REST 的拓扑 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/microservice-architecture.html#基于应用-rest-的拓扑" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="基于应用 REST 的拓扑"><!--[--><!--]--> 基于应用 REST 的拓扑 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/microservice-architecture.html#基于集中式消息传递的拓扑" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="基于集中式消息传递的拓扑"><!--[--><!--]--> 基于集中式消息传递的拓扑 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/microservice-architecture.html#避免服务间的依赖和编排" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="避免服务间的依赖和编排"><!--[--><!--]--> 避免服务间的依赖和编排 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/microservice-architecture.html#其他说明" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="其他说明"><!--[--><!--]--> 其他说明 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/courses/software-architecture/microservice-architecture.html#小结" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="小结"><!--[--><!--]--> 小结 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><p>作为单体应用（monolithic application）和面向服务架构模式（service-oriented architectures，SOA）的替代方案，微服务架构模式（microservices architecture pattern）在业界迅速普及。本文介绍微服务架构的核心概念，以及选择该架构需要考虑的取舍问题。</p><h2 id="模式介绍" tabindex="-1"><a class="header-anchor" href="#模式介绍" aria-hidden="true">#</a> 模式介绍</h2><p>尽管由于业务场景不同，微服务架构的拓扑结构和实现方式都不同，但是一些核心概念是相同的。在这些概念中，首先要说明的就是独立部署单元（separately deployed units）。如下图说是，微服务架构中，每个服务组件都是作为独立单元单独部署。独立部署单元之间彼此解耦，可以方便集成持续部署流水线（continuous deployment pipeline）,并且扩展性也很高。</p><p><img src="/courses/software-architecture/basic-microservice-architecture-c.png" alt="基本的微服务架构"></p><p>在这些概念中，最重要的就是服务组件（service component）了。不像面向服务架构中的服务，服务组件的颗粒度可以非常灵活。服务组件可以仅仅是实现了一个具体功能的一到两个模块，也可以是应用中比较独立的一整块业务。因此，服务组件的颗粒度设计是整个微服务架构模式中最具挑战性的部分。</p><p>微服务架构是分布式的，架构中的所有组成部分都是彼此独立、解耦的，彼此间需要通过远程访问协议（remote access protocol）来通信，比如 JMS、AMQP、REST、SOAP、RMI 等。</p><p>微服务架构模式是由解决其他架构模式的问题而不断演化而来，主要来自于两方面：采用分层架构模式开发的单体应用和采用面向服务架构模式开发的分布式应用。</p><p>采用分层架构模式开发的单体应用，通常因为包含了很多彼此强耦合的单元而难以拆分，从而给变更、测试和持续部署带来的很多麻烦。某一个小问题可能导致整个应用宕机。微服务架构模式将应用拆分成很多个可以独立部署的单元（服务组件），从而可以方便的进行变更、测试和支持部署。</p><p>面向服务的架构模式（SOA）非常强大，并提供了无与伦比的抽象级别、异构连接、服务编排等能力，但是该模式太复杂，难以理解和实施，而且对于大多数应用来说通常是矫枉过正的。微服务架构模式通过简化服务的概念、消除编排需求以及简化对服务组件的连接和访问来解决这种复杂性。</p><h2 id="拓扑结构" tabindex="-1"><a class="header-anchor" href="#拓扑结构" aria-hidden="true">#</a> 拓扑结构</h2><p>微服务有三种主要的拓扑结构：基于 API REST （API REST-based topology）的拓扑、基于应用 REST 的拓扑（application REST-based topology）和基于集中式消息传递的拓扑（centralized messaging topology）。</p><h3 id="基于-api-rest-的拓扑" tabindex="-1"><a class="header-anchor" href="#基于-api-rest-的拓扑" aria-hidden="true">#</a> 基于 API REST 的拓扑</h3><p><img src="/courses/software-architecture/microservice-api-rest-based-c.png" alt="基于 API REST 的拓扑"></p><p>如上图所示，基于 API REST 的拓扑包含很多细粒度的服务组件，每个服务组件仅仅包含一到两个模块，实现了与其他服务彼此独立的某一项具体的业务动作。这些服务组件通常由一个独立部署的基于 REST 的 Web API 来访问。</p><p>这种拓扑结构通常被用于那些提供单一功能的 RESTful web 服务中，这些 web 服务在 Google、Amazon 等云服务厂商中非常常见。</p><h3 id="基于应用-rest-的拓扑" tabindex="-1"><a class="header-anchor" href="#基于应用-rest-的拓扑" aria-hidden="true">#</a> 基于应用 REST 的拓扑</h3><p><img src="/courses/software-architecture/microservice-application-rest-based-c.png" alt="基于应用 REST 的拓扑"></p><p>上图展示了基于应用 REST 的拓扑结构。与基于 API REST 的拓扑结构不同的是，通常用户请求不是简单的访问一个 Web API 就可以实现，而是需要通过一个具体的 UI 层。</p><p>基于应用 REST 的拓扑结构中的服务组件，也比基于 API REST 拓扑中的服务组件更大，颗粒度更粗，通常包含整个应用中某一块业务功能。</p><p>基于应用 REST 的拓扑结构通常被用于规模较小、或者中等规模的应用中。</p><h3 id="基于集中式消息传递的拓扑" tabindex="-1"><a class="header-anchor" href="#基于集中式消息传递的拓扑" aria-hidden="true">#</a> 基于集中式消息传递的拓扑</h3><p><img src="/courses/software-architecture/microservice-centralized-messaging-c.png" alt="基于集中式消息传递的拓扑"></p><p>上图展示了基于集中式消息传递的拓扑结构。与基于应用 REST 的拓扑结构类似，但是基于集中式消息传递的拓扑结构不再使用 REST 来访问服务，而是通过一些轻量级的集中式消息代理（比如 ActiveMQ、HornetQ 等）来访问服务。</p><p>集中式消息传递拓扑通常被用于较大的业务应用，或者那些需要对用户 UI 和服务组件之间的数据传输进行复杂控制的应用中。与前面讨论的拓扑结构相比，这种拓扑结构的好处是有先进的排队机制、异步消息传递、监控、错误处理以及更好的整体负载平衡和可扩展性。</p><h2 id="避免服务间的依赖和编排" tabindex="-1"><a class="header-anchor" href="#避免服务间的依赖和编排" aria-hidden="true">#</a> 避免服务间的依赖和编排</h2><p>微服务架构模式的一大挑战是服务颗粒度的设计。颗粒度太粗无法享受到快速变更、 持续部署、低耦合、高扩展性等优势，颗粒度太小有不得不引起服务之间的编排需求，从而不得不面对成面向服务架构的问题。</p><p>如果发现我们不得不引入服务编排时，说明服务组件的颗粒度太细了。类似的，如果发现我们需要建立服务组件间的通信，而这些通信仅仅是为了满足简单的用户请求，那么说明服务组件的颗粒度太细了，或者说当前的业务场景不适合微服务架构模式。</p><p>有时候服务组件之间有一些公共的功能需要共享（比如工具函数等），在微服务架构模式中，我们建议允许一定的代码重复。这样可以保持服务之间相互独立，避免产生依赖，从而保证变更、持续部署方便。</p><h2 id="其他说明" tabindex="-1"><a class="header-anchor" href="#其他说明" aria-hidden="true">#</a> 其他说明</h2><p>微服务架构解决了单体应用和面向服务架构的应用的很多共性问题。大的应用被拆分成多个小的、可独立部署的服务。应用的健壮性、可扩展性都得到了极大的提高，同时可以更方便的与持续部署系统集成。</p><p>由于变更产生在相互独立的服务中，单个服务的变更不影响其他服务，我们可以在生产环境做实时部署，而不需要在周末或非工作时间做发布。同时，我们可以启用多个服务实例，实现滚动发布，做到用户无感。</p><p>微服务架构是分布式的，因此有着与事件驱动的架构模式相同的问题。比如协议设计、服务的管理、系统可用性、访问控制等问题。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>由于整个应用被划分成多个独立部署单元，彼此之间相互独立，因此整个应用可以快速的响应变化。在测试、快速部署等方面优势明显，同时还具备了很高的可扩展性。也正是由于应用被划分成了多个独立单元，开发人员心智负担也更小，开发也更加便利了。</p><p>与大部分的分布式系统相同，尽管应用本身可以实现不错的性能，但是微服务架构模式并不是为了解决性能问题而设计的，在性能方面会相对弱势一些。</p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><!----><!--[--><!--]--></main></div><!----><!----><!--]--></div>
    <script src="/assets/js/runtime~app.fa50ff6a.js" defer></script><script src="/assets/js/3767.b5b9e7ce.js" defer></script><script src="/assets/js/app.8de2a662.js" defer></script>
  </body>
</html>
