"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[487],{9984:(e,t,r)=>{r.r(t),r.d(t,{data:()=>n});const n={key:"v-799ea5f4",path:"/courses/software-architecture/",title:"软件架构学习笔记",lang:"zh-CN",frontmatter:{title:"软件架构学习笔记",description:"了解每种架构模式的特征、优势和劣势对于选择满足特定业务需求和目标的架构模式是必要的。本系列会详细介绍集中常见的软件架构模式，并分析他们的优缺点。",sidebar:!1,date:"2022-01-14T00:00:00.000Z"},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[],filePathRelative:"courses/software-architecture/README.md",articleList:[{key:"v-cccc7f54",path:"/courses/software-architecture/event-driven-architecture.html",title:"事件驱动架构模式",lang:"zh-CN",frontmatter:{title:"事件驱动架构模式",description:"事件驱动架构模式是常见的分布式异步架构模式，通常被用来创建具备高扩展性的应用。事件驱动架构由高度解耦、单一用途的事件处理器组成，这些组件异步接收和处理事件。",keywords:["Event Driven Architecture","事件驱动架构"],date:"2022-01-17T00:00:00.000Z",key:2},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"调解器拓扑",slug:"调解器拓扑",children:[]},{level:2,title:"代理拓扑",slug:"代理拓扑",children:[]},{level:2,title:"其他说明",slug:"其他说明",children:[]},{level:2,title:"思考",slug:"思考",children:[]}],content:"\n事件驱动架构模式是常见的分布式异步架构模式，通常被用来创建具备高扩展性的应用。其适应性也很强，即可用于小型应用，也可用于大型复杂应用。事件驱动架构由高度解耦、单一用途的事件处理器组成，这些组件异步接收和处理事件。\n\n事件驱动架构模式包含两种拓扑结构：调解器（mediator）拓扑和代理（broker）拓扑。当我们需要通过中央调解器在事件中编排多个步骤时，通常使用调解器拓扑，而当您希望在不使用中央调解器的情况下将事件链接在一起时，则使用代理拓扑。\n\n由于这两种拓扑的架构特征和实现策略不同，我们需要详细了解每种拓扑结构，才能确定在具体的业务场景下，那种拓扑结构更适合我们。\n\n## 调解器拓扑\n\n调解器拓扑非常适合那些事件具有多个步骤并且需要某种程度的编排来处理事件的场景。\n\n比如，进行股票交易的单个事件可能要求首先验证交易，然后根据各种合规规则检查该股票交易的合规性，将交易分配给经纪人，计算佣金，最后由经纪人进行交易。所有的这些步骤都需要一定的编排，来确定步骤的顺序，以及哪些步骤是可以并行的，哪些步骤是要顺序执行的。\n\n在调解器拓扑中主要有四种类型的组件：事件队列（event queue）、事件调解器（event mediator）、事件通道（event channel）和事件处理器（event processor）。\n\n事件流从客户端向事件队列发送事件开始，事件队列用于将事件传输到事件调解器。事件调解器接收初始事件，之后通过向事件通道发送额外的异步事件来实现编排收到的事件，以执行流程的每个步骤。事件处理器监听事件通道，从事件调解器接收事件并执行特定的业务逻辑来处理事件。\n\n下图展示了调解器拓扑结构。\n\n![调解器拓扑结构](/courses/software-architecture/event-driven-architecture-mediator-c.png)\n\n在事件驱动架构模式中，通常有几十到几百个事件队列，并且模式对实现事件队列没有技术要求，可以使用消息队列，也可以使用 web 服务等等。\n\n该模式中的事件有两种类型：初始事件和处理事件。初始事件是调解器接收到的原始事件，而处理事件是由调解器生成并由事件处理器接收的事件。\n\n事件调解器负责编排初始事件中包含的步骤。对于初始事件中的每一步，事件调解器都会将特定的处理事件发送给事件通道，然后由事件处理器接收和处理。需要注意的是，事件调解器实际上并不执行处理初始事件所需的业务逻辑。相反，它知道处理初始事件所需的步骤。\n\n事件调解器使用事件通道将与初始事件中的每个步骤相关的特定处理事件异步传递给事件处理器。事件通道可以是消息队列或消息主题（消息主题使用更加广泛）。处理事件可以由多个事件处理器处理，每个事件处理器根据接收到的处理事件执行不同的任务。\n\n事件处理器是自包含、独立且高度解耦的，它们接收处理事件，然后执行特定任务。事件处理器的粒度可以从细粒度（例如，计算订单的销售税）到粗粒度（例如，处理保险索赔），但是一般来说，每个事件处理器应该执行单个业务任务，而不是依赖其他事件处理器来完成其特定任务。\n\n![调解器拓扑样例](/courses/software-architecture/mediator-example-c.png)\n\n上图展示了在保险公司处理用户搬迁的业务场景中，调解器拓扑是如何工作的。\n\n在这个业务场景中，初始事件叫 relocation event。处理 relocation event 所涉及的步骤包含在事件调解器中。对于每个初始事件步骤，事件调解器会创建一个处理事件（例如，更改地址、重新计算报价等），然后将该处理事件发送到事件通道并等待相应事件处理器处理该处理事件（例如、客户流程、报价流程等）。这个过程一直持续到初始事件中的所有步骤都已处理完毕。事件调解器中重新计算报价和更新声明步骤上方的单条表示这些步骤可以并行运行。\n\n## 代理拓扑\n\n与调解器拓扑不同的是，代理拓扑没有中央事件调解器。相反，消息流以链式方式分布在事件处理器中。当我们有一个相对简单的事件处理流程并且不想要（或不需要）中央事件编排时，此拓扑结构很有用。\n\n在代理拓扑结构中有两个主要组件：代理器和事件处理器。代理器可以是集中式或联合式的，它包含事件流中使用的所有事件通道。\n\n![代理拓扑结构](/courses/software-architecture/event-driven-architecture-broker-c.png)\n\n如上图所示，在代理拓扑结构中没有中央事件编排，每个事件处理器负责处理事件并发布一个新事件，这个新的事件表示时间处理器刚刚执行的操作。\n\n我们用调解器拓扑结构中的例子（保险人搬迁）来说明代理拓扑结构。如下图所示。\n\n![代理拓扑样例](/courses/software-architecture/broker-example-c.png)\n\n由于在代理拓扑中没有中央事件调解器来接收初始事件，因此 customer process 直接接收事件，更改客户地址，并发送一个事件，说明它更改了客户的地址（例如，change address event）。在上图中，有两个事件处理器对 change address event 感兴趣：报价流程（quote process）和索赔流程（claims process）。报价处理器根据地址更改重新计算新的自动保险费率，并向系统的其余部分发布一个事件，表明它做了什么（例如，recalc quote event）。另一方面，索赔处理器接收相同的更改地址事件，然后更新未完成的保险索赔并发布一个新的事件（例如，update claim event）到系统中。然后这些新事件被其他事件处理器获取，并且事件链条继续在系统中延伸下去，直到没有针对该特定初始事件发布更多的事件。\n\n就像接力赛一样，代理拓扑结构中的每个事件处理器只处理整个事件链条中的一段，整个事件链条串联起了完整的业务逻辑。\n\n## 其他说明\n\n因为异步并且是分布式的特性，事件驱动架构模式实现起来比较复杂，需要解决各种分布式架构问题，例如远程进程可用性、缺乏响应性以及代理失败时的重新连接等问题。\n\n除此以外，在使用事件驱动架构模式的时候，需要着重考虑的一个问题是，该模式缺少原子事务能力。\n\n因为事件处理器是高度解耦并且是分布式的，我们很难再多个事件处理器间实现原子事务。因此我们需要不停的思考哪些事件是可以原子化执行的，哪些是不能原子化执行的，以此来设计事件处理器的颗粒度。如果我们发现需要通过多个事件处理器来实现一个单元业务逻辑，换句话说我们需要通过多个事件处理器来处理一段不可分割的业务逻辑时，事件驱动模式可能不适合我们当前的业务场景。\n\n在事件驱动架构模式中还有一个问题至关重要，那就是事件处理器之间的通信协议的设计。比如可以是 JSON、XML 等等，在根据实际的业务需要确定好协议形式以后，最好再加上版本控制。\n\n## 思考\n因为事件处理器是高度解耦的，各自之间相互独立，因此可以快速响应变化，同时单个事件处理器的变更不会影响其他事件处理器。\n\n在部署方面，代理拓扑结构比调解器拓扑结构更加易于部署，因为调解器拓扑结构的变更通常要涉及到中间调解器和事件处理器。\n\n因为异步和分布式的特点，事件驱动架构模式通常具有比较好的性能和扩展性。同时也因为这个特点，在开发方面，开发团队需要负责更多的开发成本，比如制定通信协议以及制定必要的错误描述系统等。\n",contentRendered:'<p>事件驱动架构模式是常见的分布式异步架构模式，通常被用来创建具备高扩展性的应用。其适应性也很强，即可用于小型应用，也可用于大型复杂应用。事件驱动架构由高度解耦、单一用途的事件处理器组成，这些组件异步接收和处理事件。</p>\n<p>事件驱动架构模式包含两种拓扑结构：调解器（mediator）拓扑和代理（broker）拓扑。当我们需要通过中央调解器在事件中编排多个步骤时，通常使用调解器拓扑，而当您希望在不使用中央调解器的情况下将事件链接在一起时，则使用代理拓扑。</p>\n<p>由于这两种拓扑的架构特征和实现策略不同，我们需要详细了解每种拓扑结构，才能确定在具体的业务场景下，那种拓扑结构更适合我们。</p>\n<h2 id="调解器拓扑" tabindex="-1"><a class="header-anchor" href="#调解器拓扑" aria-hidden="true">#</a> 调解器拓扑</h2>\n<p>调解器拓扑非常适合那些事件具有多个步骤并且需要某种程度的编排来处理事件的场景。</p>\n<p>比如，进行股票交易的单个事件可能要求首先验证交易，然后根据各种合规规则检查该股票交易的合规性，将交易分配给经纪人，计算佣金，最后由经纪人进行交易。所有的这些步骤都需要一定的编排，来确定步骤的顺序，以及哪些步骤是可以并行的，哪些步骤是要顺序执行的。</p>\n<p>在调解器拓扑中主要有四种类型的组件：事件队列（event queue）、事件调解器（event mediator）、事件通道（event channel）和事件处理器（event processor）。</p>\n<p>事件流从客户端向事件队列发送事件开始，事件队列用于将事件传输到事件调解器。事件调解器接收初始事件，之后通过向事件通道发送额外的异步事件来实现编排收到的事件，以执行流程的每个步骤。事件处理器监听事件通道，从事件调解器接收事件并执行特定的业务逻辑来处理事件。</p>\n<p>下图展示了调解器拓扑结构。</p>\n<p><img src="/courses/software-architecture/event-driven-architecture-mediator-c.png" alt="调解器拓扑结构"></p>\n<p>在事件驱动架构模式中，通常有几十到几百个事件队列，并且模式对实现事件队列没有技术要求，可以使用消息队列，也可以使用 web 服务等等。</p>\n<p>该模式中的事件有两种类型：初始事件和处理事件。初始事件是调解器接收到的原始事件，而处理事件是由调解器生成并由事件处理器接收的事件。</p>\n<p>事件调解器负责编排初始事件中包含的步骤。对于初始事件中的每一步，事件调解器都会将特定的处理事件发送给事件通道，然后由事件处理器接收和处理。需要注意的是，事件调解器实际上并不执行处理初始事件所需的业务逻辑。相反，它知道处理初始事件所需的步骤。</p>\n<p>事件调解器使用事件通道将与初始事件中的每个步骤相关的特定处理事件异步传递给事件处理器。事件通道可以是消息队列或消息主题（消息主题使用更加广泛）。处理事件可以由多个事件处理器处理，每个事件处理器根据接收到的处理事件执行不同的任务。</p>\n<p>事件处理器是自包含、独立且高度解耦的，它们接收处理事件，然后执行特定任务。事件处理器的粒度可以从细粒度（例如，计算订单的销售税）到粗粒度（例如，处理保险索赔），但是一般来说，每个事件处理器应该执行单个业务任务，而不是依赖其他事件处理器来完成其特定任务。</p>\n<p><img src="/courses/software-architecture/mediator-example-c.png" alt="调解器拓扑样例"></p>\n<p>上图展示了在保险公司处理用户搬迁的业务场景中，调解器拓扑是如何工作的。</p>\n<p>在这个业务场景中，初始事件叫 relocation event。处理 relocation event 所涉及的步骤包含在事件调解器中。对于每个初始事件步骤，事件调解器会创建一个处理事件（例如，更改地址、重新计算报价等），然后将该处理事件发送到事件通道并等待相应事件处理器处理该处理事件（例如、客户流程、报价流程等）。这个过程一直持续到初始事件中的所有步骤都已处理完毕。事件调解器中重新计算报价和更新声明步骤上方的单条表示这些步骤可以并行运行。</p>\n<h2 id="代理拓扑" tabindex="-1"><a class="header-anchor" href="#代理拓扑" aria-hidden="true">#</a> 代理拓扑</h2>\n<p>与调解器拓扑不同的是，代理拓扑没有中央事件调解器。相反，消息流以链式方式分布在事件处理器中。当我们有一个相对简单的事件处理流程并且不想要（或不需要）中央事件编排时，此拓扑结构很有用。</p>\n<p>在代理拓扑结构中有两个主要组件：代理器和事件处理器。代理器可以是集中式或联合式的，它包含事件流中使用的所有事件通道。</p>\n<p><img src="/courses/software-architecture/event-driven-architecture-broker-c.png" alt="代理拓扑结构"></p>\n<p>如上图所示，在代理拓扑结构中没有中央事件编排，每个事件处理器负责处理事件并发布一个新事件，这个新的事件表示时间处理器刚刚执行的操作。</p>\n<p>我们用调解器拓扑结构中的例子（保险人搬迁）来说明代理拓扑结构。如下图所示。</p>\n<p><img src="/courses/software-architecture/broker-example-c.png" alt="代理拓扑样例"></p>\n<p>由于在代理拓扑中没有中央事件调解器来接收初始事件，因此 customer process 直接接收事件，更改客户地址，并发送一个事件，说明它更改了客户的地址（例如，change address event）。在上图中，有两个事件处理器对 change address event 感兴趣：报价流程（quote process）和索赔流程（claims process）。报价处理器根据地址更改重新计算新的自动保险费率，并向系统的其余部分发布一个事件，表明它做了什么（例如，recalc quote event）。另一方面，索赔处理器接收相同的更改地址事件，然后更新未完成的保险索赔并发布一个新的事件（例如，update claim event）到系统中。然后这些新事件被其他事件处理器获取，并且事件链条继续在系统中延伸下去，直到没有针对该特定初始事件发布更多的事件。</p>\n<p>就像接力赛一样，代理拓扑结构中的每个事件处理器只处理整个事件链条中的一段，整个事件链条串联起了完整的业务逻辑。</p>\n<h2 id="其他说明" tabindex="-1"><a class="header-anchor" href="#其他说明" aria-hidden="true">#</a> 其他说明</h2>\n<p>因为异步并且是分布式的特性，事件驱动架构模式实现起来比较复杂，需要解决各种分布式架构问题，例如远程进程可用性、缺乏响应性以及代理失败时的重新连接等问题。</p>\n<p>除此以外，在使用事件驱动架构模式的时候，需要着重考虑的一个问题是，该模式缺少原子事务能力。</p>\n<p>因为事件处理器是高度解耦并且是分布式的，我们很难再多个事件处理器间实现原子事务。因此我们需要不停的思考哪些事件是可以原子化执行的，哪些是不能原子化执行的，以此来设计事件处理器的颗粒度。如果我们发现需要通过多个事件处理器来实现一个单元业务逻辑，换句话说我们需要通过多个事件处理器来处理一段不可分割的业务逻辑时，事件驱动模式可能不适合我们当前的业务场景。</p>\n<p>在事件驱动架构模式中还有一个问题至关重要，那就是事件处理器之间的通信协议的设计。比如可以是 JSON、XML 等等，在根据实际的业务需要确定好协议形式以后，最好再加上版本控制。</p>\n<h2 id="思考" tabindex="-1"><a class="header-anchor" href="#思考" aria-hidden="true">#</a> 思考</h2>\n<p>因为事件处理器是高度解耦的，各自之间相互独立，因此可以快速响应变化，同时单个事件处理器的变更不会影响其他事件处理器。</p>\n<p>在部署方面，代理拓扑结构比调解器拓扑结构更加易于部署，因为调解器拓扑结构的变更通常要涉及到中间调解器和事件处理器。</p>\n<p>因为异步和分布式的特点，事件驱动架构模式通常具有比较好的性能和扩展性。同时也因为这个特点，在开发方面，开发团队需要负责更多的开发成本，比如制定通信协议以及制定必要的错误描述系统等。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-01-17",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/software-architecture/event-driven-architecture.html",pathLocale:"/",permalink:null,slug:"event-driven-architecture",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/software-architecture/event-driven-architecture.md",filePathRelative:"courses/software-architecture/event-driven-architecture.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/event-driven-architecture.html.vue",componentFilePathRelative:"pages/courses/software-architecture/event-driven-architecture.html.vue",componentFileChunkName:"v-cccc7f54",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/event-driven-architecture.html.js",dataFilePathRelative:"pages/courses/software-architecture/event-driven-architecture.html.js",dataFileChunkName:"v-cccc7f54",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/software-architecture/event-driven-architecture.html",htmlFilePathRelative:"courses/software-architecture/event-driven-architecture.html"},{key:"v-56121e43",path:"/courses/software-architecture/layered-architecture.html",title:"分层架构模式",lang:"zh-CN",frontmatter:{title:"分层架构模式",description:"分层架构模式是最常见的架构模式。这种模式是大多数 Java EE 应用程序的事实标准。分层架构模式与大多数公司中组织结构紧密匹配，使其成为大多数业务应用程序开发工作的自然选择。",keywords:["Layered Architecture","分层架构"],date:"2022-01-14T00:00:00.000Z",key:1},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"模式介绍",slug:"模式介绍",children:[]},{level:2,title:"一些关键概念",slug:"一些关键概念",children:[]},{level:2,title:"举例说明",slug:"举例说明",children:[]},{level:2,title:"其他说明",slug:"其他说明",children:[]},{level:2,title:"思考",slug:"思考",children:[]}],content:"\n分层架构模式，最常见的架构模式。在 Java EE 应用开发实践中，分层架构模式已经是事实上的标准。\n\n## 模式介绍\n\n分层架构模式中的每一层通常是水平的，并且在整个应用中有着特定的角色（比如负责展示、负责业务逻辑等）。虽然不同的业务场景分层不一样，但是分层架构模式通常有四层，表现层（presentation）、业务逻辑层（business）、持久化层（persistence）和数据库层（database），如下图。\n\n![分层架构模式](/courses/software-architecture/layered-architecture-c.png)\n\n每一层都有特定的职责。比如表现层负责处理 UI 展示以及与浏览器之间的交互，而业务逻辑层则负责处理具体的业务逻辑。每一层都针对其负责的职责进行了一定的抽象，并且仅对此负责。比如业务逻辑层只关心如何处理好业务请求，不关心 UI 究竟是如何展示的。业内有一个专业术语，叫关注点分离（separation of concerns），表达的意思是一样的。\n\n## 一些关键概念\n\n![封闭层](/courses/software-architecture/closed-layer-c.png)\n\n上图中，每一层都被标记为是封闭的（closed）。这是分层架构模式中非常重要的一个概念。意思是说，用户请求如果要从上层去到下层，则必须一层一层的穿过中间的所有层。比如一个用户请求必须要先经过表现层，然后经过业务逻辑层，再经过持久化层，最终到达数据库层。\n\n那为什么不能直接从表现层直接到达数据库层呢？毕竟这样有着更好的性能。这就要引入隔离层（layers of isolation）的概念了。隔离层要求某一层中变化的影响范围尽量保持在当前层内，或者仅仅影响到与之相邻的层。比如数据库层的变化，影响范围尽量保持在数据库层内，或者仅仅影响到持久化层（当持久化层中存在直接通过 SQL 操作数据库的情况时）。\n\n如果不加这层限制的话，比如允许表现层直接操作数据库，那么当数据库层发生变更时，表现层也会受到影响，这样每一层之间就会存在强烈的耦合。这样就是的整个架构后期很难维护和迭代。\n\n同时，隔离层也意味着每一层都是独立的，对其它层的内部细节知之甚少。当我们需要重构表现层时，因为每个分层都是独立的，我们可以直接复用业务逻辑层。\n\n虽然封闭层有助于实现隔离层，因此有助于隔离架构内的变化，但有时开放某些层是有意义的。\n\n比如，当我们有一些公共服务模块（数据、字符串处理类，审计和日志类等）要提供给业务逻辑层使用。最好的做法是引入一个公共服务层。因为这样可以很好的在架构层面避免其他层使用公共服务层的逻辑。\n\n但是这么做又有明显的缺点，那就是由于封闭性，所有的用户请求都要从公共服务层经过，而很多时候这是多余的。开放层（open layer）可以帮助我们解决这个问题。\n\n![开放层](/courses/software-architecture/open-layer-c.png)\n\n如上图所示，公共服务层被标记为开放的，这样业务逻辑层就可以穿过公共服务层直接访问持久化层。\n\n利用好开放层和封闭层的概念有助于定义清楚架构中的每一层和请求流之间的关系，并为设计人员和开发人员提供必要的信息，以了解架构内的各种层间访问限制。\n\n## 举例说明\n\n假设一个用户请求查询特定个人的客户信息，如下图所示。黑色箭头表示向下流向数据库以查询客户数据的请求，红色箭头表示向上流向屏幕以显示数据的响应。\n\n![分层架构样例](/courses/software-architecture/layered-architecture-example-c.png)\n\n在此例中，客户信息由客户数据和订单数据（客户下的订单）组成。客户屏幕负责接受请求并显示客户信息。它不知道数据在哪里，如何查询，或者必须查询多少个数据库表才能获取数据。一旦表现层收到获取特定个人客户信息的请求，它就会将该请求转发到客户委托模块（Customer Delegate）。该模块了解业务层中的哪些模块可以处理该请求，如何访问这些模块以及它需要哪些数据。\n\n业务逻辑层中的客户对象负责聚合业务请求所需的所有信息（在本例中是获取客户信息）。该模块调用持久层中的 customer dao（数据访问对象）模块获取客户数据，同时调用 order dao 模块获取订单信息。这些模块依次执行 SQL 语句以检索相应的数据并将其传回业务逻辑层中的客户对象。\n\n一旦客户对象接收到数据，它就会聚合数据并将该信息传回给客户委托模块，然后客户委托模块将该数据传递给客户屏幕以呈现给用户。\n\n从技术角度来说，每一层的具体实现方式不受限制，可以由团队根据自身的技术特定和实际的业务需求自行决定。\n\n## 其他说明\n\n分层架构模式是一种可靠的通用模式。但是也有两个问题需要注意。\n\n第一个问题是反模式问题。比如如果我们的分层中很多都是直接透传，比如表现层访问业务逻辑层，而业务逻辑层实际上什么事情也没做，直接透传给了持久化层，最后达到数据库层，然后数据再同样反向返回回来。\n\n如何来解决这样的问题呢？可以参考一下二八原则。也就是说，如果有百分之八十的情况下，业务请求在每一层都有处理逻辑的，百分之二十的情况下存在透传场景，那么可以认为分层是合理的。如果超过百分之二十的场景都需要透传，那么可以考虑将某些层标记为开放的。\n\n第二个问题是分层架构模式通常最后会导致巨石应用的问题。即使我们在每一层都划分了独立模块，可以独立部署。对于某些应用来说，分层架构模式确实在部署、总体健壮性和可靠性、性能和可扩展性方面存在一些潜在问题。\n\n## 思考\n\n分层架构模式是比较常见的架构模式，每一层的职责明确，通常也与人员的组织架构相匹配（康威定律）。同时因为隔离层的特性，结合开放层和封闭层，可以很好的实现业务需求，同时保持一定的独立性。在是否易于测试、是否易于开发等方面表现出了一定的优势。\n\n但是，因为通常业务实现都具有整体性，即使我们划分的层，每一层划分了独立模块，但是分层架构模式在如何解决模块之间的紧耦合方面没能给出很好的解法，从而最终导致应用在快速响应环境变化、是否易于部署、可扩展性等方面表现出了一定的弱势。\n\n另外，由于分层的存在，不可避免的对应用性能将产生一定的影响。\n",contentRendered:'<p>分层架构模式，最常见的架构模式。在 Java EE 应用开发实践中，分层架构模式已经是事实上的标准。</p>\n<h2 id="模式介绍" tabindex="-1"><a class="header-anchor" href="#模式介绍" aria-hidden="true">#</a> 模式介绍</h2>\n<p>分层架构模式中的每一层通常是水平的，并且在整个应用中有着特定的角色（比如负责展示、负责业务逻辑等）。虽然不同的业务场景分层不一样，但是分层架构模式通常有四层，表现层（presentation）、业务逻辑层（business）、持久化层（persistence）和数据库层（database），如下图。</p>\n<p><img src="/courses/software-architecture/layered-architecture-c.png" alt="分层架构模式"></p>\n<p>每一层都有特定的职责。比如表现层负责处理 UI 展示以及与浏览器之间的交互，而业务逻辑层则负责处理具体的业务逻辑。每一层都针对其负责的职责进行了一定的抽象，并且仅对此负责。比如业务逻辑层只关心如何处理好业务请求，不关心 UI 究竟是如何展示的。业内有一个专业术语，叫关注点分离（separation of concerns），表达的意思是一样的。</p>\n<h2 id="一些关键概念" tabindex="-1"><a class="header-anchor" href="#一些关键概念" aria-hidden="true">#</a> 一些关键概念</h2>\n<p><img src="/courses/software-architecture/closed-layer-c.png" alt="封闭层"></p>\n<p>上图中，每一层都被标记为是封闭的（closed）。这是分层架构模式中非常重要的一个概念。意思是说，用户请求如果要从上层去到下层，则必须一层一层的穿过中间的所有层。比如一个用户请求必须要先经过表现层，然后经过业务逻辑层，再经过持久化层，最终到达数据库层。</p>\n<p>那为什么不能直接从表现层直接到达数据库层呢？毕竟这样有着更好的性能。这就要引入隔离层（layers of isolation）的概念了。隔离层要求某一层中变化的影响范围尽量保持在当前层内，或者仅仅影响到与之相邻的层。比如数据库层的变化，影响范围尽量保持在数据库层内，或者仅仅影响到持久化层（当持久化层中存在直接通过 SQL 操作数据库的情况时）。</p>\n<p>如果不加这层限制的话，比如允许表现层直接操作数据库，那么当数据库层发生变更时，表现层也会受到影响，这样每一层之间就会存在强烈的耦合。这样就是的整个架构后期很难维护和迭代。</p>\n<p>同时，隔离层也意味着每一层都是独立的，对其它层的内部细节知之甚少。当我们需要重构表现层时，因为每个分层都是独立的，我们可以直接复用业务逻辑层。</p>\n<p>虽然封闭层有助于实现隔离层，因此有助于隔离架构内的变化，但有时开放某些层是有意义的。</p>\n<p>比如，当我们有一些公共服务模块（数据、字符串处理类，审计和日志类等）要提供给业务逻辑层使用。最好的做法是引入一个公共服务层。因为这样可以很好的在架构层面避免其他层使用公共服务层的逻辑。</p>\n<p>但是这么做又有明显的缺点，那就是由于封闭性，所有的用户请求都要从公共服务层经过，而很多时候这是多余的。开放层（open layer）可以帮助我们解决这个问题。</p>\n<p><img src="/courses/software-architecture/open-layer-c.png" alt="开放层"></p>\n<p>如上图所示，公共服务层被标记为开放的，这样业务逻辑层就可以穿过公共服务层直接访问持久化层。</p>\n<p>利用好开放层和封闭层的概念有助于定义清楚架构中的每一层和请求流之间的关系，并为设计人员和开发人员提供必要的信息，以了解架构内的各种层间访问限制。</p>\n<h2 id="举例说明" tabindex="-1"><a class="header-anchor" href="#举例说明" aria-hidden="true">#</a> 举例说明</h2>\n<p>假设一个用户请求查询特定个人的客户信息，如下图所示。黑色箭头表示向下流向数据库以查询客户数据的请求，红色箭头表示向上流向屏幕以显示数据的响应。</p>\n<p><img src="/courses/software-architecture/layered-architecture-example-c.png" alt="分层架构样例"></p>\n<p>在此例中，客户信息由客户数据和订单数据（客户下的订单）组成。客户屏幕负责接受请求并显示客户信息。它不知道数据在哪里，如何查询，或者必须查询多少个数据库表才能获取数据。一旦表现层收到获取特定个人客户信息的请求，它就会将该请求转发到客户委托模块（Customer Delegate）。该模块了解业务层中的哪些模块可以处理该请求，如何访问这些模块以及它需要哪些数据。</p>\n<p>业务逻辑层中的客户对象负责聚合业务请求所需的所有信息（在本例中是获取客户信息）。该模块调用持久层中的 customer dao（数据访问对象）模块获取客户数据，同时调用 order dao 模块获取订单信息。这些模块依次执行 SQL 语句以检索相应的数据并将其传回业务逻辑层中的客户对象。</p>\n<p>一旦客户对象接收到数据，它就会聚合数据并将该信息传回给客户委托模块，然后客户委托模块将该数据传递给客户屏幕以呈现给用户。</p>\n<p>从技术角度来说，每一层的具体实现方式不受限制，可以由团队根据自身的技术特定和实际的业务需求自行决定。</p>\n<h2 id="其他说明" tabindex="-1"><a class="header-anchor" href="#其他说明" aria-hidden="true">#</a> 其他说明</h2>\n<p>分层架构模式是一种可靠的通用模式。但是也有两个问题需要注意。</p>\n<p>第一个问题是反模式问题。比如如果我们的分层中很多都是直接透传，比如表现层访问业务逻辑层，而业务逻辑层实际上什么事情也没做，直接透传给了持久化层，最后达到数据库层，然后数据再同样反向返回回来。</p>\n<p>如何来解决这样的问题呢？可以参考一下二八原则。也就是说，如果有百分之八十的情况下，业务请求在每一层都有处理逻辑的，百分之二十的情况下存在透传场景，那么可以认为分层是合理的。如果超过百分之二十的场景都需要透传，那么可以考虑将某些层标记为开放的。</p>\n<p>第二个问题是分层架构模式通常最后会导致巨石应用的问题。即使我们在每一层都划分了独立模块，可以独立部署。对于某些应用来说，分层架构模式确实在部署、总体健壮性和可靠性、性能和可扩展性方面存在一些潜在问题。</p>\n<h2 id="思考" tabindex="-1"><a class="header-anchor" href="#思考" aria-hidden="true">#</a> 思考</h2>\n<p>分层架构模式是比较常见的架构模式，每一层的职责明确，通常也与人员的组织架构相匹配（康威定律）。同时因为隔离层的特性，结合开放层和封闭层，可以很好的实现业务需求，同时保持一定的独立性。在是否易于测试、是否易于开发等方面表现出了一定的优势。</p>\n<p>但是，因为通常业务实现都具有整体性，即使我们划分的层，每一层划分了独立模块，但是分层架构模式在如何解决模块之间的紧耦合方面没能给出很好的解法，从而最终导致应用在快速响应环境变化、是否易于部署、可扩展性等方面表现出了一定的弱势。</p>\n<p>另外，由于分层的存在，不可避免的对应用性能将产生一定的影响。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-01-14",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/software-architecture/layered-architecture.html",pathLocale:"/",permalink:null,slug:"layered-architecture",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/software-architecture/layered-architecture.md",filePathRelative:"courses/software-architecture/layered-architecture.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/layered-architecture.html.vue",componentFilePathRelative:"pages/courses/software-architecture/layered-architecture.html.vue",componentFileChunkName:"v-56121e43",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/layered-architecture.html.js",dataFilePathRelative:"pages/courses/software-architecture/layered-architecture.html.js",dataFileChunkName:"v-56121e43",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/software-architecture/layered-architecture.html",htmlFilePathRelative:"courses/software-architecture/layered-architecture.html"},{key:"v-3c2fb554",path:"/courses/software-architecture/microkernel-architecture.html",title:"微内核架构模式",lang:"zh-CN",frontmatter:{title:"微内核架构模式",description:"微内核架构模式（有时也称为插件架构模式）通常被应用于实现基于产品的应用程序。该模式允许我们将附加的应用程序功能作为插件添加到核心应用程序中，提供可扩展性以及额外的功能。",keywords:["Microkernel Architecture","Plugin-in Architecture","微内核架构","插件架构"],date:"2022-01-18T00:00:00.000Z",key:3},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"模式介绍",slug:"模式介绍",children:[]},{level:2,title:"举例说明",slug:"举例说明",children:[]},{level:2,title:"其他说明",slug:"其他说明",children:[]},{level:2,title:"思考",slug:"思考",children:[]}],content:"\n微内核架构模式（有时也称为插件架构模式）通常被应用于实现基于产品的应用程序。基于产品的应用程序是一种基于某一个现有产品开发，作为典型第三方产品打包并可供下载的应用程序。微内核架构模式允许我们将附加的应用程序功能作为插件添加到核心应用程序中，提供可扩展性以及额外的功能。\n\n## 模式介绍\n\n微内核架构模式包含两个核心组件：内核系统（core system）和插件模块（plug-in modules）。基本的核心系统能力加上插件模块提供的彼此之间独立的、高度灵活的功能，共同组成了应用程序的整体功能。\n\n下图展示了微内核模式的基本结构。\n\n![微内核架构模式](/courses/software-architecture/microkernel-architecture-c.png)\n\n内核系统通常只包含基本的能够让系统运行起来的功能。很多操作系统都是采用的微内核架构模式。对于业务应用而言，内核系统通常是通用业务逻辑，没有针对特殊情况、特殊规则或复杂条件处理的自定义逻辑。\n\n插件模块是独立的组件，包含专门处理、附加功能以及自定义代码，旨在增强或扩展内核系统来产生附加业务功能。通常来说，插件模块之间应该是彼此相互独立的，我们也可以使用彼此有依赖的插件，但是需要关注插件间的依赖关系，避免引入依赖问题。\n\n内核系统需要知道如何获取并加载插件。通常来说，我们会有一个插件仓库来管理插件。插件模块有很多方式来集成到内核系统中来，比如 OSGI、消息、web 服务，甚至是直接对象实例化。微内核架构模式本身并未限制集成方式，具体的集成方式可以根据应用规模（小型应用还是大型应用）和具体的业务需求（集中部署还是分布式部署等）来确定。\n\n## 举例说明\n\nEclipse IDE 可能是最好的微内核架构的例子。我们下载的 Eclipse IDE 最初只包含一个编辑器，当我们添加一些插件以后，Eclipse 就会变成一个高度定制并且功能丰富的 IDE。浏览器也是一个很好的微内核架构的例子。浏览器插件为浏览器扩展了丰富的功能。\n\n基于产品的应用程序中，微内核架构的例子有很多。在大型业务应用程序中，微内核架构是如何使用的呢？我们举一个保险理赔处理的例子。\n\n保险理赔过程是非常复杂的，不同地区有不同的法规，同一个规则在一个地区允许，在另一个地区不允许。这就导致了在标准理赔处理过程中需要增加无尽的条件判断。\n\n下图展示了基于微内核架构模式实现的理赔处理程序。\n\n![微内核架构样例](/courses/software-architecture/microkernel-example-c.png)\n\n每个插件模块都包含特定地区的具体规则，插件模块与内核系统分离，我们可以自由的修改、增删模块中的规则而不影响内核系统。\n\n## 其他说明\n\n微内核架构模式可以作为组成部分与其他架构模式一起使用。比如当微内核架构模式只解决了某一个特定场景内的问题时，我们就可以将其与其他架构模式（如分层架构模式）一起使用。\n\n微内核架构模式为进化设计和增量开发提供了很好的支持。我们可以先构建一个坚实的内核系统，然后随着应用程序的逐步迭代，添加新的特性和功能，而无需对内核系统进行重大更改。\n\n对于基于产品的应用程序来说，微内核架构模式应该始终是我们作为起始架构的首选，特别是对于那些将随着时间的推移而发布附加功能并希望控制哪些用户获得哪些功能的产品。\n\n## 思考\n\n通常来说，对于采用大部分微内核架构的应用程序来说，内核系统很快就趋于稳定，而彼此之间松耦合的插件模块可以快速实现变更迭代。同时，插件也是非常易于部署的，甚至可以做到热更新。我们可以方便对内核系统进行 mock，从而方便地进行测试。虽然微内核架构模式不是为了性能而设计的，但是大部分基于此模式的应用都有不错的性能，因为可以自由的定制需要的插件。\n\n我们可以通过插件来扩展一些功能，但是考虑到大部分基于微内核架构模式的应用程序都是基于产品的应用程序，总体来说，扩展性较差。同时，内核系统与插件之间的通信协议设计、版本控制以及插件仓库的管理、插件可粒度设计等等都增加了额外的开发和管理成本。\n",contentRendered:'<p>微内核架构模式（有时也称为插件架构模式）通常被应用于实现基于产品的应用程序。基于产品的应用程序是一种基于某一个现有产品开发，作为典型第三方产品打包并可供下载的应用程序。微内核架构模式允许我们将附加的应用程序功能作为插件添加到核心应用程序中，提供可扩展性以及额外的功能。</p>\n<h2 id="模式介绍" tabindex="-1"><a class="header-anchor" href="#模式介绍" aria-hidden="true">#</a> 模式介绍</h2>\n<p>微内核架构模式包含两个核心组件：内核系统（core system）和插件模块（plug-in modules）。基本的核心系统能力加上插件模块提供的彼此之间独立的、高度灵活的功能，共同组成了应用程序的整体功能。</p>\n<p>下图展示了微内核模式的基本结构。</p>\n<p><img src="/courses/software-architecture/microkernel-architecture-c.png" alt="微内核架构模式"></p>\n<p>内核系统通常只包含基本的能够让系统运行起来的功能。很多操作系统都是采用的微内核架构模式。对于业务应用而言，内核系统通常是通用业务逻辑，没有针对特殊情况、特殊规则或复杂条件处理的自定义逻辑。</p>\n<p>插件模块是独立的组件，包含专门处理、附加功能以及自定义代码，旨在增强或扩展内核系统来产生附加业务功能。通常来说，插件模块之间应该是彼此相互独立的，我们也可以使用彼此有依赖的插件，但是需要关注插件间的依赖关系，避免引入依赖问题。</p>\n<p>内核系统需要知道如何获取并加载插件。通常来说，我们会有一个插件仓库来管理插件。插件模块有很多方式来集成到内核系统中来，比如 OSGI、消息、web 服务，甚至是直接对象实例化。微内核架构模式本身并未限制集成方式，具体的集成方式可以根据应用规模（小型应用还是大型应用）和具体的业务需求（集中部署还是分布式部署等）来确定。</p>\n<h2 id="举例说明" tabindex="-1"><a class="header-anchor" href="#举例说明" aria-hidden="true">#</a> 举例说明</h2>\n<p>Eclipse IDE 可能是最好的微内核架构的例子。我们下载的 Eclipse IDE 最初只包含一个编辑器，当我们添加一些插件以后，Eclipse 就会变成一个高度定制并且功能丰富的 IDE。浏览器也是一个很好的微内核架构的例子。浏览器插件为浏览器扩展了丰富的功能。</p>\n<p>基于产品的应用程序中，微内核架构的例子有很多。在大型业务应用程序中，微内核架构是如何使用的呢？我们举一个保险理赔处理的例子。</p>\n<p>保险理赔过程是非常复杂的，不同地区有不同的法规，同一个规则在一个地区允许，在另一个地区不允许。这就导致了在标准理赔处理过程中需要增加无尽的条件判断。</p>\n<p>下图展示了基于微内核架构模式实现的理赔处理程序。</p>\n<p><img src="/courses/software-architecture/microkernel-example-c.png" alt="微内核架构样例"></p>\n<p>每个插件模块都包含特定地区的具体规则，插件模块与内核系统分离，我们可以自由的修改、增删模块中的规则而不影响内核系统。</p>\n<h2 id="其他说明" tabindex="-1"><a class="header-anchor" href="#其他说明" aria-hidden="true">#</a> 其他说明</h2>\n<p>微内核架构模式可以作为组成部分与其他架构模式一起使用。比如当微内核架构模式只解决了某一个特定场景内的问题时，我们就可以将其与其他架构模式（如分层架构模式）一起使用。</p>\n<p>微内核架构模式为进化设计和增量开发提供了很好的支持。我们可以先构建一个坚实的内核系统，然后随着应用程序的逐步迭代，添加新的特性和功能，而无需对内核系统进行重大更改。</p>\n<p>对于基于产品的应用程序来说，微内核架构模式应该始终是我们作为起始架构的首选，特别是对于那些将随着时间的推移而发布附加功能并希望控制哪些用户获得哪些功能的产品。</p>\n<h2 id="思考" tabindex="-1"><a class="header-anchor" href="#思考" aria-hidden="true">#</a> 思考</h2>\n<p>通常来说，对于采用大部分微内核架构的应用程序来说，内核系统很快就趋于稳定，而彼此之间松耦合的插件模块可以快速实现变更迭代。同时，插件也是非常易于部署的，甚至可以做到热更新。我们可以方便对内核系统进行 mock，从而方便地进行测试。虽然微内核架构模式不是为了性能而设计的，但是大部分基于此模式的应用都有不错的性能，因为可以自由的定制需要的插件。</p>\n<p>我们可以通过插件来扩展一些功能，但是考虑到大部分基于微内核架构模式的应用程序都是基于产品的应用程序，总体来说，扩展性较差。同时，内核系统与插件之间的通信协议设计、版本控制以及插件仓库的管理、插件可粒度设计等等都增加了额外的开发和管理成本。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-01-18",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/software-architecture/microkernel-architecture.html",pathLocale:"/",permalink:null,slug:"microkernel-architecture",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/software-architecture/microkernel-architecture.md",filePathRelative:"courses/software-architecture/microkernel-architecture.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/microkernel-architecture.html.vue",componentFilePathRelative:"pages/courses/software-architecture/microkernel-architecture.html.vue",componentFileChunkName:"v-3c2fb554",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/microkernel-architecture.html.js",dataFilePathRelative:"pages/courses/software-architecture/microkernel-architecture.html.js",dataFileChunkName:"v-3c2fb554",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/software-architecture/microkernel-architecture.html",htmlFilePathRelative:"courses/software-architecture/microkernel-architecture.html"},{key:"v-6f60cae0",path:"/courses/software-architecture/microservice-architecture.html",title:"微服务构模式",lang:"zh-CN",frontmatter:{title:"微服务构模式",description:"作为单体应用和面向服务架构模式的替代方案，微服务架构模式在业界迅速普及。本文介绍微服务架构的核心概念，以及选择该架构需要考虑的取舍问题。",keywords:["Microservice Architecture","微服务架构"],date:"2022-01-19T00:00:00.000Z",key:4},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"模式介绍",slug:"模式介绍",children:[]},{level:2,title:"拓扑结构",slug:"拓扑结构",children:[{level:3,title:"基于 API REST 的拓扑",slug:"基于-api-rest-的拓扑",children:[]},{level:3,title:"基于应用 REST 的拓扑",slug:"基于应用-rest-的拓扑",children:[]},{level:3,title:"基于集中式消息传递的拓扑",slug:"基于集中式消息传递的拓扑",children:[]}]},{level:2,title:"避免服务间的依赖和编排",slug:"避免服务间的依赖和编排",children:[]},{level:2,title:"其他说明",slug:"其他说明",children:[]},{level:2,title:"小结",slug:"小结",children:[]}],content:"\n作为单体应用（monolithic application）和面向服务架构模式（service-oriented architectures，SOA）的替代方案，微服务架构模式（microservices architecture pattern）在业界迅速普及。本文介绍微服务架构的核心概念，以及选择该架构需要考虑的取舍问题。\n\n## 模式介绍\n\n尽管由于业务场景不同，微服务架构的拓扑结构和实现方式都不同，但是一些核心概念是相同的。在这些概念中，首先要说明的就是独立部署单元（separately deployed units）。如下图说是，微服务架构中，每个服务组件都是作为独立单元单独部署。独立部署单元之间彼此解耦，可以方便集成持续部署流水线（continuous deployment pipeline）,并且扩展性也很高。\n\n![基本的微服务架构](/courses/software-architecture/basic-microservice-architecture-c.png)\n\n在这些概念中，最重要的就是服务组件（service component）了。不像面向服务架构中的服务，服务组件的颗粒度可以非常灵活。服务组件可以仅仅是实现了一个具体功能的一到两个模块，也可以是应用中比较独立的一整块业务。因此，服务组件的颗粒度设计是整个微服务架构模式中最具挑战性的部分。\n\n微服务架构是分布式的，架构中的所有组成部分都是彼此独立、解耦的，彼此间需要通过远程访问协议（remote access protocol）来通信，比如 JMS、AMQP、REST、SOAP、RMI 等。\n\n微服务架构模式是由解决其他架构模式的问题而不断演化而来，主要来自于两方面：采用分层架构模式开发的单体应用和采用面向服务架构模式开发的分布式应用。\n\n采用分层架构模式开发的单体应用，通常因为包含了很多彼此强耦合的单元而难以拆分，从而给变更、测试和持续部署带来的很多麻烦。某一个小问题可能导致整个应用宕机。微服务架构模式将应用拆分成很多个可以独立部署的单元（服务组件），从而可以方便的进行变更、测试和支持部署。\n\n面向服务的架构模式（SOA）非常强大，并提供了无与伦比的抽象级别、异构连接、服务编排等能力，但是该模式太复杂，难以理解和实施，而且对于大多数应用来说通常是矫枉过正的。微服务架构模式通过简化服务的概念、消除编排需求以及简化对服务组件的连接和访问来解决这种复杂性。\n\n## 拓扑结构\n\n微服务有三种主要的拓扑结构：基于 API REST （API REST-based topology）的拓扑、基于应用 REST 的拓扑（application REST-based topology）和基于集中式消息传递的拓扑（centralized messaging topology）。\n\n### 基于 API REST 的拓扑\n\n![基于 API REST 的拓扑](/courses/software-architecture/microservice-api-rest-based-c.png)\n\n如上图所示，基于 API REST 的拓扑包含很多细粒度的服务组件，每个服务组件仅仅包含一到两个模块，实现了与其他服务彼此独立的某一项具体的业务动作。这些服务组件通常由一个独立部署的基于 REST 的 Web API 来访问。\n\n这种拓扑结构通常被用于那些提供单一功能的 RESTful web 服务中，这些 web 服务在 Google、Amazon 等云服务厂商中非常常见。\n\n### 基于应用 REST 的拓扑\n\n![基于应用 REST 的拓扑](/courses/software-architecture/microservice-application-rest-based-c.png)\n\n上图展示了基于应用 REST 的拓扑结构。与基于 API REST 的拓扑结构不同的是，通常用户请求不是简单的访问一个 Web API 就可以实现，而是需要通过一个具体的 UI 层。\n\n基于应用 REST 的拓扑结构中的服务组件，也比基于 API REST 拓扑中的服务组件更大，颗粒度更粗，通常包含整个应用中某一块业务功能。\n\n基于应用 REST 的拓扑结构通常被用于规模较小、或者中等规模的应用中。\n\n### 基于集中式消息传递的拓扑\n\n![基于集中式消息传递的拓扑](/courses/software-architecture/microservice-centralized-messaging-c.png)\n\n上图展示了基于集中式消息传递的拓扑结构。与基于应用 REST 的拓扑结构类似，但是基于集中式消息传递的拓扑结构不再使用 REST 来访问服务，而是通过一些轻量级的集中式消息代理（比如 ActiveMQ、HornetQ 等）来访问服务。\n\n集中式消息传递拓扑通常被用于较大的业务应用，或者那些需要对用户 UI 和服务组件之间的数据传输进行复杂控制的应用中。与前面讨论的拓扑结构相比，这种拓扑结构的好处是有先进的排队机制、异步消息传递、监控、错误处理以及更好的整体负载平衡和可扩展性。\n\n## 避免服务间的依赖和编排\n\n微服务架构模式的一大挑战是服务颗粒度的设计。颗粒度太粗无法享受到快速变更、\n持续部署、低耦合、高扩展性等优势，颗粒度太小有不得不引起服务之间的编排需求，从而不得不面对成面向服务架构的问题。\n\n如果发现我们不得不引入服务编排时，说明服务组件的颗粒度太细了。类似的，如果发现我们需要建立服务组件间的通信，而这些通信仅仅是为了满足简单的用户请求，那么说明服务组件的颗粒度太细了，或者说当前的业务场景不适合微服务架构模式。\n\n有时候服务组件之间有一些公共的功能需要共享（比如工具函数等），在微服务架构模式中，我们建议允许一定的代码重复。这样可以保持服务之间相互独立，避免产生依赖，从而保证变更、持续部署方便。\n\n## 其他说明\n\n微服务架构解决了单体应用和面向服务架构的应用的很多共性问题。大的应用被拆分成多个小的、可独立部署的服务。应用的健壮性、可扩展性都得到了极大的提高，同时可以更方便的与持续部署系统集成。\n\n由于变更产生在相互独立的服务中，单个服务的变更不影响其他服务，我们可以在生产环境做实时部署，而不需要在周末或非工作时间做发布。同时，我们可以启用多个服务实例，实现滚动发布，做到用户无感。\n\n微服务架构是分布式的，因此有着与事件驱动的架构模式相同的问题。比如协议设计、服务的管理、系统可用性、访问控制等问题。\n\n## 小结\n\n由于整个应用被划分成多个独立部署单元，彼此之间相互独立，因此整个应用可以快速的响应变化。在测试、快速部署等方面优势明显，同时还具备了很高的可扩展性。也正是由于应用被划分成了多个独立单元，开发人员心智负担也更小，开发也更加便利了。\n\n与大部分的分布式系统相同，尽管应用本身可以实现不错的性能，但是微服务架构模式并不是为了解决性能问题而设计的，在性能方面会相对弱势一些。\n",contentRendered:'<p>作为单体应用（monolithic application）和面向服务架构模式（service-oriented architectures，SOA）的替代方案，微服务架构模式（microservices architecture pattern）在业界迅速普及。本文介绍微服务架构的核心概念，以及选择该架构需要考虑的取舍问题。</p>\n<h2 id="模式介绍" tabindex="-1"><a class="header-anchor" href="#模式介绍" aria-hidden="true">#</a> 模式介绍</h2>\n<p>尽管由于业务场景不同，微服务架构的拓扑结构和实现方式都不同，但是一些核心概念是相同的。在这些概念中，首先要说明的就是独立部署单元（separately deployed units）。如下图说是，微服务架构中，每个服务组件都是作为独立单元单独部署。独立部署单元之间彼此解耦，可以方便集成持续部署流水线（continuous deployment pipeline）,并且扩展性也很高。</p>\n<p><img src="/courses/software-architecture/basic-microservice-architecture-c.png" alt="基本的微服务架构"></p>\n<p>在这些概念中，最重要的就是服务组件（service component）了。不像面向服务架构中的服务，服务组件的颗粒度可以非常灵活。服务组件可以仅仅是实现了一个具体功能的一到两个模块，也可以是应用中比较独立的一整块业务。因此，服务组件的颗粒度设计是整个微服务架构模式中最具挑战性的部分。</p>\n<p>微服务架构是分布式的，架构中的所有组成部分都是彼此独立、解耦的，彼此间需要通过远程访问协议（remote access protocol）来通信，比如 JMS、AMQP、REST、SOAP、RMI 等。</p>\n<p>微服务架构模式是由解决其他架构模式的问题而不断演化而来，主要来自于两方面：采用分层架构模式开发的单体应用和采用面向服务架构模式开发的分布式应用。</p>\n<p>采用分层架构模式开发的单体应用，通常因为包含了很多彼此强耦合的单元而难以拆分，从而给变更、测试和持续部署带来的很多麻烦。某一个小问题可能导致整个应用宕机。微服务架构模式将应用拆分成很多个可以独立部署的单元（服务组件），从而可以方便的进行变更、测试和支持部署。</p>\n<p>面向服务的架构模式（SOA）非常强大，并提供了无与伦比的抽象级别、异构连接、服务编排等能力，但是该模式太复杂，难以理解和实施，而且对于大多数应用来说通常是矫枉过正的。微服务架构模式通过简化服务的概念、消除编排需求以及简化对服务组件的连接和访问来解决这种复杂性。</p>\n<h2 id="拓扑结构" tabindex="-1"><a class="header-anchor" href="#拓扑结构" aria-hidden="true">#</a> 拓扑结构</h2>\n<p>微服务有三种主要的拓扑结构：基于 API REST （API REST-based topology）的拓扑、基于应用 REST 的拓扑（application REST-based topology）和基于集中式消息传递的拓扑（centralized messaging topology）。</p>\n<h3 id="基于-api-rest-的拓扑" tabindex="-1"><a class="header-anchor" href="#基于-api-rest-的拓扑" aria-hidden="true">#</a> 基于 API REST 的拓扑</h3>\n<p><img src="/courses/software-architecture/microservice-api-rest-based-c.png" alt="基于 API REST 的拓扑"></p>\n<p>如上图所示，基于 API REST 的拓扑包含很多细粒度的服务组件，每个服务组件仅仅包含一到两个模块，实现了与其他服务彼此独立的某一项具体的业务动作。这些服务组件通常由一个独立部署的基于 REST 的 Web API 来访问。</p>\n<p>这种拓扑结构通常被用于那些提供单一功能的 RESTful web 服务中，这些 web 服务在 Google、Amazon 等云服务厂商中非常常见。</p>\n<h3 id="基于应用-rest-的拓扑" tabindex="-1"><a class="header-anchor" href="#基于应用-rest-的拓扑" aria-hidden="true">#</a> 基于应用 REST 的拓扑</h3>\n<p><img src="/courses/software-architecture/microservice-application-rest-based-c.png" alt="基于应用 REST 的拓扑"></p>\n<p>上图展示了基于应用 REST 的拓扑结构。与基于 API REST 的拓扑结构不同的是，通常用户请求不是简单的访问一个 Web API 就可以实现，而是需要通过一个具体的 UI 层。</p>\n<p>基于应用 REST 的拓扑结构中的服务组件，也比基于 API REST 拓扑中的服务组件更大，颗粒度更粗，通常包含整个应用中某一块业务功能。</p>\n<p>基于应用 REST 的拓扑结构通常被用于规模较小、或者中等规模的应用中。</p>\n<h3 id="基于集中式消息传递的拓扑" tabindex="-1"><a class="header-anchor" href="#基于集中式消息传递的拓扑" aria-hidden="true">#</a> 基于集中式消息传递的拓扑</h3>\n<p><img src="/courses/software-architecture/microservice-centralized-messaging-c.png" alt="基于集中式消息传递的拓扑"></p>\n<p>上图展示了基于集中式消息传递的拓扑结构。与基于应用 REST 的拓扑结构类似，但是基于集中式消息传递的拓扑结构不再使用 REST 来访问服务，而是通过一些轻量级的集中式消息代理（比如 ActiveMQ、HornetQ 等）来访问服务。</p>\n<p>集中式消息传递拓扑通常被用于较大的业务应用，或者那些需要对用户 UI 和服务组件之间的数据传输进行复杂控制的应用中。与前面讨论的拓扑结构相比，这种拓扑结构的好处是有先进的排队机制、异步消息传递、监控、错误处理以及更好的整体负载平衡和可扩展性。</p>\n<h2 id="避免服务间的依赖和编排" tabindex="-1"><a class="header-anchor" href="#避免服务间的依赖和编排" aria-hidden="true">#</a> 避免服务间的依赖和编排</h2>\n<p>微服务架构模式的一大挑战是服务颗粒度的设计。颗粒度太粗无法享受到快速变更、\n持续部署、低耦合、高扩展性等优势，颗粒度太小有不得不引起服务之间的编排需求，从而不得不面对成面向服务架构的问题。</p>\n<p>如果发现我们不得不引入服务编排时，说明服务组件的颗粒度太细了。类似的，如果发现我们需要建立服务组件间的通信，而这些通信仅仅是为了满足简单的用户请求，那么说明服务组件的颗粒度太细了，或者说当前的业务场景不适合微服务架构模式。</p>\n<p>有时候服务组件之间有一些公共的功能需要共享（比如工具函数等），在微服务架构模式中，我们建议允许一定的代码重复。这样可以保持服务之间相互独立，避免产生依赖，从而保证变更、持续部署方便。</p>\n<h2 id="其他说明" tabindex="-1"><a class="header-anchor" href="#其他说明" aria-hidden="true">#</a> 其他说明</h2>\n<p>微服务架构解决了单体应用和面向服务架构的应用的很多共性问题。大的应用被拆分成多个小的、可独立部署的服务。应用的健壮性、可扩展性都得到了极大的提高，同时可以更方便的与持续部署系统集成。</p>\n<p>由于变更产生在相互独立的服务中，单个服务的变更不影响其他服务，我们可以在生产环境做实时部署，而不需要在周末或非工作时间做发布。同时，我们可以启用多个服务实例，实现滚动发布，做到用户无感。</p>\n<p>微服务架构是分布式的，因此有着与事件驱动的架构模式相同的问题。比如协议设计、服务的管理、系统可用性、访问控制等问题。</p>\n<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>由于整个应用被划分成多个独立部署单元，彼此之间相互独立，因此整个应用可以快速的响应变化。在测试、快速部署等方面优势明显，同时还具备了很高的可扩展性。也正是由于应用被划分成了多个独立单元，开发人员心智负担也更小，开发也更加便利了。</p>\n<p>与大部分的分布式系统相同，尽管应用本身可以实现不错的性能，但是微服务架构模式并不是为了解决性能问题而设计的，在性能方面会相对弱势一些。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-01-19",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/software-architecture/microservice-architecture.html",pathLocale:"/",permalink:null,slug:"microservice-architecture",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/software-architecture/microservice-architecture.md",filePathRelative:"courses/software-architecture/microservice-architecture.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/microservice-architecture.html.vue",componentFilePathRelative:"pages/courses/software-architecture/microservice-architecture.html.vue",componentFileChunkName:"v-6f60cae0",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/microservice-architecture.html.js",dataFilePathRelative:"pages/courses/software-architecture/microservice-architecture.html.js",dataFileChunkName:"v-6f60cae0",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/software-architecture/microservice-architecture.html",htmlFilePathRelative:"courses/software-architecture/microservice-architecture.html"},{key:"v-0d5834bf",path:"/courses/software-architecture/space-based-architecture.html",title:"基于空间的架构模式",lang:"zh-CN",frontmatter:{title:"基于空间的架构模式",description:"基于空间的架构模式，也叫云架构模式，致力于解决高访问量、高并发问题的架构模式，尤其适用于流量动态变化的业务场景。",keywords:["Space-Based Architecture","基于空间的架构模式"],date:"2022-01-19T00:00:00.000Z",key:5},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"模式介绍",slug:"模式介绍",children:[{level:3,title:"处理单元",slug:"处理单元",children:[]},{level:3,title:"虚拟化中间件",slug:"虚拟化中间件",children:[]}]},{level:2,title:"其他说明",slug:"其他说明",children:[]},{level:2,title:"小结",slug:"小结",children:[]}],content:"\n大多数基于 Web 的业务应用都有着相似的请求流程：来自浏览器的请求首先到达 Web 服务器，然后是业务服务器，最后到达数据库服务器。 随着用户负载的增加，系统的瓶颈开始出现。首先是在 Web 服务器层，然后是业务服务器层，最后是数据库服务器层。为了解决瓶颈问题，通常我们会先横向扩展 Web 服务器。因为扩展 Web 服务器相对容易且便宜，有时可以解决瓶颈问题。然而，在大多数高用户负载的情况下，横向扩展 Web 服务器层只会将瓶颈向下移动到业务服务器。扩展业务服务器可能比 Web 服务器更复杂、更昂贵，并且通常也只是将瓶颈转移到数据库服务器上，而数据库服务器的扩展更加困难和昂贵。即使您可以扩展数据库，最终得到的是三角形拓扑，三角形最宽的部分是 Web 服务器（最容易扩展），最小的部分是数据库（最难扩展）。\n\n在任何并发用户负载非常大的大容量应用中，数据库通常是系统可以同时处理多少事务的最终限制因素。虽然各种缓存技术和数据库扩展产品有助于解决问题，但为极端负载扩展普通应用是一个非常浪费且抵消的选择。\n\n基于空间的架构模式（space-based architecture，也叫云架构模式，cloud architecutre）专门设计用于解决可伸缩性和并发性问题。对于具有可变且不可预测的并发用户量的应用，它也是一种有用的架构模式。\n\n## 模式介绍\n\n基于空间的架构模式最大限度的减少了限制应用程序扩展的因素。\n\n通过消除中央数据库约束并改用可复制的内存数据网格来实现高可伸缩性。应用的数据保存在内存中，并在所有活动的处理单元（processing unit）之间复制。随着用户负载的增加和减少，处理单元可以动态启动和关闭，从而解决可变的可扩展性。因为没有中央数据库，所以消除了数据库瓶颈，给应用提供了近乎无限的可扩展性。\n\n![基于空间的架构模式](/courses/software-architecture/space-based-architecture-c.png)\n\n上图展示了基于空间的架构模式的基本结构，有两个主要组成部分：处理单元（processing unit）和虚拟化中间件（virtualized middleware）。\n\n### 处理单元\n\n处理单元通常包含业务模块（application module），以及内存中的数据网格（in-memory data grid）和用于故障转移的可选异步持久化存储（asynchronous persistence store）。它还包含一个数据复制引擎（data-replication engine），虚拟化中间件使用该复制引擎将一个处理单元所做的数据更改复制到其他活动处理单元中。下图展示了处理单元架构图。\n\n![处理单元架构图](/courses/software-architecture/space-based-processing-unit-c.png)\n\n\n### 虚拟化中间件\n\n虚拟化中间件负责处理内务和通信，管理请求、会话、数据复制、分布式请求处理和流程单元部署，是整个架构的控制器。虚拟化中间件中有四个主要架构组件：消息网格（messaging grid）、数据网格（data grid）、处理网格（processing grid）和部署管理器（deployment manager）。\n\n#### 消息网格\n![消息网格](/courses/software-architecture/space-based-messaging-grid-c.png)\n\n上图展示了消息网格是如何处理请求和会话信息的。当请求进入虚拟化中间件时，消息网格确定哪些活动处理单元可用于接收请求并将请求转发到这些处理单元中的某一个。\n\n#### 数据网格\n\n![数据网格](/courses/software-architecture/space-based-data-grid-c.png)\n\n上图展示了数据网格的工作方式。数据网格应该是整个架构模式中最重要的一块了。数据网格与每个处理单元中的数据复制引擎交互，从而在发生数据更新时，在处理单元之间复制数据。由于消息网格可以将请求转发到任何可用的处理单元，因此每个处理单元在其内存数据网格中包含完全相同的数据至关重要，数据网格的数据复制通常是在毫秒级。\n\n#### 处理网格\n\n![处理网格](/courses/software-architecture/space-based-processing-grid-c.png)\n\n上图展示了处理网格的工作方式。处理网格是虚拟化中间件中的一个可选组件，当有多个处理单元，每个处理单元实现应用的一部分功能时，它负责管理分布式请求处理。如果一个请求需要在处理单元类型（例如，订单处理单元和客户处理单元）之间进行协调，则处理网格会在这两个处理单元之间协调请求。\n\n#### 部署管理器\n\n部署管理器组件根据负载条件管理处理单元的动态启动和关闭。它持续监控响应时间和用户负载，在负载增加时启动新的处理单元，在负载减少时关闭处理单元。它是在应用程序中实现可变可扩展性的关键组件。\n\n## 其他说明\n\n基于空间的架构模式比较复杂，适用于具有可变负载的小型基于 Web 的应用（例如，社交媒体网站），它不太适合具有大量操作数据的传统大型关系数据库应用。\n\n尽管基于空间的架构模式不需要集中式数据存储，但通常会包含一个集中式数据存储，用于执行初始内存数据网格数据加载和处理单元进行的异步持久化数据更新。\n\n## 小结\n\n因为处理单元可以快速启动和关闭，应用可以很好地响应与用户负载增加或减少相关的环境变化。\n\n尽管基于空间的架构通常不是解耦和分布式的，但它们是动态的，并且各种基于云的复杂工具可以将应用轻松“推送”到服务器，从而简化部署。\n\n通过该模式中内置的内存数据访问和缓存机制可以轻松实现高性能。\n\n由于该模式减少了对集中式数据库的依赖或完全不依赖，从本质上消除了瓶颈限制，是的该模式具备很强的可扩展性。\n\n除了以上优势以外，基于空间的架构模式也存在弱势。\n\n在测试环境通过模拟大数据量的用户负载是非常复杂的，因此比较难以测试。\n\n复杂的缓存和内存数据网格使这种模式的开发相对复杂。此外，在开发这些类型的架构时必须特别小心，以确保源代码中的任何内容都不会影响性能和可伸缩性。\n",contentRendered:'<p>大多数基于 Web 的业务应用都有着相似的请求流程：来自浏览器的请求首先到达 Web 服务器，然后是业务服务器，最后到达数据库服务器。 随着用户负载的增加，系统的瓶颈开始出现。首先是在 Web 服务器层，然后是业务服务器层，最后是数据库服务器层。为了解决瓶颈问题，通常我们会先横向扩展 Web 服务器。因为扩展 Web 服务器相对容易且便宜，有时可以解决瓶颈问题。然而，在大多数高用户负载的情况下，横向扩展 Web 服务器层只会将瓶颈向下移动到业务服务器。扩展业务服务器可能比 Web 服务器更复杂、更昂贵，并且通常也只是将瓶颈转移到数据库服务器上，而数据库服务器的扩展更加困难和昂贵。即使您可以扩展数据库，最终得到的是三角形拓扑，三角形最宽的部分是 Web 服务器（最容易扩展），最小的部分是数据库（最难扩展）。</p>\n<p>在任何并发用户负载非常大的大容量应用中，数据库通常是系统可以同时处理多少事务的最终限制因素。虽然各种缓存技术和数据库扩展产品有助于解决问题，但为极端负载扩展普通应用是一个非常浪费且抵消的选择。</p>\n<p>基于空间的架构模式（space-based architecture，也叫云架构模式，cloud architecutre）专门设计用于解决可伸缩性和并发性问题。对于具有可变且不可预测的并发用户量的应用，它也是一种有用的架构模式。</p>\n<h2 id="模式介绍" tabindex="-1"><a class="header-anchor" href="#模式介绍" aria-hidden="true">#</a> 模式介绍</h2>\n<p>基于空间的架构模式最大限度的减少了限制应用程序扩展的因素。</p>\n<p>通过消除中央数据库约束并改用可复制的内存数据网格来实现高可伸缩性。应用的数据保存在内存中，并在所有活动的处理单元（processing unit）之间复制。随着用户负载的增加和减少，处理单元可以动态启动和关闭，从而解决可变的可扩展性。因为没有中央数据库，所以消除了数据库瓶颈，给应用提供了近乎无限的可扩展性。</p>\n<p><img src="/courses/software-architecture/space-based-architecture-c.png" alt="基于空间的架构模式"></p>\n<p>上图展示了基于空间的架构模式的基本结构，有两个主要组成部分：处理单元（processing unit）和虚拟化中间件（virtualized middleware）。</p>\n<h3 id="处理单元" tabindex="-1"><a class="header-anchor" href="#处理单元" aria-hidden="true">#</a> 处理单元</h3>\n<p>处理单元通常包含业务模块（application module），以及内存中的数据网格（in-memory data grid）和用于故障转移的可选异步持久化存储（asynchronous persistence store）。它还包含一个数据复制引擎（data-replication engine），虚拟化中间件使用该复制引擎将一个处理单元所做的数据更改复制到其他活动处理单元中。下图展示了处理单元架构图。</p>\n<p><img src="/courses/software-architecture/space-based-processing-unit-c.png" alt="处理单元架构图"></p>\n<h3 id="虚拟化中间件" tabindex="-1"><a class="header-anchor" href="#虚拟化中间件" aria-hidden="true">#</a> 虚拟化中间件</h3>\n<p>虚拟化中间件负责处理内务和通信，管理请求、会话、数据复制、分布式请求处理和流程单元部署，是整个架构的控制器。虚拟化中间件中有四个主要架构组件：消息网格（messaging grid）、数据网格（data grid）、处理网格（processing grid）和部署管理器（deployment manager）。</p>\n<h4 id="消息网格" tabindex="-1"><a class="header-anchor" href="#消息网格" aria-hidden="true">#</a> 消息网格</h4>\n<p><img src="/courses/software-architecture/space-based-messaging-grid-c.png" alt="消息网格"></p>\n<p>上图展示了消息网格是如何处理请求和会话信息的。当请求进入虚拟化中间件时，消息网格确定哪些活动处理单元可用于接收请求并将请求转发到这些处理单元中的某一个。</p>\n<h4 id="数据网格" tabindex="-1"><a class="header-anchor" href="#数据网格" aria-hidden="true">#</a> 数据网格</h4>\n<p><img src="/courses/software-architecture/space-based-data-grid-c.png" alt="数据网格"></p>\n<p>上图展示了数据网格的工作方式。数据网格应该是整个架构模式中最重要的一块了。数据网格与每个处理单元中的数据复制引擎交互，从而在发生数据更新时，在处理单元之间复制数据。由于消息网格可以将请求转发到任何可用的处理单元，因此每个处理单元在其内存数据网格中包含完全相同的数据至关重要，数据网格的数据复制通常是在毫秒级。</p>\n<h4 id="处理网格" tabindex="-1"><a class="header-anchor" href="#处理网格" aria-hidden="true">#</a> 处理网格</h4>\n<p><img src="/courses/software-architecture/space-based-processing-grid-c.png" alt="处理网格"></p>\n<p>上图展示了处理网格的工作方式。处理网格是虚拟化中间件中的一个可选组件，当有多个处理单元，每个处理单元实现应用的一部分功能时，它负责管理分布式请求处理。如果一个请求需要在处理单元类型（例如，订单处理单元和客户处理单元）之间进行协调，则处理网格会在这两个处理单元之间协调请求。</p>\n<h4 id="部署管理器" tabindex="-1"><a class="header-anchor" href="#部署管理器" aria-hidden="true">#</a> 部署管理器</h4>\n<p>部署管理器组件根据负载条件管理处理单元的动态启动和关闭。它持续监控响应时间和用户负载，在负载增加时启动新的处理单元，在负载减少时关闭处理单元。它是在应用程序中实现可变可扩展性的关键组件。</p>\n<h2 id="其他说明" tabindex="-1"><a class="header-anchor" href="#其他说明" aria-hidden="true">#</a> 其他说明</h2>\n<p>基于空间的架构模式比较复杂，适用于具有可变负载的小型基于 Web 的应用（例如，社交媒体网站），它不太适合具有大量操作数据的传统大型关系数据库应用。</p>\n<p>尽管基于空间的架构模式不需要集中式数据存储，但通常会包含一个集中式数据存储，用于执行初始内存数据网格数据加载和处理单元进行的异步持久化数据更新。</p>\n<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>因为处理单元可以快速启动和关闭，应用可以很好地响应与用户负载增加或减少相关的环境变化。</p>\n<p>尽管基于空间的架构通常不是解耦和分布式的，但它们是动态的，并且各种基于云的复杂工具可以将应用轻松“推送”到服务器，从而简化部署。</p>\n<p>通过该模式中内置的内存数据访问和缓存机制可以轻松实现高性能。</p>\n<p>由于该模式减少了对集中式数据库的依赖或完全不依赖，从本质上消除了瓶颈限制，是的该模式具备很强的可扩展性。</p>\n<p>除了以上优势以外，基于空间的架构模式也存在弱势。</p>\n<p>在测试环境通过模拟大数据量的用户负载是非常复杂的，因此比较难以测试。</p>\n<p>复杂的缓存和内存数据网格使这种模式的开发相对复杂。此外，在开发这些类型的架构时必须特别小心，以确保源代码中的任何内容都不会影响性能和可伸缩性。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-01-19",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/software-architecture/space-based-architecture.html",pathLocale:"/",permalink:null,slug:"space-based-architecture",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/software-architecture/space-based-architecture.md",filePathRelative:"courses/software-architecture/space-based-architecture.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/space-based-architecture.html.vue",componentFilePathRelative:"pages/courses/software-architecture/space-based-architecture.html.vue",componentFileChunkName:"v-0d5834bf",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/software-architecture/space-based-architecture.html.js",dataFilePathRelative:"pages/courses/software-architecture/space-based-architecture.html.js",dataFileChunkName:"v-0d5834bf",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/software-architecture/space-based-architecture.html",htmlFilePathRelative:"courses/software-architecture/space-based-architecture.html"}]}},7401:(e,t,r)=>{r.r(t),r.d(t,{default:()=>l});var n=r(6252);const a=(0,n.Wm)("div",{class:"custom-container tip"},[(0,n.Wm)("p",{class:"custom-container-title"},"TIP"),(0,n.Wm)("p",null,"软件架构学习笔记")],-1),c=(0,n.Wm)("p",null,"对于开发人员来说，在没有正式架构的情况下开始编写应用程序是很常见的。但是对于一个长期迭代的项目来说，如果没有清晰且定义明确的架构，应用程序最终会演变成一堆杂乱无章的源代码模块，这些模块缺乏明确的角色、职责和相互之间的关系。",-1),i=(0,n.Wm)("p",null,"一个好的架构模式将会定义应用程序的基本特征和行为。比如应用是否可扩展，性能特点如何，是否可以方便的对应用进行更改，是否可以容易的进行部署等。",-1),s=(0,n.Wm)("p",null,"不同的架构模式有着不同的特点，比如有的架构模式适合高度可扩展的应用程序，有的架构模式适合高度敏捷的应用程序等。了解每种架构模式的特征、优势和劣势对于选择满足特定业务需求和目标的架构模式是必要的。",-1),p=(0,n.Wm)("p",null,"本系列会详细介绍集中常见的软件架构模式，并分析他们的优缺点。",-1),o=(0,n.uE)('<blockquote><p>参考链接：https://www.oreilly.com/content/software-architecture-patterns/</p></blockquote><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',2),l={render:function(e,t){const r=(0,n.up)("ArticleList");return(0,n.wg)(),(0,n.j4)(n.HY,null,[a,c,i,s,p,(0,n.Wm)(r,{noTag:!0}),o],64)}}}}]);