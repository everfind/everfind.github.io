"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[7945],{2096:(n,a,e)=>{e.r(a),e.d(a,{data:()=>s});const s={key:"v-4a3ec27b",path:"/courses/webpack/performance.html",title:"性能优化",lang:"zh-CN",frontmatter:{title:"性能优化",description:"介绍 Webpack 中如何优化性能",keywords:["Webpack"],date:"2021-01-25T00:00:00.000Z",key:23},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"找到待优化的地方",slug:"找到待优化的地方",children:[]},{level:2,title:"一些优化措施",slug:"一些优化措施",children:[]},{level:2,title:"总结",slug:"总结",children:[]}],filePathRelative:"courses/webpack/performance.md"}},9544:(n,a,e)=>{e.r(a),e.d(a,{default:()=>E});var s=e(6252);const p=(0,s.Wm)("p",null,"Webpack 默认的优化措施对于一些小项目来说已经足够了。但是当项目的规模逐渐变大，Webpack 会逐渐产生性能问题，我们需要设置一些优化措施来优化 Webpack 的性能。",-1),t=(0,s.Wm)("h2",{id:"找到待优化的地方",tabindex:"-1"},[(0,s.Wm)("a",{class:"header-anchor",href:"#找到待优化的地方","aria-hidden":"true"},"#"),(0,s.Uk)(" 找到待优化的地方")],-1),l=(0,s.Uk)("前面说到，Webpack 输出的统计数据（stats）里面包含了各阶段的构建信息，我们可以分析 stats 数据来找出性能较差的地方。"),c={href:"https://webpack.js.org/plugins/profiling-plugin/",target:"_blank",rel:"noopener noreferrer"},o=(0,s.Uk)("webpack.debug.ProfilingPlugin"),r=(0,s.Uk)(" 和 "),i={href:"https://github.com/jantimon/cpuprofile-webpack-plugin",target:"_blank",rel:"noopener noreferrer"},u=(0,s.Uk)("cpuprofile-webpack-plugin"),k=(0,s.Uk)(" 可以将插件的运行时间输出到文件中，然后将这个文件导入到 Chrome 的开发工具中，我们可以看到由此生成的火焰图数据。"),d=(0,s.Wm)("h2",{id:"一些优化措施",tabindex:"-1"},[(0,s.Wm)("a",{class:"header-anchor",href:"#一些优化措施","aria-hidden":"true"},"#"),(0,s.Uk)(" 一些优化措施")],-1),m=(0,s.Uk)("默认情况下，Webpack 只会开启一个实例，无法充分利用多核 CPU 的优势。我们可以通过 "),b={href:"https://www.npmjs.com/package/thread-loader",target:"_blank",rel:"noopener noreferrer"},g=(0,s.Uk)("thread-loader"),h=(0,s.Uk)(" 或者 "),f={href:"https://www.npmjs.com/package/parallel-webpack",target:"_blank",rel:"noopener noreferrer"},W=(0,s.Uk)("parallel-webpack"),y=(0,s.Uk)(" 来开启并行模式。parallel-webpack 支持传入一组配置文件，然后并行的进行构建输出。"),x=(0,s.Wm)("p",null,"除了启动多个进程并行构建以外，还有一些细节问题也可以优化。",-1),v=(0,s.Wm)("li",null,"在开发阶段使用性能更好的 source-map 选项，或者不使用 source-map.",-1),w=(0,s.Uk)("使用 "),j={href:"https://www.npmjs.com/package/@babel/preset-env",target:"_blank",rel:"noopener noreferrer"},U=(0,s.Uk)("@babel/preset-env"),_=(0,s.Uk)(" 来减少现代浏览器中的代码转译。"),P=(0,s.Wm)("li",null,"在开发阶段跳过 polyfill。因为引入 core-js 会极大的增加构建开销。",-1),q=(0,s.Wm)("li",null,[(0,s.Uk)("不对 NodeJS 相关的功能做 polyfill. 比如 polyfill "),(0,s.Wm)("code",null,"process"),(0,s.Uk)(" 对象对构建 bundle 的大小影响很大。")],-1),C=(0,s.Wm)("li",null,[(0,s.Uk)("从 Webpack 5 开始，可以通过 "),(0,s.Wm)("code",null,'cache.type = "filesystem"'),(0,s.Uk)(" 来开启文件系统级别的缓存。通过 "),(0,s.Wm)("code",null,"cache.buildDependencies.config = [__filename]"),(0,s.Uk)(" 可以在配置文件发生变化的时候让缓存失效。")],-1),R=(0,s.uE)('<p>除了上面的优化措施，还有一些 loader 级别的优化。</p><ul><li>在开发阶段，可以跳过某些 loader。比如对于现代浏览器，我们可以跳过 <code>babel-loader</code>。</li><li>可以通过 <code>include</code> 和 <code>exclude</code> 来控制文件检索范围。</li><li>可以通过 <code>thread-loader</code> 来讲一些高耗时的 loader 并行执行。</li></ul><p>在开发阶段，我们还可以优化重新构建的时间。比如，在 React 项目中，我们可以舍弃 <code>propType</code>，只加载一个 <code>.min.js</code> 版本的 React。结合 <code>module.noParse</code> 和 <code>resolve.alias</code>，我们可以告诉 Webpack 在构建时不处理已经最小化压缩的文件。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>exports<span class="token punctuation">.</span><span class="token function-variable function">dontParse</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> name<span class="token punctuation">,</span> path <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n  module<span class="token operator">:</span> <span class="token punctuation">{</span> noParse<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  resolve<span class="token operator">:</span> <span class="token punctuation">{</span> alias<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token operator">:</span> path <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>使用如下：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">dontParse</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">,</span>\n  path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>\n    __dirname<span class="token punctuation">,</span> <span class="token string">&quot;node_modules/react/cjs/react.production.min.js&quot;</span><span class="token punctuation">,</span>\n  <span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如此配置，Webpack 在构建时将不会再解析 React 的代码。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>我们可以通过多种方式来优化 Webpack 的性能。通常情况下，我们可以从最容易实施的优化措施开始。</p><p>我们可以通过并行执行的方式，开启多个实例构建，优化构建性能。</p><p>针对现代游览器，在开发阶段，我们可以跳过很多转译 loader 的处理。</p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',12),E={render:function(n,a){const e=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.j4)(s.HY,null,[p,t,(0,s.Wm)("p",null,[l,(0,s.Wm)("a",c,[o,(0,s.Wm)(e)]),r,(0,s.Wm)("a",i,[u,(0,s.Wm)(e)]),k]),d,(0,s.Wm)("p",null,[m,(0,s.Wm)("a",b,[g,(0,s.Wm)(e)]),h,(0,s.Wm)("a",f,[W,(0,s.Wm)(e)]),y]),x,(0,s.Wm)("ul",null,[v,(0,s.Wm)("li",null,[w,(0,s.Wm)("a",j,[U,(0,s.Wm)(e)]),_]),P,q,C]),R],64)}}}}]);