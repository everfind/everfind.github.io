"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[1653],{1372:(e,a,s)=>{s.r(a),s.d(a,{data:()=>n});const n={key:"v-5e3eb789",path:"/posts/2021/08/06/nodejs-streams.html",title:"图解 NodeJS 流",lang:"zh-CN",frontmatter:{title:"图解 NodeJS 流",description:"以图形化的形式，介绍 NodeJS 中流的类型、工作原理，以及如何使用流。",keywords:["NodeJS","流","stream"],date:"2021-08-06T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"水流，信息流",slug:"水流-信息流",children:[]},{level:2,title:"可读流（Readable Stream）",slug:"可读流-readable-stream",children:[]},{level:2,title:"可写流（Writable Stream）",slug:"可写流-writable-stream",children:[]},{level:2,title:"双工流（Duplex Streams）",slug:"双工流-duplex-streams",children:[]},{level:2,title:"转换流（Transform Stream）",slug:"转换流-transform-stream",children:[]},{level:2,title:"管道（Pipe）",slug:"管道-pipe",children:[{level:3,title:"使用流复制数据",slug:"使用流复制数据",children:[]}]},{level:2,title:"高水位线控制（highWaterMark）",slug:"高水位线控制-highwatermark",children:[]},{level:2,title:"流的应用",slug:"流的应用",children:[]}],filePathRelative:"posts/nodejs-streams.md"}},8018:(e,a,s)=>{s.r(a),s.d(a,{default:()=>ee});var n=s(6252);const t=(0,n.Wm)("p",null,"假设我们现在要盖一座房子，我们买了一些砖块，厂家正在送货。现在我们有两个选择，一是等所有砖块都到了以后再开始动工；二是到一批砖块就开始动工，砖块到多少我们就用多少。",-1),r=(0,n.Wm)("p",null,"这两种方式哪种效率更高呢？显然是第二种。这就是流（stream）的理念。在计算机科学中，流是随时间可用的一系列数据元素。就像传送带运输物品一样，使用流可以实现一次处理一个数据元素。",-1),p=(0,n.Uk)("在 NodeJS 中，"),l={href:"https://nodejs.org/api/stream.html",target:"_blank",rel:"noopener noreferrer"},o=(0,n.Uk)("stream"),i=(0,n.Uk)(" 模块实现了流的功能。即使我们没有直接使用过这个模块，我们也间接使用过流，比如读写文件、网络等。"),c=(0,n.uE)('<h2 id="水流-信息流" tabindex="-1"><a class="header-anchor" href="#水流-信息流" aria-hidden="true">#</a> 水流，信息流</h2><p>信息就像水流一样，以比特流（strem of bits）的形式从一个地方流到另一个地方。比如读取文件，信息就从磁盘流向了应用程序。</p><p>但是，流的两端处理信息的速度是不同的，通常流的一端会比另一端要慢，因此就需要一个缓存来作为缓冲（buffer）。</p><p>如下图所示，上面的水龙头水流较大，下面的水龙头水流较小，因此需要一个容器来暂时存储下面的水龙头来不及处理的水。</p><p><img src="/posts/images/node-streams/stream-c.png" alt="流与缓存"></p><p>NodeJS 中流的基本原理也是这样的，stream 模块实现了这些能力。</p><p>在 NodeJS 中有两种基本的流可以使用：</p><ul><li>可读流（Readable Streams）</li><li>可写流（Writable Streams）</li></ul><p>同时还有两种读写混合的流：</p><ul><li>双工流（Duplex Streams）-- 可读可写的流</li><li>转换流（Transform Streams）-- 可以转换数据的双工流</li></ul><h2 id="可读流-readable-stream" tabindex="-1"><a class="header-anchor" href="#可读流-readable-stream" aria-hidden="true">#</a> 可读流（Readable Stream）</h2>',11),m=(0,n.Uk)("可读流可以从一个地方读取数据，比如从文件中读取信息。读取的数据可以暂时存放在可读流中的"),d={href:"https://nodejs.org/api/stream.html#stream_buffering",target:"_blank",rel:"noopener noreferrer"},h=(0,n.Uk)("缓存（Buffer）"),u=(0,n.Uk)("里，防止应用程序无法及时处理。"),g=(0,n.Wm)("p",null,[(0,n.Wm)("img",{src:"/posts/images/node-streams/readable-c.png",alt:"可读流"})],-1),k=(0,n.Uk)("常见的可读流有 "),f={href:"https://nodejs.org/api/process.html#process_process_stdin",target:"_blank",rel:"noopener noreferrer"},b=(0,n.Wm)("code",null,"process.stdin",-1),W=(0,n.Uk)("、"),x={href:"https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options",target:"_blank",rel:"noopener noreferrer"},y=(0,n.Wm)("code",null,"fs.createReadStream",-1),_=(0,n.Uk)(" 以及 HTTP 服务中的 "),S={href:"https://nodejs.org/api/http.html#http_class_http_incomingmessage",target:"_blank",rel:"noopener noreferrer"},w=(0,n.Wm)("code",null,"IncomingMessage",-1),v=(0,n.Uk)(" 对象。"),j=(0,n.Wm)("h2",{id:"可写流-writable-stream",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#可写流-writable-stream","aria-hidden":"true"},"#"),(0,n.Uk)(" 可写流（Writable Stream）")],-1),U=(0,n.Wm)("p",null,"可写流可以将数据写到一个地方，比如将数据写入文件中。为了防止因为写入目标处理速度太慢导致数据丢失，写入的数据可以暂存在可写流内部的缓存（Buffer）中。",-1),N=(0,n.Wm)("p",null,[(0,n.Wm)("img",{src:"/posts/images/node-streams/writable-c.png",alt:"可写流"})],-1),J=(0,n.Uk)("常用的可写流有 "),R={href:"https://nodejs.org/api/process.html#process_process_stdout",target:"_blank",rel:"noopener noreferrer"},M=(0,n.Wm)("code",null,"process.stdout",-1),T=(0,n.Uk)("、"),P={href:"https://nodejs.org/api/process.html#process_process_stderr",target:"_blank",rel:"noopener noreferrer"},C=(0,n.Wm)("code",null,"process.stderr",-1),q=(0,n.Uk)(" 和 "),B={href:"https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options",target:"_blank",rel:"noopener noreferrer"},D=(0,n.Wm)("code",null,"fs.createWriteStream",-1),E=(0,n.Uk)("."),H=(0,n.Wm)("h2",{id:"双工流-duplex-streams",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#双工流-duplex-streams","aria-hidden":"true"},"#"),(0,n.Uk)(" 双工流（Duplex Streams）")],-1),z=(0,n.Wm)("p",null,"双工流是可读流和可写流的混合体。连接到双工流之后，应用程序既可以从流中读取数据，也可以向流中写入数据。在双工流中，可读流和可写流有各自独立的缓存（Buffer）。",-1),I=(0,n.Wm)("p",null,[(0,n.Wm)("img",{src:"/posts/images/node-streams/duplex-c.png",alt:"双工流"})],-1),L=(0,n.Uk)("最常用的双工流就是 "),O={href:"https://nodejs.org/api/net.html#net_class_net_socket",target:"_blank",rel:"noopener noreferrer"},Y=(0,n.Wm)("code",null,"net.Socket",-1),Z=(0,n.Uk)("。"),A=(0,n.Wm)("h2",{id:"转换流-transform-stream",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#转换流-transform-stream","aria-hidden":"true"},"#"),(0,n.Uk)(" 转换流（Transform Stream）")],-1),F=(0,n.Wm)("p",null,"转换流是更加特殊的混合流，在转换流中，可读流是通过某种方式连接到可写流上的。",-1),G=(0,n.Wm)("p",null,[(0,n.Wm)("img",{src:"/posts/images/node-streams/transform-c.png",alt:"转换流"})],-1),K=(0,n.Uk)("最常见的转换流是有 "),Q={href:"https://nodejs.org/api/stream.html#stream_buffering",target:"_blank",rel:"noopener noreferrer"},V=(0,n.Wm)("code",null,"Cipher",-1),X=(0,n.Uk)(" 创建的流。在这个流中，应用程序写入数据，然后再从流中读取加密后的数据。"),$=(0,n.uE)('<h2 id="管道-pipe" tabindex="-1"><a class="header-anchor" href="#管道-pipe" aria-hidden="true">#</a> 管道（Pipe）</h2><p>通常流在连接到一起之后才能发挥更大的作用。我们通过管道来连接流。</p><p>比如我们可以将一个可读流连接到一个可写流或者双工流上，仅仅使用可读流的 <code>pipe()</code> 方法即可。</p><p>常见的管道场景就是复制文件。将 <code>fs.createReadStream()</code> 创建的流通过 <code>pipe()</code> 方法连接到 <code>fs.createWriteStream()</code> 创建的流上去。</p><h3 id="使用流复制数据" tabindex="-1"><a class="header-anchor" href="#使用流复制数据" aria-hidden="true">#</a> 使用流复制数据</h3><p>我们可以将流连接到多个其他流上。这在一些需要重复读取原始数据的场景中非常有用。因为可读流只能读取一次数据，因此我们可以通过 <code>pipe()</code> 方法将可读流连接到多个流上，这样这些被连接的流就可以直接消费数据，不需要创建多个可读流。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> original <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">&#39;./original.txt&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> copy1 <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">&#39;./copy1.txt&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> copy2 <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">&#39;./copy2.txt&#39;</span><span class="token punctuation">)</span>\n\noriginal<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>copy1<span class="token punctuation">)</span>\noriginal<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>copy2<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><img src="/posts/images/node-streams/copy-file-c.png" alt="使用流复制数据"></p><h2 id="高水位线控制-highwatermark" tabindex="-1"><a class="header-anchor" href="#高水位线控制-highwatermark" aria-hidden="true">#</a> 高水位线控制（highWaterMark）</h2><p>在最开始的例子中，我们通过水箱蓄水的例子描述了流的缓存特性。因为上方的水流始终比下方的水流快，水箱中的水越来越多，终究会超过水箱的容积而溢出。</p><p>因此我们需要一个高水位警戒线，当水箱中的水位高于这个警戒线的时候，就需要通知上方的水龙头暂时停止放水了。</p><p><img src="/posts/images/node-streams/high-water-mark-c.png" alt="高水位线控制"></p><p>在流中也是同样的原理，可读流和可写流内部都有缓存，这些缓存的最大可存储量是系统的可用内存量。NodeJS 流通过 <code>highWaterMark</code> 这个配置项来控制缓存中的水位线。</p><p>举个例子，如下图，可读流连接到可写流之后，可写流通过 <code>highWaterMark</code> 来检测缓存中的水位是否过高，高于这条线之后，可写流会通知可读流暂停写入数据。</p><p><img src="/posts/images/node-streams/read-write-high-water-mark-c.png" alt="高水位线控制"></p><p>需要注意的是，<code>highWaterMark</code> 只是一个警示线，并不是一个硬性约束条件。也就是说，如果自定义的流没有正确处理这个警示线的话，可能会导致数据丢失。</p><h2 id="流的应用" tabindex="-1"><a class="header-anchor" href="#流的应用" aria-hidden="true">#</a> 流的应用</h2><p>我们来举个例子综合说明如何使用流。</p><p>假设我们有一个裁减图片的应用程序。用户将图片的地址告诉应用程序，应用程序从网络上读取原始图片，裁减之后再返回给用户。那么我们可以借助于流来实现这个应用程序的功能，如下图。</p><p><img src="/posts/images/node-streams/stream-usage-c.png" alt="裁减图片的应用"></p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',21),ee={render:function(e,a){const s=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.j4)(n.HY,null,[t,r,(0,n.Wm)("p",null,[p,(0,n.Wm)("a",l,[o,(0,n.Wm)(s)]),i]),c,(0,n.Wm)("p",null,[m,(0,n.Wm)("a",d,[h,(0,n.Wm)(s)]),u]),g,(0,n.Wm)("p",null,[k,(0,n.Wm)("a",f,[b,(0,n.Wm)(s)]),W,(0,n.Wm)("a",x,[y,(0,n.Wm)(s)]),_,(0,n.Wm)("a",S,[w,(0,n.Wm)(s)]),v]),j,U,N,(0,n.Wm)("p",null,[J,(0,n.Wm)("a",R,[M,(0,n.Wm)(s)]),T,(0,n.Wm)("a",P,[C,(0,n.Wm)(s)]),q,(0,n.Wm)("a",B,[D,(0,n.Wm)(s)]),E]),H,z,I,(0,n.Wm)("p",null,[L,(0,n.Wm)("a",O,[Y,(0,n.Wm)(s)]),Z]),A,F,G,(0,n.Wm)("p",null,[K,(0,n.Wm)("a",Q,[V,(0,n.Wm)(s)]),X]),$],64)}}}}]);