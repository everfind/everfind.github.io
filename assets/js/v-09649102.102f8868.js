"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[7235],{6109:(n,s,t)=>{t.r(s),t.d(s,{data:()=>a});const a={key:"v-09649102",path:"/posts/2021/07/06/how-process-exit.html",title:"NodeJS 进程是如何退出的",lang:"zh-CN",frontmatter:{title:"NodeJS 进程是如何退出的",description:"描述导致 NodeJS 进程退出的几种情况，以及如何处理。",keywords:["NodeJS 进程","异常处理"],date:"2021-07-06T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"主动退出",slug:"主动退出",children:[]},{level:2,title:"Exceptions, Rejections 和 Emitted Errors",slug:"exceptions-rejections-和-emitted-errors",children:[]},{level:2,title:"信号",slug:"信号",children:[]},{level:2,title:"小结",slug:"小结",children:[]}],filePathRelative:"posts/how-process-exit.md"}},8009:(n,s,t)=>{t.r(s),t.d(s,{default:()=>g});var a=t(6252);const e=(0,a.uE)('<p>有几种因素可以导致 NodeJS 进程退出。在这些因素中，有些是可预防的，比如代码抛出了一个异常；有些是不可预防的，比如内存耗尽。<code>process</code> 这个全局变量是一个 Event Emitter 实例，如果进程优雅退出，<code>process</code> 会派发一个 <code>exit</code> 事件。应用代码可以监听这个事件，来做最后的清理工作。</p><p>下面的表格列举了可以导致进程退出的因素。</p><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">举例</th></tr></thead><tbody><tr><td style="text-align:left;">手动退出</td><td style="text-align:left;"><code>process.exit(1)</code></td></tr><tr><td style="text-align:left;">未捕获的异常</td><td style="text-align:left;"><code>throw new Error()</code></td></tr><tr><td style="text-align:left;">未处理的 promise rejection</td><td style="text-align:left;"><code>Promise.reject()</code></td></tr><tr><td style="text-align:left;">未处理的 error 事件</td><td style="text-align:left;"><code>EventEmitter#emit(&#39;error&#39;)</code></td></tr><tr><td style="text-align:left;">未处理的信号</td><td style="text-align:left;"><code>kill &lt;PROCESS_ID&gt;</code></td></tr></tbody></table><h2 id="主动退出" tabindex="-1"><a class="header-anchor" href="#主动退出" aria-hidden="true">#</a> 主动退出</h2><p><code>process.exit(code)</code> 是最直接的结束进程的方法。<code>code</code> 参数是可选的，可以为 0 ~ 255 之间任何数字，默认为 0。0 表示进程执行成功，非 0 数字表示进程执行失败。</p><p>当 <code>process.exit()</code> 被使用时，控制台不会有任何输出，如果我们想在进程推出的时候像控制台输出一些错误说明信息，则需要在调用之前显示的输出错误信息。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>node -e <span class="token string">&quot;process.exit(42)&quot;</span>\n<span class="token builtin class-name">echo</span> <span class="token variable">$?</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面的代码直接退出了 NodeJS 进程，命令行没有任何输出信息。用户在遭遇进程退出的时候，无法获取有效的错误信息。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">checkConfig</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span>host<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Configuration is missing &#39;host&#39; parameter!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上面的代码中，我们在进程退出之前输出的明确的错误信息。</p><p><code>process.exit()</code> 的功能非常强大，但是我们不应该在工具库中使用。如果在工具库中遇到的错误，我们应该以异常的形式抛出，从而让应用代码决定如何处理这个错误。</p><h2 id="exceptions-rejections-和-emitted-errors" tabindex="-1"><a class="header-anchor" href="#exceptions-rejections-和-emitted-errors" aria-hidden="true">#</a> Exceptions, Rejections 和 Emitted Errors</h2><p><code>process.exit()</code> 在应用启动配置检查等场景中非常有用，但是在处理运行时异常时，它并不适用，我们需要其他的工具。</p><p>比如当应用在处理一个 HTTP 请求时，一个错误不应该导致进程终止，相反，我们应该返回一个含有错误信息的响应。</p><p><code>Error</code> 类可以包含描述错误发生的详细信息的数据，比如调用堆栈和错误文本。通常我们会定义特定场景的 XXXError，这些 XXXError 都继承制 <code>Error</code> 类。</p><p>当我们使用 <code>throw</code> 关键字，或者代码逻辑出错时，一个错误就会被抛出。此时，系统调用栈会释放，每个函数会退出，直到遇到一个 包裹了当前调用的 try/catch 语句。如果没有 try/catch 语句，则这个错误会被认为是未捕获的异常。</p><blockquote><p>通常，在 NodeJS 应用中，我们会给 Error 类定义一个 <code>code</code> 属性，作为用来描述具体错误的错误码，这么做的优点是可以使错误码保持唯一，同时还能使得错误码是可读的。同时，我们也可以配合 <code>message</code> 属性来描述具体的错误信息。</p></blockquote><p>当一个未捕获的异常抛出时，控制台会打印调用堆栈，同时进程退出，退出状态码为 1.</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/tmp/foo.js:1\nthrow new TypeError(&#39;invalid foo&#39;);\n^\nError: invalid foo\n    at Object.&lt;anonymous&gt; (/tmp/foo.js:2:11)\n    ... TRUNCATED ...\n    at internal/main/run_main_module.js:17:47\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这段控制台输出信息说明，错误发生在 <code>foo.js</code> 中的第 2 行第 11 列。</p><p>全局变量 <code>process</code> 是个 Event Emitter 实例，可以通过监听 <code>uncaughtException</code> 事件来处理这些未捕获异常。下面的代码展示了如何使用：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> logger <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./lib/logger.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nprocess<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;uncaughtException&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  logger<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;An uncaught exception has occured&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Promise Rejection 与抛出异常类似。我们可以通过调用 <code>reject()</code> 函数或者在 <code>async</code> 函数中抛出异常来是的 promise 到达 rejected 状态。下面的两段代码功能是相似的。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;oh no&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;oh no&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>目前，在 NodeJS 14 中，Promise Rejection 不会导致进程退出，在后续的版本中，Promise Rejection 可能会导致进程退出。</p><p>下面是一段未捕获的 Promise Rejection 的控制台输出样例。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>(node:52298) UnhandledPromiseRejectionWarning: Error: oh no\n    at Object.&lt;anonymous&gt; (/tmp/reject.js:1:16)\n    ... TRUNCATED ...\n    at internal/main/run_main_module.js:17:47\n(node:52298) UnhandledPromiseRejectionWarning: Unhandled promise\n  rejection. This error originated either by throwing inside of an\n  async function without a catch block, or by rejecting a promise\n  which was not handled with .catch().\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>我们可以通过监听 <code>unhandledRejection</code> 事件来处理未捕获的 Rejection. 样例代码如下：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;unhandledRejection&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">reason<span class="token punctuation">,</span> promise</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Event Emitter 是 NodeJS 中的基础模块，应用广泛。当 Event Emitter 的 <code>error</code> 事件未被处理时，Event Emitter 就会抛出一个错误，同时会导致进程退出。下面是一个 Event Emitter <code>error</code> 的控制台输出。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>events.js:306\n    throw err; // Unhandled &#39;error&#39; event\n    ^\nError [ERR_UNHANDLED_ERROR]: Unhandled error. (undefined)\n    at EventEmitter.emit (events.js:304:17)\n    at Object.&lt;anonymous&gt; (/tmp/foo.js:1:40)\n    ... TRUNCATED ...\n    at internal/main/run_main_module.js:17:47 {\n  code: &#39;ERR_UNHANDLED_ERROR&#39;,\n  context: undefined\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>因此，我们在使用 Event Emitter 的时候，要确保监听了 <code>error</code> 事件，这样在发生错误的时候，可以使得应用能够处理这些错误，避免奔溃。</p><h2 id="信号" tabindex="-1"><a class="header-anchor" href="#信号" aria-hidden="true">#</a> 信号</h2><p>信号是操作信息提供了进程间通信机制。信号通常是一个数字，同时也可以使用一个字符串来标识。比如 <code>SIGKILL</code> 标识数字 9。不同的操作系统对信号的定义不同。下面表格里罗列的是基本通用的信号定义。</p><table><thead><tr><th style="text-align:left;">名称</th><th style="text-align:left;">数字</th><th style="text-align:left;">是否可处理</th><th style="text-align:left;">NodeJS 默认行为</th><th style="text-align:left;">信号的含义</th></tr></thead><tbody><tr><td style="text-align:left;"><code>SIGHUP</code></td><td style="text-align:left;">1</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">父命令行被关闭</td></tr><tr><td style="text-align:left;"><code>SIGINT</code></td><td style="text-align:left;">2</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">命令行尝试中断，即 Ctrl + C</td></tr><tr><td style="text-align:left;"><code>SIGQUIT</code></td><td style="text-align:left;">3</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">命令行尝试退出，即 Ctrl + Z</td></tr><tr><td style="text-align:left;"><code>SIGKILL</code></td><td style="text-align:left;">9</td><td style="text-align:left;">No</td><td style="text-align:left;">退出</td><td style="text-align:left;">强制进程退出</td></tr><tr><td style="text-align:left;"><code>SIGUSR1</code></td><td style="text-align:left;">10</td><td style="text-align:left;">Yes</td><td style="text-align:left;">启动调试器</td><td style="text-align:left;">用户自定义信号</td></tr><tr><td style="text-align:left;"><code>SIGUSR2</code></td><td style="text-align:left;">12</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">用户自定义信号</td></tr><tr><td style="text-align:left;"><code>SIGTERM</code></td><td style="text-align:left;">15</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">进程优雅的退出</td></tr><tr><td style="text-align:left;"><code>SIGSTOP</code></td><td style="text-align:left;">19</td><td style="text-align:left;">No</td><td style="text-align:left;">退出</td><td style="text-align:left;">进程被强制停止</td></tr></tbody></table><p>这表格里，是否可处理表示这个信号是否可被进程接收并被处理。NodeJS 默认行为表示进程在接收到这个信号以后默认执行的动作。</p><p>我们可以通过如下方式来监听这些信号。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token hashbang comment">#!/usr/bin/env node</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Process ID: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>process<span class="token punctuation">.</span>pid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nprocess<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;SIGHUP&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Received: SIGHUP&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nprocess<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;SIGINT&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Received: SIGINT&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// keep process alive</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在一个命令行窗口中运行这段代码，然后按下 Ctrl + C，此时进程不会退出，而是会在控制台打印一行接收到了 <code>SIGINT</code> 信号的日志信息。新起一个命令行窗口，执行如下命令，PROCESS_ID 为上面程序输出的进程 ID。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">kill</span> -s SIGHUP <span class="token operator">&lt;</span>PROCESS_ID<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>通过新起的命令行，我们向原来的那个程序进程发送了一个 <code>SIGHUP</code> 信号，原来的命令行窗口中会打印一行接收到了 <code>SIGHUP</code> 信号的日志信息。</p><p>在 NodeJS 代码中，进程也可以给其他进程发送信号。比如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>node -e <span class="token string">&quot;process.kill(&lt;PROCESS_ID&gt;, &#39;SIGHUP&#39;)&quot;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这段代码同样会在第一个命令行窗口中输出一行接收到了 <code>SIGHUP</code> 信号的日志。</p><p>如果我们要让第一个命令行窗口的进程退出，则可以通过下面的命令来实现。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">kill</span> -9 <span class="token operator">&lt;</span>PROCESS_ID<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',46),p=(0,a.Uk)("在 NodeJS 中，信号通常被用作控制进程优雅的退出。比如，在 "),o={href:"https://kubernetes.io/",target:"_blank",rel:"noopener noreferrer"},l=(0,a.Uk)("Kubernetes"),c=(0,a.Uk)(" 中，当一个 pod 要退出时，k8s 会像 pod 内的进程发送一个 "),i=(0,a.Wm)("code",null,"SIGTERM",-1),r=(0,a.Uk)(" 的信号，同时启动一个 30 秒的定时器。应用程序有 30 秒的时间来关闭连接、保存数据等。如果 30 秒之后进程依然存活，k8s 会再发送一个 "),u=(0,a.Wm)("code",null,"SIGKILL",-1),d=(0,a.Uk)(" 来强制关闭进程。"),k=(0,a.uE)('<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本文讲述了可以导致进程退出的几种因素，分别是：</p><ul><li>主动退出</li><li>未捕获的异常、未处理的 promise rejection、未处理的 Event Emitter error 事件</li><li>系统信号</li></ul><p>我们对每种因素的作用原理和使用方法做了说明。</p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',5),g={render:function(n,s){const t=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.j4)(a.HY,null,[e,(0,a.Wm)("p",null,[p,(0,a.Wm)("a",o,[l,(0,a.Wm)(t)]),c,i,r,u,d]),k],64)}}}}]);