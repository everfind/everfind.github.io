"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[4765],{2903:(e,t,r)=>{r.r(t),r.d(t,{data:()=>l});const l={key:"v-2ca566b1",path:"/courses/architecture-of-react-app/testing.html",title:"测试",lang:"zh-CN",frontmatter:{title:"测试",description:"好的测试可以给项目质量带来质的提升。不同的测试方法侧重点不同，本篇介绍常见的测试方法，以及一些可用的测试工具。",keywords:["React","架构","测试"],date:"2021-08-12T00:00:00.000Z",key:9},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"测试方法",slug:"测试方法",children:[{level:3,title:"单元测试（Unit Test）",slug:"单元测试-unit-test",children:[]},{level:3,title:"集成测试（Integration Test）",slug:"集成测试-integration-test",children:[]},{level:3,title:"端到端测试（E2E Test）",slug:"端到端测试-e2e-test",children:[]}]},{level:2,title:"测试工具",slug:"测试工具",children:[{level:3,title:"Jest",slug:"jest",children:[]},{level:3,title:"Testing Library",slug:"testing-library",children:[]},{level:3,title:"Cypress",slug:"cypress",children:[]}]}],filePathRelative:"courses/architecture-of-react-app/testing.md"}},6927:(e,t,r)=>{r.r(t),r.d(t,{default:()=>O});var l=r(6252);const n=(0,l.Wm)("h2",{id:"测试方法",tabindex:"-1"},[(0,l.Wm)("a",{class:"header-anchor",href:"#测试方法","aria-hidden":"true"},"#"),(0,l.Uk)(" 测试方法")],-1),i=(0,l.Wm)("p",null,"通常有如下几种测试方法：",-1),a=(0,l.Wm)("h3",{id:"单元测试-unit-test",tabindex:"-1"},[(0,l.Wm)("a",{class:"header-anchor",href:"#单元测试-unit-test","aria-hidden":"true"},"#"),(0,l.Uk)(" 单元测试（Unit Test）")],-1),s=(0,l.Wm)("p",null,"单元测试，顾名思义，就是对应用中的某一个功能单元进行测试，这个功能单元可以是一个组件，也可以是一个函数。通常我们会对应用中全局通用的组件和函数进行单元测试。一是因为这些组件和函数相对来说比较独立，二是有时候在集成测试的时候，不容易创建测试场景。",-1),o={href:"https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/ConfirmationDialog/__tests__/ConfirmationDialog.test.tsx",target:"_blank",rel:"noopener noreferrer"},p=(0,l.Uk)("这里是单元测试的样例"),c=(0,l.Wm)("h3",{id:"集成测试-integration-test",tabindex:"-1"},[(0,l.Wm)("a",{class:"header-anchor",href:"#集成测试-integration-test","aria-hidden":"true"},"#"),(0,l.Uk)(" 集成测试（Integration Test）")],-1),h=(0,l.Wm)("p",null,"集成测试，是将应用中多个模块集成在一起进行测试。在我们的测试代码中，大部分测试用例应该都是集成测试。因此只有集成测试才能保证多个模块集成在一起之后的功能是符合预期的。单元测试虽然能保证单个功能单元的表现符合预期，但是不能保证多个单元集成在一起之后的功能是否符合预期。",-1),d={href:"https://github.com/everfind/bulletproof-react/blob/master/src/features/auth/components/__tests__/RegisterForm.test.tsx",target:"_blank",rel:"noopener noreferrer"},m=(0,l.Uk)("这里是集成测试的样例"),u=(0,l.Wm)("h3",{id:"端到端测试-e2e-test",tabindex:"-1"},[(0,l.Wm)("a",{class:"header-anchor",href:"#端到端测试-e2e-test","aria-hidden":"true"},"#"),(0,l.Uk)(" 端到端测试（E2E Test）")],-1),g=(0,l.Wm)("p",null,"端到端（End-to-End）测试是对整个应用整体进行测试。端到端测试会将前端和后端放在一起进行测试，来保证整个系统是正常工作的。端到端测试其实就在模拟用户是如何使用系统的。",-1),b={href:"https://github.com/everfind/bulletproof-react/blob/master/cypress/integration/smoke.ts",target:"_blank",rel:"noopener noreferrer"},W=(0,l.Uk)("这里是端到端测试的样例"),y=(0,l.Wm)("h2",{id:"测试工具",tabindex:"-1"},[(0,l.Wm)("a",{class:"header-anchor",href:"#测试工具","aria-hidden":"true"},"#"),(0,l.Uk)(" 测试工具")],-1),f=(0,l.Wm)("h3",{id:"jest",tabindex:"-1"},[(0,l.Wm)("a",{class:"header-anchor",href:"#jest","aria-hidden":"true"},"#"),(0,l.Uk)(" Jest")],-1),k={href:"https://jestjs.io/",target:"_blank",rel:"noopener noreferrer"},x=(0,l.Uk)("Jest"),v=(0,l.Uk)(" 是一款全功能测试框架，并且在逐步成为测试 JavaScript 应用程序的事实上的标准。"),U=(0,l.Wm)("p",null,"Jest 非常灵活，且提供了丰富的配置项。Jest 既支持对前端应用进行测试，也支持对后端服务进行测试。",-1),_=(0,l.Wm)("h3",{id:"testing-library",tabindex:"-1"},[(0,l.Wm)("a",{class:"header-anchor",href:"#testing-library","aria-hidden":"true"},"#"),(0,l.Uk)(" Testing Library")],-1),C={href:"https://testing-library.com/",target:"_blank",rel:"noopener noreferrer"},w=(0,l.Uk)("Testing Library"),j=(0,l.Uk)(" 是一个测试工具和库的集合。Test Library 旨在让我们能像现实用户使用系统一样测试我们的应用，而不是局限在测试应用的实现细节。"),T=(0,l.Wm)("p",null,"举个例子，我们不应该测试当前组件的状态值是多少，而是应该测试当前组件展示在屏幕中的样子。这样的话，如果我们重构了代码，修改了组件的状态管理代码，但是我们的测试用例依然是有效的，因为组件展示的样子没有变。",-1),E=(0,l.Wm)("h3",{id:"cypress",tabindex:"-1"},[(0,l.Wm)("a",{class:"header-anchor",href:"#cypress","aria-hidden":"true"},"#"),(0,l.Uk)(" Cypress")],-1),J={href:"https://www.cypress.io/",target:"_blank",rel:"noopener noreferrer"},L=(0,l.Uk)("Cypress"),D=(0,l.Uk)(" 是一款自动实行端到端测试的自动化工具。"),I=(0,l.Wm)("p",null,"我们定义一个真实用户会对应用进行怎样的操作，然后 Cypress 工具负责执行这些操作。",-1),R=(0,l.Wm)("p",null,"Cypress 有两种模式：",-1),q=(0,l.Wm)("ul",null,[(0,l.Wm)("li",null,"浏览器模式 -- 会启动一个浏览器来执行测试用例。在用例执行过程中，我们可以使用很多工具来可视化的观察应用的状态变化。我们通常在本地开发的时候会使用浏览器模式。"),(0,l.Wm)("li",null,"无头模式 -- 会启动一个无头浏览器来执行测试用例。非常适合在 CI/CD 中使用。")],-1),z=(0,l.Wm)("p",null,"Cypress 支持配置各种插件和命令，我们甚至可以将其与 Testing Library 进行集成。Cypress 也支持自定义命令，通过自定义命令，我们可以对一些通用任务进行抽象，然后集成到测试中去。",-1),F={href:"https://github.com/everfind/bulletproof-react/blob/master/cypress/support/commands.ts",target:"_blank",rel:"noopener noreferrer"},H=(0,l.Uk)("这里是自定义 Cypress 命令的样例"),N=(0,l.uE)('<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',1),O={render:function(e,t){const r=(0,l.up)("OutboundLink");return(0,l.wg)(),(0,l.j4)(l.HY,null,[n,i,a,s,(0,l.Wm)("p",null,[(0,l.Wm)("a",o,[p,(0,l.Wm)(r)])]),c,h,(0,l.Wm)("p",null,[(0,l.Wm)("a",d,[m,(0,l.Wm)(r)])]),u,g,(0,l.Wm)("p",null,[(0,l.Wm)("a",b,[W,(0,l.Wm)(r)])]),y,f,(0,l.Wm)("p",null,[(0,l.Wm)("a",k,[x,(0,l.Wm)(r)]),v]),U,_,(0,l.Wm)("p",null,[(0,l.Wm)("a",C,[w,(0,l.Wm)(r)]),j]),T,E,(0,l.Wm)("p",null,[(0,l.Wm)("a",J,[L,(0,l.Wm)(r)]),D]),I,R,q,z,(0,l.Wm)("p",null,[(0,l.Wm)("a",F,[H,(0,l.Wm)(r)])]),N],64)}}}}]);