"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[714],{8882:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-b8462e7e",path:"/posts/2021/08/15/nodejs-event-loop.html",title:"NodeJS 的事件循环详解",lang:"zh-CN",frontmatter:{title:"NodeJS 的事件循环详解",description:"什么是 NodeJS 的事件循环？事件循环是如何工作的？setTimeout 和 setImmediate 如何工作？",keywords:["事件循环","任务队列"],date:"2021-08-15T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"libuv 的事件循环",slug:"libuv-的事件循环",children:[]},{level:2,title:"NodeJS 的事件循环",slug:"nodejs-的事件循环",children:[]},{level:2,title:"setImmediate、setTimeout 和 process.nextTick",slug:"setimmediate、settimeout-和-process-nexttick",children:[]},{level:2,title:"Promise",slug:"promise",children:[]},{level:2,title:"总结",slug:"总结",children:[]}],filePathRelative:"posts/nodejs-event-loop.md"}},3048:(n,s,a)=>{a.r(s),a.d(s,{default:()=>i});var e=a(6252);const t=(0,e.Uk)("事件循环是 NodeJS 处理非阻塞 I/O 操作的和核心机制。NodeJS 的事件循环脱胎于 "),p={href:"http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop",target:"_blank",rel:"noopener noreferrer"},o=(0,e.Uk)("libuv"),c=(0,e.Uk)(" 的事件循环，因此，要搞清楚 NodeJS 的事件循环，还需要先了解 libuv 的事件循环是如何工作的。"),l=(0,e.uE)('<h2 id="libuv-的事件循环" tabindex="-1"><a class="header-anchor" href="#libuv-的事件循环" aria-hidden="true">#</a> libuv 的事件循环</h2><p>我们先来了解两个基本概念：句柄（handle）和请求（request）.</p><ul><li>句柄是指在整个事件循环活跃时间内能够执行某些操作的长期对象。比如一个 TCP 服务句柄，每当有新的联接建立时，这个句柄的 <code>connected</code> 回调就会被调用。</li><li>请求是通常指短期操作。比如向某个句柄中写入数据的操作。</li></ul><p>了解了这两个概念以后，我们来看看 libuv 的事件循环是如何工作的。</p><p>下面这张图可以清楚的展示事件循环的执行过程：</p><p><img src="/posts/images/nodejs-event-loop/libuv-loop-c.png" alt="libuv 的事件循环"></p><p>结合这张图我们简单描述一下一次循环过程中各个步骤做了什么。</p><ol><li>首先更新循环内的当前时间（now），避免在循环过程中多次发生与时间相关的系统调用。</li><li>检查当前事件循环是否还是活跃（active）的。检查的表示是当前事件循环是否还有活跃的句柄、活跃的请求操作，或者还有“关闭”回调的话，就视为是活跃的。如果判断当前循环不是活跃的，则直接退出。</li><li>执行所有的到期回调。即所有的到期时间在循环当前时间之前的回调都会被执行。</li><li>执行所有的挂起回调（pending callbacks）。所谓挂起回调，就是在上一个循环周期中设置的到下一循环周期在执行的回调。</li><li>执行空闲句柄回调（idle handle callbacks）。虽然名字中包含空闲二字，实际上每个循环周期都会执行。</li><li>执行准备句柄回调（prepare handle callbacks）。</li><li>在这一步会暂停循环，轮询等待 I/O 事件一段时间。这个时间长度是根据一个算法算出，这里不做详细说明。在轮询期间，所有 I/O 相关的回调会被执行（前提是系统通知到 libuv）。</li><li>执行检查句柄回调（check handle callbacks）。检查句柄回调往往与准备句柄回调相对应。这两个回调可以方便我们在 I/O 之前做一些准备工作，然后在 I/O 之后做相应的检查。</li><li>执行关闭回调（close callbacks）。比如通过 <code>uv_close()</code> 设置的回调。</li></ol><p>整个事件循环就是 1 - 9 的循环执行。</p><p>值得说明的是，libuv 会在轮询阶段中断事件循环，等待系统通知。比如某个文件 I/O 已经完成，或者接收到一个网络连接等。在接收到系统通知后，事件循环会调用相关的回调执行操作。</p><p>不同的平台（windows\\linux 等），异步 I/O 的机制不同，libuv 底层会根据不同平台，采用不同的 I/O 轮询机制，比如 epoll（linux）、kqueue（OSX）、IOCP（windows）等，上层不需要关注异步 I/O 的实现机制。</p><h2 id="nodejs-的事件循环" tabindex="-1"><a class="header-anchor" href="#nodejs-的事件循环" aria-hidden="true">#</a> NodeJS 的事件循环</h2><p>现在我们来看 NodeJS 的事件循环。同样，我们放一张 NodeJS 事件循环的过程图。</p><p><img src="/posts/images/nodejs-event-loop/nodejs-loop-c.png" alt="NodeJS 的事件循环"></p><p>在 NodeJS 中，事件循环的每一步成为一个阶段，每个阶段都有一个 FIFO 队列来执行回调。通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列清空或达到最大回调数限制。当队列清空或者达到最大限制，事件循环进入下一阶段。</p><p>对比两个事件循环的图，我们可以看到，具体过程基本相同。因此，NodeJS 的事件循环过程我们简述如下：</p><ol><li>定时器阶段，执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 调度的回调函数。</li><li>挂起的回调，执行（在上一个循环中被设置）延迟到下一个循环迭代的 I/O 回调。</li><li>idle, prepare 阶段，仅 NodeJS 系统内部使用。</li><li>轮询阶段，检索新的 I/O 事件，执行与 I/O 相关的回调。与 libuv 一样，NodeJS 还在这个阶段暂停循环一段时间。</li><li>检测阶段，执行被 <code>setImmediate()</code> 调度的回调函数。</li><li>关闭的回调函数，执行一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code>。</li></ol><p>我们对轮询阶段做个详细说明。</p><p>轮询阶段有两个重要的功能：</p><ul><li>计算应该阻塞和轮询 I/O 的时间。</li><li>处理轮询队列里的事件。</li></ul><p>一旦事件循环进入轮询阶段并且没有到期的定时器回调时，事件循环将做如下判断：</p><ul><li>如果轮询队列不是空的，那么事件循环将循环访问回调队列并同步执行它们，直到清空队列，或者达到了最大限制。</li><li>如果轮询队列是空的，则再做如下判断： <ul><li>如果有代码是被 <code>setImmediate()</code> 调度的，那么事件循环将结束轮询阶段，并到检查阶段以执行那些被调度的代码。</li><li>如果没有代码被 <code>setImmediate()</code> 调度，那么事件循环将等待回调被添加到队列中，然后立即执行。</li></ul></li></ul><p>在轮询阶段的执行过程中，一旦轮询队列为空，事件循环将检查是否有到期的定制器。如果一个或多个定时器已准备就绪，则事件循环将绕回定时器阶段以执行这些定时器的回调。</p><p>这里要特别对 <code>setImmediate()</code> 进行一些说明。</p><p>在 libuv 的事件循环中，允许开发人员在轮询阶段之前做些准备操作，然后在轮询阶段之后立即对这些操作进行检查。NodeJS 中 <code>setImmediate()</code> 实际上是一个在事件循环的单独阶段运行的特殊定时器。它使用一个 libuv API 来安排回调在轮询阶段完成后执行。</p><h2 id="setimmediate、settimeout-和-process-nexttick" tabindex="-1"><a class="header-anchor" href="#setimmediate、settimeout-和-process-nexttick" aria-hidden="true">#</a> <code>setImmediate</code>、<code>setTimeout</code> 和 <code>process.nextTick</code></h2><ul><li><code>setImmediate()</code> 被设计为一旦在当前轮询阶段完成，就执行代码。</li><li><code>setTimeout()</code> 是在最小阈值（ms 单位）过后执行代码。</li><li><code>process.nextTick()</code> 严格意义上讲并不属于事件循环的一部分。它不管事件循环的当前阶段如何，它都将在当前操作完成后处理 <code>nextTickQueue</code> 中排队的代码。</li></ul><p><code>setImmediate()</code> 和 <code>setTimeout()</code> 很类似，但是基于被调用的时机，他们也有不同表现。</p><p>我们看下面这段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;timeout&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;immediate&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这两个函数调用都在主模块中被调用，则他们的回调执行顺序是不定的，受进程的性能影响很大(进程会受到系统中运行其他应用程序影响)。</p><p>但是一旦将这两个函数放到 I/O 轮询调用内，那么 <code>setImmediate()</code> 一定会在 <code>setTimeout()</code> 之前被执行，不管有多个定制器已经到期。比如下面这段代码，总是会先输出 &quot;immediate&quot;。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nfs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;timeout&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;immediate&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>process.nextTick()</code> 和 <code>setImmediate()</code> 严格意义上来说，应该将名称互换。因为 <code>process.nextTick()</code> 比 <code>setImmediate()</code> 触发得更快。</p><p>任何时候在给定的阶段中调用 <code>process.nextTick()</code>，所有传递到 <code>process.nextTick()</code> 的回调将在事件循环继续之前解析。之所以这么设计，是考虑到这些使用场景：</p><ul><li>允许开发者处理错误，清理任何不需要的资源，或者在事件循环继续之前重试请求。</li><li>有时有让回调在栈展开后，但在事件循环继续之前运行的必要。</li></ul><p>比如下面这段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nserver<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;listening&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>只有传递端口时，端口才会立即被绑定，然后立即调用 <code>&#39;listening&#39;</code> 回调。问题是 <code>.on(&#39;listening&#39;)</code> 的回调在那个时间点尚未被设置。</p><p>为了绕过这个问题，<code>&#39;listening&#39;</code> 事件被排在 <code>nextTick()</code> 中，以允许脚本运行完成。这让用户设置所想设置的任何事件处理器。</p><h2 id="promise" tabindex="-1"><a class="header-anchor" href="#promise" aria-hidden="true">#</a> Promise</h2><p>这里在补充说明一下 NodeJS 中 Promise 是如何处理的。我们之前说过，在浏览器的事件循环里，会有一个微任务的队列来防止所有的微任务，并且在每个操作之后，都尝试清空微任务队列。</p><p>在 NodeJS 中，做法类似，NodeJS 的事件循环中也有一个微任务队列，工作机制与 <code>process.nextTick()</code> 类似，在每个操作之后，事件循环都会尝试清空微任务队列。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>我们结合 libuv 的事件循环，详细说明了 NodeJS 事件循环的每一阶段的具体职能。同时，我们还分析了常用的几个异步代码函数的原理。</p><p>我们用一张图归纳如下：</p><p><img src="/posts/images/nodejs-event-loop/event-loop-c.png" alt="事件循环"></p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',48),i={render:function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[(0,e.Wm)("p",null,[t,(0,e.Wm)("a",p,[o,(0,e.Wm)(a)]),c]),l],64)}}}}]);