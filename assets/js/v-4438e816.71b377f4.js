"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[414],{963:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-4438e816",path:"/posts/2021/07/30/browser-event-loop.html",title:"浏览器中的事件循环与异步代码执行",lang:"zh-CN",frontmatter:{title:"浏览器中的事件循环与异步代码执行",description:"什么是事件循环？事件循环是如何工作的？宏任务、微任务分别是什么？",keywords:["事件循环","任务队列","宏任务","微任务"],date:"2021-07-30T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"事件循环（Event Loop）",slug:"事件循环-event-loop",children:[{level:3,title:"执行过程",slug:"执行过程",children:[]}]},{level:2,title:"任务与微任务",slug:"任务与微任务",children:[]},{level:2,title:"执行异步代码",slug:"执行异步代码",children:[{level:3,title:"回调函数",slug:"回调函数",children:[]},{level:3,title:"setTimeout 和 setInterval",slug:"settimeout-和-setinterval",children:[]},{level:3,title:"requestAnimationFrame",slug:"requestanimationframe",children:[]},{level:3,title:"Promise 和 Async/await",slug:"promise-和-async-await",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",children:[]}],filePathRelative:"posts/browser-event-loop.md"}},5279:(n,a,s)=>{s.r(a),s.d(a,{default:()=>z});var e=s(6252);const t=(0,e.uE)('<p>在浏览器中，JavaScript 的执行是单线程的。如何在单线程中实现异步操作呢？答案就是事件循环。</p><h2 id="事件循环-event-loop" tabindex="-1"><a class="header-anchor" href="#事件循环-event-loop" aria-hidden="true">#</a> 事件循环（Event Loop）</h2><p>浏览器通过事件循环来处理事件、用户交互、JS 代码执行、渲染、网络请求等。通常又两种事件循环，一种是 Window 事件循环，一种是 Worker 事件循环。由于它们核心的工作原理相同，本文我们仅仅讨论 Window 事件循环。</p><p>事件循环，首先是一个循环，每个循环周期会执行一些代码，一个循环周期被称为 <code>tick</code>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>eventLoop<span class="token punctuation">.</span><span class="token function">waitForTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  eventLoop<span class="token punctuation">.</span><span class="token function">processNextTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>一个事件循环有一到多个任务队列。每个任务队列就是一个有序的任务列表。可以理解为一段要执行的代码，或者浏览器要执行的一个动作，比如发送事件、解析 HTML 等。</p>',6),p=(0,e.Uk)("网页和浏览器本身的用户界面程序运行在相同的线程中，共享相同的事件循环。 该线程就是"),o={href:"https://developer.mozilla.org/zh-CN/docs/Glossary/Main_thread",target:"_blank",rel:"noopener noreferrer"},l=(0,e.Uk)("主线程"),c=(0,e.Uk)("，它除了运行网页本身的代码之外，还负责收集和派发用户和其它事件，以及渲染和绘制网页内容等。然后，事件循环会驱动发生在浏览器中与用户交互有关的一切。"),i=(0,e.uE)('<h3 id="执行过程" tabindex="-1"><a class="header-anchor" href="#执行过程" aria-hidden="true">#</a> 执行过程</h3><p>简略的说，事件循环在每一个循环周期都会顺序执行下面的步骤：</p><ol><li>选择一个任务队列，从队列中取出最靠前（最老的）的任务。如果已经没有任务了，则跳到第 3 步。</li><li>执行取出的任务。</li><li>从微任务（Micro Task）队列中取出微任务执行，知道清空微任务队列。</li><li>更新渲染（resize、scroll、动画等）</li><li>返回第 1 步。</li></ol><p>每一个时间循环都有一个微任务队列。微任务队列与任务队列很像，不同的地方在于，每次循环周期只会执行任务队列中的一个任务，在这期间产生的任何任务都只能在下一个循环周期中才能得以执行。在执行前任务后，事件循环会一次执行微任务队列中的每一个微任务，直到微任务队列为空。也就是说，在微任务执行过程中新产生的微任务，也会在当前循环周期内得到执行。</p><p>不同的任务队列可能有不同的优先级。比如浏览器可能会将用户鼠标和键盘输入（用户交互）的任务都放在一个任务队列中，其他任务放到另外一个队列中。在每个循环周期中优先从用户交互队列中取出任务执行，来保证及时响应用户操作。</p><p>下图展示了一个事件循环周期的执行过程。</p><p><img src="/posts/images/browser-event-loop/event-loop.svg" alt="事件循环"></p><h2 id="任务与微任务" tabindex="-1"><a class="header-anchor" href="#任务与微任务" aria-hidden="true">#</a> 任务与微任务</h2><p>一个任务可以简单的理解为一段要执行的 JavaScript 代码。比如当执行 <code>&lt;script&gt;</code> 标签中的代码时，一个任务会被添加到任务队列中。事件的回调函数、<code>setTimeout</code>、<code>setInterval</code> 的回调函数都会作为任务放到任务队列中。</p><p>每个事件循环周期，事件循环会从任务队列中取出一个最老的任务执行，其他任务要等到下一个事件循环周期才会执行。</p><p>微任务与任务没有本质的区别，只是因为被放入的微任务任务队列。事件循环在每个循环周期都会清空微任务队列中的任务。</p>',11),r=(0,e.Uk)("在浏览器的实现中，"),u=(0,e.Wm)("code",null,"setTimeout",-1),d=(0,e.Uk)(" 和 "),k=(0,e.Wm)("code",null,"setInterval",-1),m=(0,e.Uk)(" 被放在了任务队列中，"),h=(0,e.Wm)("code",null,"Promise",-1),b=(0,e.Uk)(" 和 "),g={href:"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver",target:"_blank",rel:"noopener noreferrer"},v=(0,e.Uk)("Mutation Observer API"),f=(0,e.Uk)(" 被放在的微任务队列中。我们也可以借助于 "),y={href:"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask",target:"_blank",rel:"noopener noreferrer"},w=(0,e.Uk)("queueMicrotask()"),x=(0,e.Uk)(" 函数向微任务队列中添加任务。"),W=(0,e.uE)('<h2 id="执行异步代码" tabindex="-1"><a class="header-anchor" href="#执行异步代码" aria-hidden="true">#</a> 执行异步代码</h2><p>我们有很多种方式来执行异步代码。</p><h3 id="回调函数" tabindex="-1"><a class="header-anchor" href="#回调函数" aria-hidden="true">#</a> 回调函数</h3><p>我们可以给一些事件添加监听，设置回调函数，从而在触发事件的时候执行函数。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>buttonEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* 点击响应 */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>回调函数会被放到任务队列中执行。</p><h3 id="settimeout-和-setinterval" tabindex="-1"><a class="header-anchor" href="#settimeout-和-setinterval" aria-hidden="true">#</a> setTimeout 和 setInterval</h3><p>这两个函数大家都非常熟悉，<code>setTimeout</code> 会在指定的时间之后执行回调函数，<code>setInterval</code> 会每个一定的时间执行一次回调函数。这些回调函数都是以任务的形式被添加到任务队列中。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 1s 后执行 */</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 每 500 ms 执行一次 */</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>注意，这两个函数都接收一个时间参数。但是实际运行的时候，事件循环并不会保证一定按照这个时间执行。</p></blockquote><h3 id="requestanimationframe" tabindex="-1"><a class="header-anchor" href="#requestanimationframe" aria-hidden="true">#</a> requestAnimationFrame</h3><p><code>requestAnimationFrame</code> 是一个特殊的工具函数，浏览器会在重绘页面之前调用这个函数设置的回调，允许我们在页面重绘之前更新页面。</p><p>通过这个函数，我们可以很好的在代码执行和运行设备的显示帧率（display frame rate）之间取得一个平衡。</p><p>假如，我们通过 <code>setInterval</code> 来控制动画，由于每个事件循环周期执行的时间不可控，而显示器的刷新频率是固定的（通常是 60Hz），因此如果我们的动画执行过快，会出现掉帧，执行过慢又会有卡顿现象。</p><p><code>requestAnimationFrame</code> 会综合考虑显示器的刷新频率和代码的执行，以达到动画能够顺滑执行。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 执行一次 */</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 每个事件循环都会考虑执行</span>\n<span class="token keyword">function</span> <span class="token function">alwaysRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 函数逻辑 */</span>\n  <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>alwaysRun<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">alwaysRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="promise-和-async-await" tabindex="-1"><a class="header-anchor" href="#promise-和-async-await" aria-hidden="true">#</a> Promise 和 Async/await</h3><p>Promise 和 Async/await 最终都会以 <code>promise</code> 的形式在代码中执行。</p><p>Promise 可以帮助我们管理有依赖关系的任务，同时可以一定程度的避免回调函数的回调地狱问题。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 函数逻辑 */</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 链式调用</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Async/await 是 Promise 的语法糖，可以帮助我们实现以同步的形式编写异步代码，解决了回调地狱问题。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">await</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">await</span> <span class="token function">someOtherFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Promise 和 Async/await 的任务都是微任务，会被放到微任务队列中。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',24),j={href:"https://www.w3.org/TR/html51/webappapis.html#event-loops",target:"_blank",rel:"noopener noreferrer"},U=(0,e.Uk)("HTML5 规范中的事件循环"),_={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth",target:"_blank",rel:"noopener noreferrer"},A=(0,e.Uk)("深入：微任务与Javascript运行时环境"),q={href:"https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide",target:"_blank",rel:"noopener noreferrer"},P=(0,e.Uk)("Using microtasks in JavaScript with queueMicrotask()"),I={href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Choosing_the_right_approach",target:"_blank",rel:"noopener noreferrer"},M=(0,e.Uk)("Choosing the right approach"),T=(0,e.uE)('<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',1),z={render:function(n,a){const s=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[t,(0,e.Wm)("p",null,[p,(0,e.Wm)("a",o,[l,(0,e.Wm)(s)]),c]),i,(0,e.Wm)("blockquote",null,[(0,e.Wm)("p",null,[r,u,d,k,m,h,b,(0,e.Wm)("a",g,[v,(0,e.Wm)(s)]),f,(0,e.Wm)("a",y,[w,(0,e.Wm)(s)]),x])]),W,(0,e.Wm)("ul",null,[(0,e.Wm)("li",null,[(0,e.Wm)("a",j,[U,(0,e.Wm)(s)])]),(0,e.Wm)("li",null,[(0,e.Wm)("a",_,[A,(0,e.Wm)(s)])]),(0,e.Wm)("li",null,[(0,e.Wm)("a",q,[P,(0,e.Wm)(s)])]),(0,e.Wm)("li",null,[(0,e.Wm)("a",I,[M,(0,e.Wm)(s)])])]),T],64)}}}}]);