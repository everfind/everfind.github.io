"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[9547],{5881:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t={key:"v-64a2fc74",path:"/solutions/micro-frontend/",title:"微前端实践方案",lang:"zh-CN",frontmatter:{title:"微前端实践方案",description:"本系列会从概念出发，详细介绍目前主流微前端方案的各个组成部分以及技术原理。",sidebar:!1,key:1},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[],filePathRelative:"solutions/micro-frontend/README.md",articleList:[{key:"v-70766a09",path:"/solutions/micro-frontend/microfrontend.html",title:"理解微前端技术原理",lang:"zh-CN",frontmatter:{title:"理解微前端技术原理",description:"从概念、技术原理、实践经验等层面，对目前主流的微前端架构方案进行分析。",keywords:["micro frontend","微前端","qiankun","single spa"],date:"2021-11-21T00:00:00.000Z",key:1,tags:["概念"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"什么是微前端",slug:"什么是微前端",children:[]},{level:2,title:"技术分析",slug:"技术分析",children:[{level:3,title:"路由与子应用加载",slug:"路由与子应用加载",children:[]},{level:3,title:"隔离",slug:"隔离",children:[]}]},{level:2,title:"需要注意的问题",slug:"需要注意的问题",children:[]}],content:"\n我最早是在 2016 年接触到微前端的，当时社区里以介绍概念居多，在实践方案，尤其是在业务落地方面应用的比较少。后来，随着方案逐渐成熟，社区里关于微前端的讨论越来越多。\n\n今天，我们先从概念、关键技术原理层面来对微前端进行详细说明。后续会有专门的文章来介绍微前端的实践经验。\n\n## 什么是微前端\n微前端的概念来源于微服务，其整体的架构思路是将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，之后将这些应用组成整体，在用户看来仍然是内聚的单个产品，用户体验是一致的。\n\n从概念上看，微前端架构由主应用和子应用两个部分组成，子应用负责具体的业务实现，主应用负责子应用的加载和卸载，即生命周期管理。\n\n从概念延伸开来，我们不难发现，使用微前端，可以获得如下收益：\n\n* 子应用独立开发、部署，技术栈无关\n  拆分以后，子应用拥有独立的代码仓库、独立的开发部署流程，甚至可以自由的使用任何技术栈进行开发。由此，我们可以在组织架构层面形成不同的团队来负责不同的业务模块，各个团队之间相对独立自主，互不干扰。\n* 增量升级，多技术体系共存\n  对于很多大型的组织，他们的产品通常都经历了长期的迭代，功能复杂，同时技术栈通常也比较老旧。使用微前端以后，借助于独立的子应用，可以获得增量升级的能力。既可以实现新功能使用新的技术栈，同时与老技术栈共存。又可以对老功能进行逐步迭代升级，小步快跑。\n* 产品层面的自由组合\n  借助于微前端，我们可以对各个子应用自由的进行上下线。换句话说，我们可以根据产品需要，自由的将不同的子应用组合成新的产品。\n\n## 技术分析\n\n在微前端架构下，有主应用和子应用两个基本角色。子应用负责具体的业务逻辑，主应用负责调度子应用。考虑到主应用的特殊性功能，为了保证整个框架的可用性，通常主应用不负责任何业务逻辑。\n\n### 路由与子应用加载\n\n由于主应用负责调度子应用，因此主应用需要具备路由管理和资源加载能力。所谓路由管理，就是主应用中需要维护一个路由表，当页面路由发生变化的时候，主应用可以知道当前需要启动哪个子应用。这个路由表可以是动态的，也可以是静态的。\n\n知道启动哪个子应用之后，主应用就需要加载子应用的资源。通常有两种资源加载方式：\n\n* JS Entry。\n  通常将子应用的所有资源打包成一个入口文件，在 [single-spa](https://single-spa.js.org/docs/examples) 的很多样例中就使用了这种方式。\n* HTML Entry。\n  子应用构建输出的是一个 HTML 文件，主应用通过加载这个 HTML 文件完成子应用的加载。\n\n相比较而言，JS Entry 的方案限制更多一些，比如要求将图片、样式等所有资源打包成一个 JS Bundle，构建的包太大，也无法利用浏览器的并行加载能力。同时，子应用还需要与主应用约定好要挂载的节点，主应用要提前初始化好，或者子应用自行创建，避免挂载失败或者冲突。\n\nHTML Entry 很好的避免了 JS Entry 的问题。本质上，HTML 文件充当的是应用静态资源表的角色。主应用加载了 HTML 以后，浏览器会自行下载子应用的各种资源。同时，由于构建产物是 HTML，子应用具备与独立应用开发时一致的开发体验。当然，HTML Entry 也存在缺点，比如要多一次请求，先加载了 HTML 才能知道加载哪些资源。\n\n在加载完子应用的资源以后，主应用就可以启动子应用，完成页面渲染了。那么该如何启动子应用呢？主应用需要与子应用之前制定一个接口规范，比如在 single-spa 中就指定了 `bootstrap`、`mount`、`unmount` 和 `unload` 四个方法。子应用暴露这四个方法给主应用，主应用通过这四个方法来管理子应用的声明周期。\n\n### 隔离\n解决了路由和子应用加载的问题，理论上说我们已经实现了微前端的核心能力。但是，在实际的工程实践中，我们还需要解决很多的细节问题。其中最大的一部分就是如何做好子应用间的隔离。比如如何避免子应用间的样式冲突。\n\n抛开现有的微前端方案，假如让我们从头开始实现一套微前端架构，将独立开发部署的各个子应用组合起来。相信大多数同学都会首先想到 [iframe](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe)。其实我们就可以通过 iframe 来理解微前端架构中的种种技术细节。\n\niframe 自带的样式、环境隔离机制使得它具备天然的沙箱能力，但是 iframe 也有很多天然的缺陷，比如事件无法冒泡到顶层，路由跳转无法与主应用同步，与主应用通信复杂繁琐等。\n\n我们可以参考 iframe 的设计思想，来设计如何对子应用进行隔离。一个传统的 iframe 具备四层能力：文档的加载能力、HTML 的渲染能力、独立执行 JavaScript 的能力、隔离样式的能力。\n\n文档的加载能力和 HTML 的渲染能力在前面主应用加载子应用资源的时候，我们已经做了说明。\n\n我们现在来说说如何实现独立的 JavaScript 运行环境和样式隔离。\n\n#### 沙箱（sandbox）\n\n通常，子应用在运行期间会有一些污染性的副作用产生，比如全局变量、全局事件、定时器、网络请求、localStorage、全局 Style 样式、全局 DOM 元素等。为了保证应用能够稳定的运行且互不影响，需要提供安全的运行环境，能够有效地隔离、收集、清除应用在运行期间所产生的副作用，也就是沙箱的设计目标。\n\n有两种沙箱的设计思路。一种是快照模式，另一种是虚拟机（virtual machine）模式。\n\n##### 快照模式\n\n所谓快照模式，就是将启动子应用之前，对当前环境打一个快照，子应用退出之后，再重新加载这个快照来恢复环境。\n\n在实现层面，我们可以针对每一种副作用设计一个 `save` 方法保存当前状态，在设计一个 `load` 方法来加载保存的状态。\n\n框照模式的缺陷是对操作的顺序要求非常严格，当页面有多个子应用的时候，快照沙箱就会有多个实例存在，此时不同顺序的 `save` 和 `load` 会产生问题。\n##### VM（虚拟机）模式\n\n虚拟机想必大家都听说过，是一种计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。使用虚拟机就跟使用真实的计算机一样。\n\nNodeJS 中也提供了 [VM 模块](https://nodejs.org/api/vm.html)，不过不同于传统的 VM，它并不具备虚拟机那么强的隔离性，并没有模拟完整的硬件系统，仅仅将指定代码放置了特定的上下文中编译并执行，无法用来执行不可信来源的代码。\n\n下面的代码展示了 NodeJS 的 VM 模块的基本用法：\n\n```js\nconst vm = require('vm');\n\nconst x = 1;\n\nconst context = { x: 2 };\nvm.createContext(context); // 将 context 对象上下文化\n\nconst code = 'x += 40; var y = 17;';\n// `x` and `y` 在上下文中是全局变量\n// 初始状态下, x 的值为 2，因为 context.x 得值是 2\nvm.runInContext(code, context);\n\nconsole.log(context.x); // 42\nconsole.log(context.y); // 17\n\nconsole.log(x); // 1; y 为未定义\n```\n\n参考 NodeJS 中 VM 模块的设计，以及 JavaScript 词法作用域的特性，可以设计出 VM 沙箱，不过与传统的 VM 差异也同样存在，它并不能执行不可信的代码，因为它的隔离能力仅限于将其运行在一个指定的上下文环境中。\n\n```js\nlet code = `(function(document, window){ /* 代码逻辑 */ })`\n\n(new Function('document', 'window', code)(fakeDocument, fakeWindow))\n```\n\n针对前面提到的子应用运行产生的全局变量、全局事件等种种副作用，我们可以针对性的做处理，提供新的执行上下文。比如，用新的 window 对象用来隔离全局变量，用新的 document 来收集创建的 dom 对象，style 样式，script 标签等。全局事件、localStorage 等都可以一一进行处理。\n\n下面借助于 `Proxy`，我们可以轻松的对当前的执行上下文进行劫持，创建新的执行上下文。下面的代码展示了如何劫持 window 对象。\n\n```js\nconst varBox = {};\nconst fakeWindow = new Proxy(window, {\n  get(target, key) {\n    return varBox[key] || window[key];\n  },\n  set(target, key, value) {\n    varBox[key] = value;\n    return true;\n  }\n});\n\nconst code = `(function(window) {\n  window.a = '111';\n  console.log(window.a);\n})`;\n\nconst fn = new Function('window', code);\nfn(fakeWindow);\n```\n\nVM 模式的沙箱，可以有效的解决子应用之间、主子应用之间各种副作用的有效隔离问题。[qiankun](https://qiankun.umijs.org/zh) 的沙箱模式就是 VM 模式。\n\n##### 样式隔离\n\n虽然说，VM 模式的沙箱可以收集子应用运行过程中产生的样式，然后在子应用卸载的时候去除样式，但是考虑到子应用的 dom 结构最终还是要并入到主应用的 dom 树中去，VM 沙箱无法避免主应用的样式干扰到子应用的样式的问题。\n\n这时候，我们就需要借助于一些其他手段，比如在主子应用中都使用 [css modules](https://github.com/css-modules/css-modules) 来减少样式冲突。\n\n#### Shadow Dom\n\n如果不考虑兼容性，[Shadow Dom](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM) 是子应用样式隔离的一个绝佳选择。\n\n我们把子应用放到 Shadow Dom 中，可以原生实现子应用间的样式隔离。但是 Shadow Dom 本身也有诸多限制，很多依赖库还不支持 Shadow Dom。比如埋点检测，事件处理等。\n\n我们这里仅是将 Shadow Dom 作为补充技术方案来进行说明。\n\n> qiankun 官方也将在[未来的版本](https://github.com/umijs/qiankun/discussions/1378#discussioncomment-598734)中逐步弃用 Shadow Dom。\n\n## 需要注意的问题\n\n技术领域有句话叫“没有永远的银弹”。本文开头我们介绍了使用微前端可以获得的很多收益，现在我们来讲讲微前端带来的问题。\n\n* 整个产品的复杂度从代码转移到了基础设施\n  我们需要有一套应用注册、管理的系统，并要和现有的应用发布流程对接。同时还要围绕微前端方案构建一整套的基础工具，比如开发调试工具，埋点监控系统等。\n\n* 增加了学习和理解成本\n  子应用或多或少要了解一些微前端方案的技术原理，才能带来更好的开发和产品体验。\n",contentRendered:'<p>我最早是在 2016 年接触到微前端的，当时社区里以介绍概念居多，在实践方案，尤其是在业务落地方面应用的比较少。后来，随着方案逐渐成熟，社区里关于微前端的讨论越来越多。</p>\n<p>今天，我们先从概念、关键技术原理层面来对微前端进行详细说明。后续会有专门的文章来介绍微前端的实践经验。</p>\n<h2 id="什么是微前端" tabindex="-1"><a class="header-anchor" href="#什么是微前端" aria-hidden="true">#</a> 什么是微前端</h2>\n<p>微前端的概念来源于微服务，其整体的架构思路是将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，之后将这些应用组成整体，在用户看来仍然是内聚的单个产品，用户体验是一致的。</p>\n<p>从概念上看，微前端架构由主应用和子应用两个部分组成，子应用负责具体的业务实现，主应用负责子应用的加载和卸载，即生命周期管理。</p>\n<p>从概念延伸开来，我们不难发现，使用微前端，可以获得如下收益：</p>\n<ul>\n<li>子应用独立开发、部署，技术栈无关\n拆分以后，子应用拥有独立的代码仓库、独立的开发部署流程，甚至可以自由的使用任何技术栈进行开发。由此，我们可以在组织架构层面形成不同的团队来负责不同的业务模块，各个团队之间相对独立自主，互不干扰。</li>\n<li>增量升级，多技术体系共存\n对于很多大型的组织，他们的产品通常都经历了长期的迭代，功能复杂，同时技术栈通常也比较老旧。使用微前端以后，借助于独立的子应用，可以获得增量升级的能力。既可以实现新功能使用新的技术栈，同时与老技术栈共存。又可以对老功能进行逐步迭代升级，小步快跑。</li>\n<li>产品层面的自由组合\n借助于微前端，我们可以对各个子应用自由的进行上下线。换句话说，我们可以根据产品需要，自由的将不同的子应用组合成新的产品。</li>\n</ul>\n<h2 id="技术分析" tabindex="-1"><a class="header-anchor" href="#技术分析" aria-hidden="true">#</a> 技术分析</h2>\n<p>在微前端架构下，有主应用和子应用两个基本角色。子应用负责具体的业务逻辑，主应用负责调度子应用。考虑到主应用的特殊性功能，为了保证整个框架的可用性，通常主应用不负责任何业务逻辑。</p>\n<h3 id="路由与子应用加载" tabindex="-1"><a class="header-anchor" href="#路由与子应用加载" aria-hidden="true">#</a> 路由与子应用加载</h3>\n<p>由于主应用负责调度子应用，因此主应用需要具备路由管理和资源加载能力。所谓路由管理，就是主应用中需要维护一个路由表，当页面路由发生变化的时候，主应用可以知道当前需要启动哪个子应用。这个路由表可以是动态的，也可以是静态的。</p>\n<p>知道启动哪个子应用之后，主应用就需要加载子应用的资源。通常有两种资源加载方式：</p>\n<ul>\n<li>JS Entry。\n通常将子应用的所有资源打包成一个入口文件，在 <a href="https://single-spa.js.org/docs/examples" target="_blank" rel="noopener noreferrer">single-spa<OutboundLink/></a> 的很多样例中就使用了这种方式。</li>\n<li>HTML Entry。\n子应用构建输出的是一个 HTML 文件，主应用通过加载这个 HTML 文件完成子应用的加载。</li>\n</ul>\n<p>相比较而言，JS Entry 的方案限制更多一些，比如要求将图片、样式等所有资源打包成一个 JS Bundle，构建的包太大，也无法利用浏览器的并行加载能力。同时，子应用还需要与主应用约定好要挂载的节点，主应用要提前初始化好，或者子应用自行创建，避免挂载失败或者冲突。</p>\n<p>HTML Entry 很好的避免了 JS Entry 的问题。本质上，HTML 文件充当的是应用静态资源表的角色。主应用加载了 HTML 以后，浏览器会自行下载子应用的各种资源。同时，由于构建产物是 HTML，子应用具备与独立应用开发时一致的开发体验。当然，HTML Entry 也存在缺点，比如要多一次请求，先加载了 HTML 才能知道加载哪些资源。</p>\n<p>在加载完子应用的资源以后，主应用就可以启动子应用，完成页面渲染了。那么该如何启动子应用呢？主应用需要与子应用之前制定一个接口规范，比如在 single-spa 中就指定了 <code>bootstrap</code>、<code>mount</code>、<code>unmount</code> 和 <code>unload</code> 四个方法。子应用暴露这四个方法给主应用，主应用通过这四个方法来管理子应用的声明周期。</p>\n<h3 id="隔离" tabindex="-1"><a class="header-anchor" href="#隔离" aria-hidden="true">#</a> 隔离</h3>\n<p>解决了路由和子应用加载的问题，理论上说我们已经实现了微前端的核心能力。但是，在实际的工程实践中，我们还需要解决很多的细节问题。其中最大的一部分就是如何做好子应用间的隔离。比如如何避免子应用间的样式冲突。</p>\n<p>抛开现有的微前端方案，假如让我们从头开始实现一套微前端架构，将独立开发部署的各个子应用组合起来。相信大多数同学都会首先想到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener noreferrer">iframe<OutboundLink/></a>。其实我们就可以通过 iframe 来理解微前端架构中的种种技术细节。</p>\n<p>iframe 自带的样式、环境隔离机制使得它具备天然的沙箱能力，但是 iframe 也有很多天然的缺陷，比如事件无法冒泡到顶层，路由跳转无法与主应用同步，与主应用通信复杂繁琐等。</p>\n<p>我们可以参考 iframe 的设计思想，来设计如何对子应用进行隔离。一个传统的 iframe 具备四层能力：文档的加载能力、HTML 的渲染能力、独立执行 JavaScript 的能力、隔离样式的能力。</p>\n<p>文档的加载能力和 HTML 的渲染能力在前面主应用加载子应用资源的时候，我们已经做了说明。</p>\n<p>我们现在来说说如何实现独立的 JavaScript 运行环境和样式隔离。</p>\n<h4 id="沙箱-sandbox" tabindex="-1"><a class="header-anchor" href="#沙箱-sandbox" aria-hidden="true">#</a> 沙箱（sandbox）</h4>\n<p>通常，子应用在运行期间会有一些污染性的副作用产生，比如全局变量、全局事件、定时器、网络请求、localStorage、全局 Style 样式、全局 DOM 元素等。为了保证应用能够稳定的运行且互不影响，需要提供安全的运行环境，能够有效地隔离、收集、清除应用在运行期间所产生的副作用，也就是沙箱的设计目标。</p>\n<p>有两种沙箱的设计思路。一种是快照模式，另一种是虚拟机（virtual machine）模式。</p>\n<h5 id="快照模式" tabindex="-1"><a class="header-anchor" href="#快照模式" aria-hidden="true">#</a> 快照模式</h5>\n<p>所谓快照模式，就是将启动子应用之前，对当前环境打一个快照，子应用退出之后，再重新加载这个快照来恢复环境。</p>\n<p>在实现层面，我们可以针对每一种副作用设计一个 <code>save</code> 方法保存当前状态，在设计一个 <code>load</code> 方法来加载保存的状态。</p>\n<p>框照模式的缺陷是对操作的顺序要求非常严格，当页面有多个子应用的时候，快照沙箱就会有多个实例存在，此时不同顺序的 <code>save</code> 和 <code>load</code> 会产生问题。</p>\n<h5 id="vm-虚拟机-模式" tabindex="-1"><a class="header-anchor" href="#vm-虚拟机-模式" aria-hidden="true">#</a> VM（虚拟机）模式</h5>\n<p>虚拟机想必大家都听说过，是一种计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。使用虚拟机就跟使用真实的计算机一样。</p>\n<p>NodeJS 中也提供了 <a href="https://nodejs.org/api/vm.html" target="_blank" rel="noopener noreferrer">VM 模块<OutboundLink/></a>，不过不同于传统的 VM，它并不具备虚拟机那么强的隔离性，并没有模拟完整的硬件系统，仅仅将指定代码放置了特定的上下文中编译并执行，无法用来执行不可信来源的代码。</p>\n<p>下面的代码展示了 NodeJS 的 VM 模块的基本用法：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'vm\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\nvm<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 context 对象上下文化</span>\n\n<span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token string">\'x += 40; var y = 17;\'</span><span class="token punctuation">;</span>\n<span class="token comment">// `x` and `y` 在上下文中是全局变量</span>\n<span class="token comment">// 初始状态下, x 的值为 2，因为 context.x 得值是 2</span>\nvm<span class="token punctuation">.</span><span class="token function">runInContext</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 17</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1; y 为未定义</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>参考 NodeJS 中 VM 模块的设计，以及 JavaScript 词法作用域的特性，可以设计出 VM 沙箱，不过与传统的 VM 差异也同样存在，它并不能执行不可信的代码，因为它的隔离能力仅限于将其运行在一个指定的上下文环境中。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(function(document, window){ /* 代码逻辑 */ })</span><span class="token template-punctuation string">`</span></span>\n\n<span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">\'document\'</span><span class="token punctuation">,</span> <span class="token string">\'window\'</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">(</span>fakeDocument<span class="token punctuation">,</span> fakeWindow<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>针对前面提到的子应用运行产生的全局变量、全局事件等种种副作用，我们可以针对性的做处理，提供新的执行上下文。比如，用新的 window 对象用来隔离全局变量，用新的 document 来收集创建的 dom 对象，style 样式，script 标签等。全局事件、localStorage 等都可以一一进行处理。</p>\n<p>下面借助于 <code>Proxy</code>，我们可以轻松的对当前的执行上下文进行劫持，创建新的执行上下文。下面的代码展示了如何劫持 window 对象。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> varBox <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> fakeWindow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> varBox<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> window<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    varBox<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(function(window) {\n  window.a = \'111\';\n  console.log(window.a);\n})</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">\'window\'</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">fn</span><span class="token punctuation">(</span>fakeWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>VM 模式的沙箱，可以有效的解决子应用之间、主子应用之间各种副作用的有效隔离问题。<a href="https://qiankun.umijs.org/zh" target="_blank" rel="noopener noreferrer">qiankun<OutboundLink/></a> 的沙箱模式就是 VM 模式。</p>\n<h5 id="样式隔离" tabindex="-1"><a class="header-anchor" href="#样式隔离" aria-hidden="true">#</a> 样式隔离</h5>\n<p>虽然说，VM 模式的沙箱可以收集子应用运行过程中产生的样式，然后在子应用卸载的时候去除样式，但是考虑到子应用的 dom 结构最终还是要并入到主应用的 dom 树中去，VM 沙箱无法避免主应用的样式干扰到子应用的样式的问题。</p>\n<p>这时候，我们就需要借助于一些其他手段，比如在主子应用中都使用 <a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener noreferrer">css modules<OutboundLink/></a> 来减少样式冲突。</p>\n<h4 id="shadow-dom" tabindex="-1"><a class="header-anchor" href="#shadow-dom" aria-hidden="true">#</a> Shadow Dom</h4>\n<p>如果不考虑兼容性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM" target="_blank" rel="noopener noreferrer">Shadow Dom<OutboundLink/></a> 是子应用样式隔离的一个绝佳选择。</p>\n<p>我们把子应用放到 Shadow Dom 中，可以原生实现子应用间的样式隔离。但是 Shadow Dom 本身也有诸多限制，很多依赖库还不支持 Shadow Dom。比如埋点检测，事件处理等。</p>\n<p>我们这里仅是将 Shadow Dom 作为补充技术方案来进行说明。</p>\n<blockquote>\n<p>qiankun 官方也将在<a href="https://github.com/umijs/qiankun/discussions/1378#discussioncomment-598734" target="_blank" rel="noopener noreferrer">未来的版本<OutboundLink/></a>中逐步弃用 Shadow Dom。</p>\n</blockquote>\n<h2 id="需要注意的问题" tabindex="-1"><a class="header-anchor" href="#需要注意的问题" aria-hidden="true">#</a> 需要注意的问题</h2>\n<p>技术领域有句话叫“没有永远的银弹”。本文开头我们介绍了使用微前端可以获得的很多收益，现在我们来讲讲微前端带来的问题。</p>\n<ul>\n<li>\n<p>整个产品的复杂度从代码转移到了基础设施\n我们需要有一套应用注册、管理的系统，并要和现有的应用发布流程对接。同时还要围绕微前端方案构建一整套的基础工具，比如开发调试工具，埋点监控系统等。</p>\n</li>\n<li>\n<p>增加了学习和理解成本\n子应用或多或少要了解一些微前端方案的技术原理，才能带来更好的开发和产品体验。</p>\n</li>\n</ul>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-11-21",deps:[],hoistedTags:[],links:[],pathInferred:"/solutions/micro-frontend/microfrontend.html",pathLocale:"/",permalink:null,slug:"microfrontend",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/micro-frontend/microfrontend.md",filePathRelative:"solutions/micro-frontend/microfrontend.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/micro-frontend/microfrontend.html.vue",componentFilePathRelative:"pages/solutions/micro-frontend/microfrontend.html.vue",componentFileChunkName:"v-70766a09",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/micro-frontend/microfrontend.html.js",dataFilePathRelative:"pages/solutions/micro-frontend/microfrontend.html.js",dataFileChunkName:"v-70766a09",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/micro-frontend/microfrontend.html",htmlFilePathRelative:"solutions/micro-frontend/microfrontend.html"},{key:"v-4b841320",path:"/solutions/micro-frontend/qiankun.html",title:"qiankun 技术分析",lang:"zh-CN",frontmatter:{title:"qiankun 技术分析",description:"对阿里的微前端框架 qiankun 进行技术分析，了解技术原理。",keywords:["micro frontend","微前端","qiankun"],date:"2021-12-15T00:00:00.000Z",key:3,tags:["技术分析"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"如何加载子应用",slug:"如何加载子应用",children:[{level:3,title:"import-html-entry",slug:"import-html-entry",children:[]},{level:3,title:"loadApp",slug:"loadapp",children:[]}]},{level:2,title:"隔离",slug:"隔离",children:[{level:3,title:"JS 隔离",slug:"js-隔离",children:[]},{level:3,title:"样式隔离",slug:"样式隔离",children:[]}]},{level:2,title:"小结",slug:"小结",children:[]}],content:'\n我们在[single-spa 技术分析](./single-spa.md)里面讲到，[single-spa](https://single-spa.js.org/) 基本实现了一个微前端框架需要具备的各种功能，但是又实现的不够彻底，遗留了很多问题需要解决。虽然官方提供了很多样例和最佳实践，但是总显得过于单薄，总给人一种“问题解决了，但是又没有完全解决”的感觉。  \n\n[qiankun](https://qiankun.umijs.org/zh) 在 single-spa 的基础上做了二次开发，完善了很多功能，算是一个比较完备的微前端框架了。今天我们来聊一聊 qiankun 的技术原理。  \n\n在本系列的开头，我们提到微前端的核心问题其实就是解决如何加载子应用以及如果做好子应用间的隔离问题。所以，我们从这两点来看 qiankun 的实现。  \n\n## 如何加载子应用\n\nsingle-spa 通过 js entry 的形式来加载子应用。而 qiankun 采用了 html entry 的形式。这两种方式的优缺点我们在[理解微前端技术原理](./microfrontend.md)中已经做过分析，这里不再赘述，我们看看 qiankun 是如何实现 html entry 的。\n\nqiankun 提供了一个 API `registerMicroApps` 来注册子应用，其内部调用 single-spa 提供的 `registerApplication` 方法。在调用 `registerApplication` 之前，会调用内部的 `loadApp` 方法来加载子应用的资源，初始化子应用的配置。  \n\n通过阅读 `loadApp` 的代码，我们发现，qiankun 通过 [import-html-entry](https://npmjs.org/package/import-html-entry) 这个包来加载子应用。import-html-entry 的作用就是通过解析子应用的入口 html 文件，来获取子应用的 html 模板、css 样式和入口 JS 导出的生命周期函数。  \n\n### import-html-entry\n\n`import-html-entry` 是这样工作的，假设我们有如下 html entry 文件:  \n\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>test</title>\n</head>\n<body>\n\n\x3c!-- mark the entry script with entry attribute --\x3e\n<script src="https://unpkg.com/mobx@5.0.3/lib/mobx.umd.js" entry><\/script>\n<script src="https://unpkg.com/react@16.4.2/umd/react.production.min.js"><\/script>\n</body>\n</html>\n```\n\n我们使用 `import-html-entry` 来解析这个 html 文件：  \n\n```js\nimport importHTML from \'import-html-entry\';\n\nimportHTML(\'./subApp/index.html\')\n    .then(res => {\n        console.log(res.template);\n\n        res.execScripts().then(exports => {\n            const mobx = exports;\n            const { observable } = mobx;\n            observable({\n                name: \'kuitos\'\n            })\t\n        })\n});\n```\n\n`importHTML` 的返回值有如下几个属性：\n\n* template  处理后的 HTML 模板\n* assetPublicPath  静态资源的公共路径\n* getExternalScripts 获取所有外部脚本的函数，返回脚本路径\n* getExternalStyleSheets 获取所有外部样式的函数，返回样式文件的路径\n* execScripts 执行脚本的函数\n\n在 `importHTML` 的返回值中，除了几个工具类的方法，最重要的就是 `template` 和 `execScripts` 了。\n\n`importHTML(\'./subApp/index.html\')` 的整个执行过程代码比较长，我们只讲一下大概的执行原理，感兴趣的同学可以自行查看[importHTML 的源码](https://github.com/kuitos/import-html-entry/blob/master/src/index.js#L239)。  \n\n`importHTML` 首先会通过 `fetch` 函数请求具体的 html 内容，然后在 [`processTpl` 函数](https://github.com/kuitos/import-html-entry/blob/master/src/process-tpl.js#L58) 中通过一系列复杂的正则匹配，解析出 html 中的样式文件和 js 文件。  \n\n`importHTML` 函数返回值为 `{ template, scripts, entry, styles }`，分别是 html 模板，html 中的 js 文件（包含内嵌的代码和通过链接加载的代码），子应用的入口文件，html 中的样式文件（同样是包含内嵌的代码和通过链接加载的代码）。  \n\n之后通过 [`getEmbedHTML` 函数](https://github.com/kuitos/import-html-entry/blob/master/src/index.js#L38) 将所有使用外部链接加载的样式全部转化成内嵌到 html 中的样式。`getEmbedHTML` 返回的 html 就是 `importHTML` 函数最终返回的 `template` 内容。\n\n现在，我们看看 `execScripts` 是怎么实现的。\n\n`execScripts` 内部会调用 `getExternalScripts` 加载所有 js 代码的文本内容，然后通过 `eval("code")` 的形式执行加载的代码。\n\n注意，`execScripts` 的函数签名是这样的 `(sandbox?: object, strictGlobal?: boolean, execScriptsHooks?: ExecScriptsHooks): Promise<unknown>`。允许我们传入一个沙箱对象，如果子应用按照微前端的规范打包，那么会在全局对象上设置 `mount`、`unmount` 这几个生命周期函数属性。`execScripts` 在执行 `eval("code")` 的时候，会巧妙的把我们指定的沙箱最为全局对象包装到 `"code"` 中，子应用能够运行在沙盒环境中。  \n\n在执行完 `eval("code")` 以后，就可以从沙盒对象上获取子应用导出的生命周期函数了。  \n\n### loadApp  \n\n现在我们把视线拉回 `loadApp` 中，`loadApp` 在获取到 `template`、`execScripts` 这些信息以后，会基于 `template` 生成 [`render` 函数](https://github.com/umijs/qiankun/blob/master/src/loader.ts#L296)用于渲染子应用的页面。之后会根据需要生成沙盒，并将沙盒对象传给 `execScripts` 来获取子应用导出的声明周期函数。  \n\n之后，在子应用生命周期函数的基础上，构建新的生命周期函数，再调用 single-spa 的 API 启动子应用。  \n\n在这些新的生命周期函数中，会在不同时机负责启动沙盒、渲染子应用、清理沙盒等事务。  \n\n## 隔离\n\n在完成子应用的加载以后，作为一个微前端框架，要解决好子应用的隔离问题，主要要解决 JS 隔离和样式隔离这两方面的问题。  \n\n### JS 隔离\n\nqiankun 为根据浏览器的能力创建两种沙箱，在老旧浏览器中会创建[快照模式](./microfrontend.md#快照模式)的沙箱 `SnapshotSandbox`，在支持 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 的浏览器中创建 [VM 模式](./microfrontend.md#vm-虚拟机-模式)的沙箱 `ProxySandbox`。  \n\n篇幅限制，我们只看 `ProxySandbox` 的实现，在其构造函数中，我们可以看到具体的逻辑：首先会根据用户指定的全局对象（默认是 window）创建一个 `fakeWindow`，之后在这个 `fakeWindow` 上创建一个 proxy 对象，在子应用中，这个 proxy 对象就是全局变量 `window`。 \n\n```ts\nconstructor(name: string, globalContext = window) {\n  const { fakeWindow, propertiesWithGetter } = createFakeWindow(globalContext);\n  const proxy = new Proxy(fakeWindow, {\n      set: (target: FakeWindow, p: PropertyKey, value: any): boolean => {},\n      get: (target: FakeWindow, p: PropertyKey): any => {},\n      has(target: FakeWindow, p: string | number | symbol): boolean {},\n\n      getOwnPropertyDescriptor(target: FakeWindow, p: string | number | symbol): PropertyDescriptor | undefined {},\n\n      ownKeys(target: FakeWindow): ArrayLike<string | symbol> {},\n\n      defineProperty(target: Window, p: PropertyKey, attributes: PropertyDescriptor): boolean {},\n\n      deleteProperty: (target: FakeWindow, p: string | number | symbol): boolean => {},\n\n      getPrototypeOf() {\n        return Reflect.getPrototypeOf(globalContext);\n      },\n    });\n  this.proxy = proxy;\n}\n```\n\n其实 qiankun 中的沙箱分两个类型：\n\n* app 环境沙箱\n  app 环境沙箱是指应用初始化过之后，应用会在什么样的上下文环境运行。每个应用的环境沙箱只会初始化一次，因为子应用只会触发一次 `bootstrap` 。子应用在切换时，实际上切换的是 app 环境沙箱。\n* render 沙箱\n  子应用在 app mount 开始前生成好的的沙箱。每次子应用切换过后，render 沙箱都会重现初始化。\n\n上面说的 `ProxySandbox` 其实是 render 沙箱。至于 app 环境沙箱，qiankun 目前只针对在应用 `bootstrap` 时动态创建样式链接、脚本链接等副作用打了补丁，保证子应用切换时这些副作用互不干扰。\n\n之所以设计两层沙箱，是为了保证每个子应用切换回来之后，还能运行在应用 bootstrap 之后的环境下。\n\n### 样式隔离\n\nqiankun 提供了多种样式隔离方式，隔离效果最好的是 shadow dom，但是由于其存在诸多限制，qiankun 官方在将来的版本中将会弃用，转而推行 `experimentalStyleIsolation` 方案。  \n\n我们可以通过下面这段代码看到 `experimentalStyleIsolation` 方案的基本原理。\n\n```ts\nconst styleNodes = appElement.querySelectorAll(\'style\') || [];\nforEach(styleNodes, (stylesheetElement: HTMLStyleElement) => {\n  css.process(appElement!, stylesheetElement, appInstanceId);\n});\n```\n\n`css.process` 的核心逻辑，就是给读取到的子应用的样式添加带有子应用信息的前缀。效果如下：\n\n```css\n/* 假设应用名是 react16 */ \n.app-main {\n  font-size: 14px;\n}\n\ndiv[data-qiankun-react16] .app-main {\n  font-size: 14px;\n}\n```\n\n通过上面的隔离方法，基本可以保证子应用间的样式互不影响。  \n\n## 小结  \n\nqiankun 在 single-spa 的基础上根据实际的生产实践开发了很多有用的功能，大大降低了微前端的使用成本。  \n\n本文仅仅针对如何加载子应用和如何做好子应用间的隔离这两个问题，介绍了 qiankun 的实现。其实，在隔离这个问题上，qiankun 也仅仅是根据实际中会遇到的情况做了必要的隔离措施，并没有像 iframe 那样实现完全的隔离。我们可以说 qiankun 实现的隔离有缺陷，也可以说是 qiankun 在实际的业务需求和完全隔离的实现成本之间做的取舍。  \n\n',contentRendered:'<p>我们在<RouterLink to="/solutions/micro-frontend/single-spa.html">single-spa 技术分析</RouterLink>里面讲到，<a href="https://single-spa.js.org/" target="_blank" rel="noopener noreferrer">single-spa<OutboundLink/></a> 基本实现了一个微前端框架需要具备的各种功能，但是又实现的不够彻底，遗留了很多问题需要解决。虽然官方提供了很多样例和最佳实践，但是总显得过于单薄，总给人一种“问题解决了，但是又没有完全解决”的感觉。</p>\n<p><a href="https://qiankun.umijs.org/zh" target="_blank" rel="noopener noreferrer">qiankun<OutboundLink/></a> 在 single-spa 的基础上做了二次开发，完善了很多功能，算是一个比较完备的微前端框架了。今天我们来聊一聊 qiankun 的技术原理。</p>\n<p>在本系列的开头，我们提到微前端的核心问题其实就是解决如何加载子应用以及如果做好子应用间的隔离问题。所以，我们从这两点来看 qiankun 的实现。</p>\n<h2 id="如何加载子应用" tabindex="-1"><a class="header-anchor" href="#如何加载子应用" aria-hidden="true">#</a> 如何加载子应用</h2>\n<p>single-spa 通过 js entry 的形式来加载子应用。而 qiankun 采用了 html entry 的形式。这两种方式的优缺点我们在<RouterLink to="/solutions/micro-frontend/microfrontend.html">理解微前端技术原理</RouterLink>中已经做过分析，这里不再赘述，我们看看 qiankun 是如何实现 html entry 的。</p>\n<p>qiankun 提供了一个 API <code>registerMicroApps</code> 来注册子应用，其内部调用 single-spa 提供的 <code>registerApplication</code> 方法。在调用 <code>registerApplication</code> 之前，会调用内部的 <code>loadApp</code> 方法来加载子应用的资源，初始化子应用的配置。</p>\n<p>通过阅读 <code>loadApp</code> 的代码，我们发现，qiankun 通过 <a href="https://npmjs.org/package/import-html-entry" target="_blank" rel="noopener noreferrer">import-html-entry<OutboundLink/></a> 这个包来加载子应用。import-html-entry 的作用就是通过解析子应用的入口 html 文件，来获取子应用的 html 模板、css 样式和入口 JS 导出的生命周期函数。</p>\n<h3 id="import-html-entry" tabindex="-1"><a class="header-anchor" href="#import-html-entry" aria-hidden="true">#</a> import-html-entry</h3>\n<p><code>import-html-entry</code> 是这样工作的，假设我们有如下 html entry 文件:</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n\n<span class="token comment">&lt;!-- mark the entry script with entry attribute --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/mobx@5.0.3/lib/mobx.umd.js<span class="token punctuation">"</span></span> <span class="token attr-name">entry</span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react@16.4.2/umd/react.production.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>我们使用 <code>import-html-entry</code> 来解析这个 html 文件：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> importHTML <span class="token keyword">from</span> <span class="token string">\'import-html-entry\'</span><span class="token punctuation">;</span>\n\n<span class="token function">importHTML</span><span class="token punctuation">(</span><span class="token string">\'./subApp/index.html\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>template<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        res<span class="token punctuation">.</span><span class="token function">execScripts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">exports</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n            <span class="token keyword">const</span> mobx <span class="token operator">=</span> exports<span class="token punctuation">;</span>\n            <span class="token keyword">const</span> <span class="token punctuation">{</span> observable <span class="token punctuation">}</span> <span class="token operator">=</span> mobx<span class="token punctuation">;</span>\n            <span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n                name<span class="token operator">:</span> <span class="token string">\'kuitos\'</span>\n            <span class="token punctuation">}</span><span class="token punctuation">)</span>\t\n        <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><code>importHTML</code> 的返回值有如下几个属性：</p>\n<ul>\n<li>template  处理后的 HTML 模板</li>\n<li>assetPublicPath  静态资源的公共路径</li>\n<li>getExternalScripts 获取所有外部脚本的函数，返回脚本路径</li>\n<li>getExternalStyleSheets 获取所有外部样式的函数，返回样式文件的路径</li>\n<li>execScripts 执行脚本的函数</li>\n</ul>\n<p>在 <code>importHTML</code> 的返回值中，除了几个工具类的方法，最重要的就是 <code>template</code> 和 <code>execScripts</code> 了。</p>\n<p><code>importHTML(\'./subApp/index.html\')</code> 的整个执行过程代码比较长，我们只讲一下大概的执行原理，感兴趣的同学可以自行查看<a href="https://github.com/kuitos/import-html-entry/blob/master/src/index.js#L239" target="_blank" rel="noopener noreferrer">importHTML 的源码<OutboundLink/></a>。</p>\n<p><code>importHTML</code> 首先会通过 <code>fetch</code> 函数请求具体的 html 内容，然后在 <a href="https://github.com/kuitos/import-html-entry/blob/master/src/process-tpl.js#L58" target="_blank" rel="noopener noreferrer"><code>processTpl</code> 函数<OutboundLink/></a> 中通过一系列复杂的正则匹配，解析出 html 中的样式文件和 js 文件。</p>\n<p><code>importHTML</code> 函数返回值为 <code>{ template, scripts, entry, styles }</code>，分别是 html 模板，html 中的 js 文件（包含内嵌的代码和通过链接加载的代码），子应用的入口文件，html 中的样式文件（同样是包含内嵌的代码和通过链接加载的代码）。</p>\n<p>之后通过 <a href="https://github.com/kuitos/import-html-entry/blob/master/src/index.js#L38" target="_blank" rel="noopener noreferrer"><code>getEmbedHTML</code> 函数<OutboundLink/></a> 将所有使用外部链接加载的样式全部转化成内嵌到 html 中的样式。<code>getEmbedHTML</code> 返回的 html 就是 <code>importHTML</code> 函数最终返回的 <code>template</code> 内容。</p>\n<p>现在，我们看看 <code>execScripts</code> 是怎么实现的。</p>\n<p><code>execScripts</code> 内部会调用 <code>getExternalScripts</code> 加载所有 js 代码的文本内容，然后通过 <code>eval(&quot;code&quot;)</code> 的形式执行加载的代码。</p>\n<p>注意，<code>execScripts</code> 的函数签名是这样的 <code>(sandbox?: object, strictGlobal?: boolean, execScriptsHooks?: ExecScriptsHooks): Promise&lt;unknown&gt;</code>。允许我们传入一个沙箱对象，如果子应用按照微前端的规范打包，那么会在全局对象上设置 <code>mount</code>、<code>unmount</code> 这几个生命周期函数属性。<code>execScripts</code> 在执行 <code>eval(&quot;code&quot;)</code> 的时候，会巧妙的把我们指定的沙箱最为全局对象包装到 <code>&quot;code&quot;</code> 中，子应用能够运行在沙盒环境中。</p>\n<p>在执行完 <code>eval(&quot;code&quot;)</code> 以后，就可以从沙盒对象上获取子应用导出的生命周期函数了。</p>\n<h3 id="loadapp" tabindex="-1"><a class="header-anchor" href="#loadapp" aria-hidden="true">#</a> loadApp</h3>\n<p>现在我们把视线拉回 <code>loadApp</code> 中，<code>loadApp</code> 在获取到 <code>template</code>、<code>execScripts</code> 这些信息以后，会基于 <code>template</code> 生成 <a href="https://github.com/umijs/qiankun/blob/master/src/loader.ts#L296" target="_blank" rel="noopener noreferrer"><code>render</code> 函数<OutboundLink/></a>用于渲染子应用的页面。之后会根据需要生成沙盒，并将沙盒对象传给 <code>execScripts</code> 来获取子应用导出的声明周期函数。</p>\n<p>之后，在子应用生命周期函数的基础上，构建新的生命周期函数，再调用 single-spa 的 API 启动子应用。</p>\n<p>在这些新的生命周期函数中，会在不同时机负责启动沙盒、渲染子应用、清理沙盒等事务。</p>\n<h2 id="隔离" tabindex="-1"><a class="header-anchor" href="#隔离" aria-hidden="true">#</a> 隔离</h2>\n<p>在完成子应用的加载以后，作为一个微前端框架，要解决好子应用的隔离问题，主要要解决 JS 隔离和样式隔离这两方面的问题。</p>\n<h3 id="js-隔离" tabindex="-1"><a class="header-anchor" href="#js-隔离" aria-hidden="true">#</a> JS 隔离</h3>\n<p>qiankun 为根据浏览器的能力创建两种沙箱，在老旧浏览器中会创建<RouterLink to="/solutions/micro-frontend/microfrontend.html#%E5%BF%AB%E7%85%A7%E6%A8%A1%E5%BC%8F">快照模式</RouterLink>的沙箱 <code>SnapshotSandbox</code>，在支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy<OutboundLink/></a> 的浏览器中创建 <RouterLink to="/solutions/micro-frontend/microfrontend.html#vm-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E6%A8%A1%E5%BC%8F">VM 模式</RouterLink>的沙箱 <code>ProxySandbox</code>。</p>\n<p>篇幅限制，我们只看 <code>ProxySandbox</code> 的实现，在其构造函数中，我们可以看到具体的逻辑：首先会根据用户指定的全局对象（默认是 window）创建一个 <code>fakeWindow</code>，之后在这个 <code>fakeWindow</code> 上创建一个 proxy 对象，在子应用中，这个 proxy 对象就是全局变量 <code>window</code>。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> globalContext <span class="token operator">=</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span> fakeWindow<span class="token punctuation">,</span> propertiesWithGetter <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createFakeWindow</span><span class="token punctuation">(</span>globalContext<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>fakeWindow<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      set<span class="token operator">:</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> FakeWindow<span class="token punctuation">,</span> p<span class="token operator">:</span> PropertyKey<span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n      get<span class="token operator">:</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> FakeWindow<span class="token punctuation">,</span> p<span class="token operator">:</span> PropertyKey<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token function">has</span><span class="token punctuation">(</span>target<span class="token operator">:</span> FakeWindow<span class="token punctuation">,</span> p<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n      <span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>target<span class="token operator">:</span> FakeWindow<span class="token punctuation">,</span> p<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">)</span><span class="token operator">:</span> PropertyDescriptor <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n      <span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token operator">:</span> FakeWindow<span class="token punctuation">)</span><span class="token operator">:</span> ArrayLike<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n      <span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token operator">:</span> Window<span class="token punctuation">,</span> p<span class="token operator">:</span> PropertyKey<span class="token punctuation">,</span> attributes<span class="token operator">:</span> PropertyDescriptor<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n      deleteProperty<span class="token operator">:</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> FakeWindow<span class="token punctuation">,</span> p<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n      <span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>globalContext<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>proxy <span class="token operator">=</span> proxy<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>其实 qiankun 中的沙箱分两个类型：</p>\n<ul>\n<li>app 环境沙箱\napp 环境沙箱是指应用初始化过之后，应用会在什么样的上下文环境运行。每个应用的环境沙箱只会初始化一次，因为子应用只会触发一次 <code>bootstrap</code> 。子应用在切换时，实际上切换的是 app 环境沙箱。</li>\n<li>render 沙箱\n子应用在 app mount 开始前生成好的的沙箱。每次子应用切换过后，render 沙箱都会重现初始化。</li>\n</ul>\n<p>上面说的 <code>ProxySandbox</code> 其实是 render 沙箱。至于 app 环境沙箱，qiankun 目前只针对在应用 <code>bootstrap</code> 时动态创建样式链接、脚本链接等副作用打了补丁，保证子应用切换时这些副作用互不干扰。</p>\n<p>之所以设计两层沙箱，是为了保证每个子应用切换回来之后，还能运行在应用 bootstrap 之后的环境下。</p>\n<h3 id="样式隔离" tabindex="-1"><a class="header-anchor" href="#样式隔离" aria-hidden="true">#</a> 样式隔离</h3>\n<p>qiankun 提供了多种样式隔离方式，隔离效果最好的是 shadow dom，但是由于其存在诸多限制，qiankun 官方在将来的版本中将会弃用，转而推行 <code>experimentalStyleIsolation</code> 方案。</p>\n<p>我们可以通过下面这段代码看到 <code>experimentalStyleIsolation</code> 方案的基本原理。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">const</span> styleNodes <span class="token operator">=</span> appElement<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">\'style\'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token function">forEach</span><span class="token punctuation">(</span>styleNodes<span class="token punctuation">,</span> <span class="token punctuation">(</span>stylesheetElement<span class="token operator">:</span> HTMLStyleElement<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  css<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>appElement<span class="token operator">!</span><span class="token punctuation">,</span> stylesheetElement<span class="token punctuation">,</span> appInstanceId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>css.process</code> 的核心逻辑，就是给读取到的子应用的样式添加带有子应用信息的前缀。效果如下：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token comment">/* 假设应用名是 react16 */</span> \n<span class="token selector">.app-main</span> <span class="token punctuation">{</span>\n  <span class="token property">font-size</span><span class="token punctuation">:</span> 14px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">div[data-qiankun-react16] .app-main</span> <span class="token punctuation">{</span>\n  <span class="token property">font-size</span><span class="token punctuation">:</span> 14px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>通过上面的隔离方法，基本可以保证子应用间的样式互不影响。</p>\n<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>qiankun 在 single-spa 的基础上根据实际的生产实践开发了很多有用的功能，大大降低了微前端的使用成本。</p>\n<p>本文仅仅针对如何加载子应用和如何做好子应用间的隔离这两个问题，介绍了 qiankun 的实现。其实，在隔离这个问题上，qiankun 也仅仅是根据实际中会遇到的情况做了必要的隔离措施，并没有像 iframe 那样实现完全的隔离。我们可以说 qiankun 实现的隔离有缺陷，也可以说是 qiankun 在实际的业务需求和完全隔离的实现成本之间做的取舍。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-12-15",deps:[],hoistedTags:[],links:[{raw:"./single-spa.md",relative:"solutions/micro-frontend/single-spa.md",absolute:"/solutions/micro-frontend/single-spa.md"},{raw:"./microfrontend.md",relative:"solutions/micro-frontend/microfrontend.md",absolute:"/solutions/micro-frontend/microfrontend.md"},{raw:"./microfrontend.md#%E5%BF%AB%E7%85%A7%E6%A8%A1%E5%BC%8F",relative:"solutions/micro-frontend/microfrontend.md",absolute:"/solutions/micro-frontend/microfrontend.md"},{raw:"./microfrontend.md#vm-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E6%A8%A1%E5%BC%8F",relative:"solutions/micro-frontend/microfrontend.md",absolute:"/solutions/micro-frontend/microfrontend.md"}],pathInferred:"/solutions/micro-frontend/qiankun.html",pathLocale:"/",permalink:null,slug:"qiankun",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/micro-frontend/qiankun.md",filePathRelative:"solutions/micro-frontend/qiankun.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/micro-frontend/qiankun.html.vue",componentFilePathRelative:"pages/solutions/micro-frontend/qiankun.html.vue",componentFileChunkName:"v-4b841320",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/micro-frontend/qiankun.html.js",dataFilePathRelative:"pages/solutions/micro-frontend/qiankun.html.js",dataFileChunkName:"v-4b841320",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/micro-frontend/qiankun.html",htmlFilePathRelative:"solutions/micro-frontend/qiankun.html"},{key:"v-b1c699d8",path:"/solutions/micro-frontend/single-spa.html",title:"single-spa 技术分析",lang:"zh-CN",frontmatter:{title:"single-spa 技术分析",description:"对目前主流的 single-spa 框架进行技术分析，了解技术原理。",keywords:["micro frontend","微前端","single spa"],date:"2021-12-01T00:00:00.000Z",key:2,tags:["技术分析"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"核心能力",slug:"核心能力",children:[{level:3,title:"主应用的配置信息",slug:"主应用的配置信息",children:[]},{level:3,title:"子应用的生命周期函数",slug:"子应用的生命周期函数",children:[]}]},{level:2,title:"其他概念",slug:"其他概念",children:[{level:3,title:"子应用的分类",slug:"子应用的分类",children:[]},{level:3,title:"Layout Engine",slug:"layout-engine",children:[]},{level:3,title:"关于 SystemJS",slug:"关于-systemjs",children:[]}]},{level:2,title:"隔离",slug:"隔离",children:[{level:3,title:"样式隔离",slug:"样式隔离",children:[]},{level:3,title:"JS 隔离",slug:"js-隔离",children:[]}]},{level:2,title:"小结",slug:"小结",children:[]}],content:'\n在[理解微前端技术原理](./microfrontend.md)中我们介绍了微前端的概念和核心技术原理。本篇我们结合目前业内主流的微前端实现 [single-spa](https://single-spa.js.org/) 来说明在生产实践中是如何实现微前端的。\n\nsingle-spa 的文档略显凌乱，概念也比较多，初次接触它的同学容易抓不住重点。今天我们尝试整理出一条清晰的脉络，让感兴趣的同学能够快速理解它。\n\n在 single-spa 的架构设计中，有两种主要角色，主应用和子应用，如下图。\n\n```plantuml\nnode 主应用\nnode 子应用A\nnode 子应用B\nnode 子应用C\n\n主应用 --\x3e 子应用A\n主应用 --\x3e 子应用B\n主应用 --\x3e 子应用C\n```\n\n主应用力求足够简单，只负责子应用的调度，业务逻辑都由子应用来承担。\n\n## 核心能力\n\n其实总结来说，single-spa 的核心就是定义了一套协议。通过这套协议，主应用可以方便的知道在什么情况下激活哪个子应用。而这套协议主要包含两个部分：主应用的**配置信息**和子应用的**生命周期函数**。\n\n### 主应用的配置信息\n在 single-spa 中，这个配置信息叫 [Root Config](https://single-spa.js.org/docs/configuration)。\n\n下面的样例展示了配置信息的结构：\n\n```js\n{\n  name: "subApp1",\n  app: () => System.import("/path/to/subApp1/code"),\n  activeWhen: "/subApp1",\n}\n```\n\n`name` 就是子应用的名称，`app` 函数告诉主应用如何加载子应用的代码，`activeWhen` 告诉主应用何时激活子应用，也可以为一个返回布尔值的函数。\n\n通过 [`registerApplication`](https://single-spa.js.org/docs/api#registerapplication) 将子应用的信息注册到主应用中。\n\n样例如下：\n\n```js\nsingleSpa.registerApplication({\n    name: \'appName\',\n    app: () => System.import(\'appName\'),\n    activeWhen: \'/appName\',\n    customProps: {\n        authToken: \'xc67f6as87f7s9d\'\n    }\n})\n```\n\n### 子应用的生命周期函数\n主应用在管理子应用的时候，通过子应用暴露的生命周期函数来实现子应用的启动和卸载。\n\n主要有如下几个生命周期函数。\n\n* bootstrap\n\n  这个生命周期函数会在应用第一次挂载前执行一次。就是说在子应用的代码加载完成以后，页面渲染之前执行。函数形式如下：\n\n  ```js\n  export function bootstrap(props) {\n    return Promise\n      .resolve()\n      .then(() => {\n        // 可以在这里部署只执行一次的初始化代码\n        console.log(\'bootstrapped!\')\n      });\n  }\n  ```\n\n* mount\n\n  当主应用判定需要激活这个子应用时会调用这个生命周期函数。在这个函数中实现子应用的挂载、页面渲染等逻辑。这个函数也只会执行一次。我们可以简单的理解为 `ReactDOM.render` 操作。函数形式如下：\n\n  ```js\n  export function mount(props) {\n    return Promise.resolve().then(() => {\n      // 页面渲染逻辑\n      console.log(\'mounted!\');\n    });\n  }\n  ```\n\n* unmount\n\n  当主应用判定需要卸载这个子应用时会调用这个生命周期函数。在这个函数中实现组件卸载、清理事件监听等逻辑。我们可以简单的理解为 `ReactDOM.unmountComponentAtNode` 操作。函数形式如下：\n\n  ```js\n  export function unmount(props) {\n    return Promise.resolve().then(() => {\n      // 页面卸载逻辑\n      console.log(\'unmounted!\');\n    });\n  }\n  ```\n\n> 观察每个生命周期函数的签名我们可以发现，每个函数都有一个 `props` 参数，主应用可以通过这个参数向子应用传递一些额外信息，后面会做说明。\n\n> 为了方便各种技术栈的子应用能方便的接入，single-spa 提供了很多工具，可以在这里查到[官方维护的工具列表](https://single-spa.js.org/docs/ecosystem#help-for-frameworks)。\n\n## 其他概念\n\n### 子应用的分类\n\nsingle-spa 根据职能的不同，把子应用划分成三类：\n\n* [Application](https://single-spa.js.org/docs/module-types#applications)\n  表示普通的子应用，需要实现上面提到的生命周期函数；\n* [Parcel](https://single-spa.js.org/docs/module-types#parcels)\n  可以理解为可以跨子应用复用的业务单元，需要实现[与之对应的生命周期函数](https://single-spa.js.org/docs/parcels-api)；\n* [Utility](https://single-spa.js.org/docs/module-types#utilities)\n  表示一段可复用的逻辑，比如一个函数等，不做页面渲染。\n\n不难看出，Parcel 和 Utility 都是为了共享和复用，也算是 single-spa 在框架层面给出的一种复用方案。\n\n### Layout Engine\n\n虽然 single-spa 的理念是让主应用尽可能的简单，但是在实践中，主应用通常会负责通用的顶部、底部通栏的渲染。这个时候，如何确定子应用的渲染位置就成了一个问题。\n\nsingle-spa 提供了 [Layout Engine](https://single-spa.js.org/docs/layout-overview)的方案。样例代码如下，与 Vue 颇为相似，详细的可以查看文档，这里不做过多叙述。\n\n```html\n<html>\n  <head>\n    <template id="single-spa-layout">\n      <single-spa-router>\n        <nav class="topnav">\n          <application name="@organization/nav"></application>\n        </nav>\n        <div class="main-content">\n          <route path="settings">\n            <application name="@organization/settings"></application>\n          </route>\n          <route path="clients">\n            <application name="@organization/clients"></application>\n          </route>\n        </div>\n        <footer>\n          <application name="@organization/footer"></application>\n        </footer>\n      </single-spa-router>\n    </template>\n  </head>\n</html>\n```\n### 关于 SystemJS\n\n很多人在提到 single-spa 的时候都会提到 [SystemJS](https://github.com/systemjs/systemjs)，认为 SystemJS 是 single-spa 的核心之一。其实这是一个误区， SystemJS 并不是 single-spa 所必须的。\n\n前面说到，子应用要实现生命周期函数，然后导出给主应用使用。关键就是这个“导出”的实现，这就涉及到 [JavaScript 的模块化](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)问题。\n\n在一些现代浏览器中，我们可以通过在 `<script>` 标签上添加 `type="module"` 来实现导入导出。\n\n```html\n<script type="module" src="module.js"><\/script>\n<script type="module">\n  // or an inline script\n  import {helperMethod} from \'./providesHelperMethod.js\';\n  helperMethod();\n<\/script>\n\n// providesHelperMethod.js\nexport function helperMethod() {\n  console.info(`I\'m helping!`);\n}\n```\n\n但是如果我们想要实现 `import axios from \'axios\'` 还需要借助于 [`importmap`](https://github.com/WICG/import-maps)。\n\n```html\n<script type="importmap">\n    {\n       "imports": {\n          "axios": "https://cdn.jsdelivr.net/npm/axios@0.20.0/dist/axios.min.js"\n       }\n    }\n<\/script>\n<script type="module">\n  import axios from \'axios\'\n<\/script>\n```\n\n在低版本浏览器中，我们就需要借助于一些 “Polyfill” 来实现模块化了。SystemJS 就是解决这个问题的。所以 single-spa 的样例中大量采用了 SystemJS 来加载应用。\n\n其实也可以不用 SystemJS，webpack 也可以实现类似的能力，但是会加深主应用与子应用间的工程耦合。\n\n## 隔离\n\n在[理解微前端技术原理](./microfrontend.md)中，我们花了很长的篇幅来说明子应用隔离的思路。那么，single-spa 中是如何来实现隔离的呢？\n\n### 样式隔离\n\nsingle-spa 中的样式隔离可以分为两块来说。\n\n首先是子应用样式的加载和卸载。single-spa 提供了 [single-spa-css](https://single-spa.js.org/docs/ecosystem-css#single-spa-css) 这个工具来实现。\n\n```js\nimport singleSpaCss from \'single-spa-css\';\n\nconst cssLifecycles = singleSpaCss({\n  // 需要加载的 css 列表\n  cssUrls: [\'https://example.com/main.css\'],\n\n  // 是否是 webpack 导出的 css，如果是要做额外处理（webpack 导出的文件名通常会有 hash）\n  webpackExtractedCss: false,\n\n  // 当子应用 unmount 的时候，css 是否需要一并删除\n  shouldUnmount: true,\n});\n\nconst reactLifecycles = singleSpaReact({...})\n\n// 加入到子应用的 bootstrap 里\nexport const bootstrap = [\n  cssLifecycles.bootstrap,\n  reactLifecycles.bootstrap\n]\n\nexport const mount = [\n  // 加入到子应用的 mount 里，css 放前面，不然 mount 后会有样式闪烁（FOUC）的问题\n  cssLifecycles.mount,\n  reactLifecycles.mount\n]\n\nexport const unmount = [\n  // 后卸载 css，防止样式闪烁\n  reactLifecycles.unmount,\n  cssLifecycles.unmount\n]\n```\n\n如果样式是 webpack 导出的，则每次构建后都要更新样式文件列表。single-spa 贴心的准备了一个插件来解决这个问题。只要在 webpack 的配置文件中添加如下插件即可。\n\n```js\nconst MiniCssExtractPlugin = require("mini-css-extract-plugin");\nconst ExposeRuntimeCssAssetsPlugin = require("single-spa-css/ExposeRuntimeCssAssetsPlugin.cjs");\n\nmodule.exports = {\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: "[name].css",\n    }),\n    new ExposeRuntimeCssAssetsPlugin({\n      // filename 必须与 MiniCssExtractPlugin 中的 filename 一一对应\n      filename: "[name].css",\n    }),\n  ],\n};\n```\n\n解决了子应用样式加载和卸载问题以后，我们再来看子应用样式隔离的问题。\n\nsingle-spa 给出了一些建议，比如使用 [Scoped CSS](https://single-spa.js.org/docs/ecosystem-css#scoped-css)，每个子应用都有一个固定前缀，类似于下面这样：\n\n```css\n/*\n<div class="app1__settings-67f89dd87sf89ds"></div>\n*/\n.app1__settings-67f89dd87sf89ds {\n  color: blue;\n}\n\n/*\n<div data-df65s76dfs class="settings"></div>\n*/\n.settings[data-df65s76dfs] {\n  color: blue;\n}\n\n/*\n<div id="single-spa-application:@org-name/project-name">\n    <div class="settings"></div>\n  </div>\n*/\n#single-spa-application\\:\\@org-name\\/project-name .settings {\n  color: blue;\n}\n```\n\n有很多工具可以实现 Scoped CSS，比如 [CSS Modules](https://github.com/css-modules/css-modules) 等。\n\n最后一种方式我们可以通过 webpack 自动化的实现。\n\n```js\nconst prefixer = require(\'postcss-prefix-selector\');\n\nmodule.exports = {\n  plugins: [\n    prefixer({\n      prefix: "#single-spa-application\\\\:\\\\@org-name\\\\/project-name"\n    })\n  ]\n}\n```\n\nsingle-spa 也提到了 Shadow DOM，我们在上一篇文章中已经分析过，这里不再赘述了。\n\n### JS 隔离\n\nsingle-spa 采用了类似于[快照模式](./microfrontend.md#快照模式)的隔离机制，通过 [single-spa-leaked-globals](https://single-spa.js.org/docs/ecosystem-leaked-globals) 来实现。\n\n用法如下：\n\n```js\nimport singleSpaLeakedGlobals from \'single-spa-leaked-globals\';\n\n// 其它 single-spa-xxx 提供的生命周期函数\nconst frameworkLifecycles = ...\n\n// 新添加的全局变量\nconst leakedGlobalsLifecycles = singleSpaLeakedGlobals({\n  globalVariableNames: [\'$\', \'jQuery\', \'_\'],\n})\n\nexport const bootstrap = [\n  leakedGlobalsLifecycles.bootstrap, // 放在第一位\n  frameworkLifecycles.bootstrap,\n]\n\nexport const mount = [\n  leakedGlobalsLifecycles.mount, // mount 时添加全局变量，如果之前有记录在案的，直接恢复\n  frameworkLifecycles.mount,\n]\n\nexport const unmount = [\n  leakedGlobalsLifecycles.unmount, // 删掉新添加的全局变量\n  frameworkLifecycles.unmount,\n]\n```\n\n> 前面已经说过，快照模式的一个缺点是无法保证多个子应用同时运行时的有效隔离。\n\n## 小结\n\n总体来说，single-spa 算是基本实现了一个微前端框架需要具备的各种功能，但是又实现的不够彻底，遗留了很多问题需要解决。虽然官方提供了很多样例和最佳实践，但是总显得过于单薄，总给人一种“问题解决了，但是又没有完全解决”的感觉。\n\nqiankun 基于 single-spa 开发，一定程度上解决了很多 single-spa 没有解决的问题。我们下篇详细说明。\n',contentRendered:'<p>在<RouterLink to="/solutions/micro-frontend/microfrontend.html">理解微前端技术原理</RouterLink>中我们介绍了微前端的概念和核心技术原理。本篇我们结合目前业内主流的微前端实现 <a href="https://single-spa.js.org/" target="_blank" rel="noopener noreferrer">single-spa<OutboundLink/></a> 来说明在生产实践中是如何实现微前端的。</p>\n<p>single-spa 的文档略显凌乱，概念也比较多，初次接触它的同学容易抓不住重点。今天我们尝试整理出一条清晰的脉络，让感兴趣的同学能够快速理解它。</p>\n<p>在 single-spa 的架构设计中，有两种主要角色，主应用和子应用，如下图。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuShBJqbLUB9ZzzDTKvvFMG7XFbqx0S9rHECxeV6TkRZWMXLqTUsGTUAGSC8buSpba9gN0dGI0000" alt="uml diagram">\n<p>主应用力求足够简单，只负责子应用的调度，业务逻辑都由子应用来承担。</p>\n<h2 id="核心能力" tabindex="-1"><a class="header-anchor" href="#核心能力" aria-hidden="true">#</a> 核心能力</h2>\n<p>其实总结来说，single-spa 的核心就是定义了一套协议。通过这套协议，主应用可以方便的知道在什么情况下激活哪个子应用。而这套协议主要包含两个部分：主应用的<strong>配置信息</strong>和子应用的<strong>生命周期函数</strong>。</p>\n<h3 id="主应用的配置信息" tabindex="-1"><a class="header-anchor" href="#主应用的配置信息" aria-hidden="true">#</a> 主应用的配置信息</h3>\n<p>在 single-spa 中，这个配置信息叫 <a href="https://single-spa.js.org/docs/configuration" target="_blank" rel="noopener noreferrer">Root Config<OutboundLink/></a>。</p>\n<p>下面的样例展示了配置信息的结构：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">"subApp1"</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">app</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> System<span class="token punctuation">.</span><span class="token function">import</span><span class="token punctuation">(</span><span class="token string">"/path/to/subApp1/code"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  activeWhen<span class="token operator">:</span> <span class="token string">"/subApp1"</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>name</code> 就是子应用的名称，<code>app</code> 函数告诉主应用如何加载子应用的代码，<code>activeWhen</code> 告诉主应用何时激活子应用，也可以为一个返回布尔值的函数。</p>\n<p>通过 <a href="https://single-spa.js.org/docs/api#registerapplication" target="_blank" rel="noopener noreferrer"><code>registerApplication</code><OutboundLink/></a> 将子应用的信息注册到主应用中。</p>\n<p>样例如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>singleSpa<span class="token punctuation">.</span><span class="token function">registerApplication</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">\'appName\'</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">app</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> System<span class="token punctuation">.</span><span class="token function">import</span><span class="token punctuation">(</span><span class="token string">\'appName\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    activeWhen<span class="token operator">:</span> <span class="token string">\'/appName\'</span><span class="token punctuation">,</span>\n    customProps<span class="token operator">:</span> <span class="token punctuation">{</span>\n        authToken<span class="token operator">:</span> <span class="token string">\'xc67f6as87f7s9d\'</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="子应用的生命周期函数" tabindex="-1"><a class="header-anchor" href="#子应用的生命周期函数" aria-hidden="true">#</a> 子应用的生命周期函数</h3>\n<p>主应用在管理子应用的时候，通过子应用暴露的生命周期函数来实现子应用的启动和卸载。</p>\n<p>主要有如下几个生命周期函数。</p>\n<ul>\n<li>\n<p>bootstrap</p>\n<p>这个生命周期函数会在应用第一次挂载前执行一次。就是说在子应用的代码加载完成以后，页面渲染之前执行。函数形式如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> Promise\n    <span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// 可以在这里部署只执行一次的初始化代码</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'bootstrapped!\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li>\n<li>\n<p>mount</p>\n<p>当主应用判定需要激活这个子应用时会调用这个生命周期函数。在这个函数中实现子应用的挂载、页面渲染等逻辑。这个函数也只会执行一次。我们可以简单的理解为 <code>ReactDOM.render</code> 操作。函数形式如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 页面渲染逻辑</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'mounted!\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li>\n<li>\n<p>unmount</p>\n<p>当主应用判定需要卸载这个子应用时会调用这个生命周期函数。在这个函数中实现组件卸载、清理事件监听等逻辑。我们可以简单的理解为 <code>ReactDOM.unmountComponentAtNode</code> 操作。函数形式如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">unmount</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 页面卸载逻辑</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'unmounted!\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li>\n</ul>\n<blockquote>\n<p>观察每个生命周期函数的签名我们可以发现，每个函数都有一个 <code>props</code> 参数，主应用可以通过这个参数向子应用传递一些额外信息，后面会做说明。</p>\n</blockquote>\n<blockquote>\n<p>为了方便各种技术栈的子应用能方便的接入，single-spa 提供了很多工具，可以在这里查到<a href="https://single-spa.js.org/docs/ecosystem#help-for-frameworks" target="_blank" rel="noopener noreferrer">官方维护的工具列表<OutboundLink/></a>。</p>\n</blockquote>\n<h2 id="其他概念" tabindex="-1"><a class="header-anchor" href="#其他概念" aria-hidden="true">#</a> 其他概念</h2>\n<h3 id="子应用的分类" tabindex="-1"><a class="header-anchor" href="#子应用的分类" aria-hidden="true">#</a> 子应用的分类</h3>\n<p>single-spa 根据职能的不同，把子应用划分成三类：</p>\n<ul>\n<li><a href="https://single-spa.js.org/docs/module-types#applications" target="_blank" rel="noopener noreferrer">Application<OutboundLink/></a>\n表示普通的子应用，需要实现上面提到的生命周期函数；</li>\n<li><a href="https://single-spa.js.org/docs/module-types#parcels" target="_blank" rel="noopener noreferrer">Parcel<OutboundLink/></a>\n可以理解为可以跨子应用复用的业务单元，需要实现<a href="https://single-spa.js.org/docs/parcels-api" target="_blank" rel="noopener noreferrer">与之对应的生命周期函数<OutboundLink/></a>；</li>\n<li><a href="https://single-spa.js.org/docs/module-types#utilities" target="_blank" rel="noopener noreferrer">Utility<OutboundLink/></a>\n表示一段可复用的逻辑，比如一个函数等，不做页面渲染。</li>\n</ul>\n<p>不难看出，Parcel 和 Utility 都是为了共享和复用，也算是 single-spa 在框架层面给出的一种复用方案。</p>\n<h3 id="layout-engine" tabindex="-1"><a class="header-anchor" href="#layout-engine" aria-hidden="true">#</a> Layout Engine</h3>\n<p>虽然 single-spa 的理念是让主应用尽可能的简单，但是在实践中，主应用通常会负责通用的顶部、底部通栏的渲染。这个时候，如何确定子应用的渲染位置就成了一个问题。</p>\n<p>single-spa 提供了 <a href="https://single-spa.js.org/docs/layout-overview" target="_blank" rel="noopener noreferrer">Layout Engine<OutboundLink/></a>的方案。样例代码如下，与 Vue 颇为相似，详细的可以查看文档，这里不做过多叙述。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>single-spa-layout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>single-spa-router</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>topnav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@organization/nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>application</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main-content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>route</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>settings<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@organization/settings<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>application</span><span class="token punctuation">></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>route</span><span class="token punctuation">></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>route</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clients<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@organization/clients<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>application</span><span class="token punctuation">></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>route</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@organization/footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>application</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>single-spa-router</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="关于-systemjs" tabindex="-1"><a class="header-anchor" href="#关于-systemjs" aria-hidden="true">#</a> 关于 SystemJS</h3>\n<p>很多人在提到 single-spa 的时候都会提到 <a href="https://github.com/systemjs/systemjs" target="_blank" rel="noopener noreferrer">SystemJS<OutboundLink/></a>，认为 SystemJS 是 single-spa 的核心之一。其实这是一个误区， SystemJS 并不是 single-spa 所必须的。</p>\n<p>前面说到，子应用要实现生命周期函数，然后导出给主应用使用。关键就是这个“导出”的实现，这就涉及到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noopener noreferrer">JavaScript 的模块化<OutboundLink/></a>问题。</p>\n<p>在一些现代浏览器中，我们可以通过在 <code>&lt;script&gt;</code> 标签上添加 <code>type=&quot;module&quot;</code> 来实现导入导出。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token comment">// or an inline script</span>\n  <span class="token keyword">import</span> <span class="token punctuation">{</span>helperMethod<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./providesHelperMethod.js\'</span><span class="token punctuation">;</span>\n  <span class="token function">helperMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n// providesHelperMethod.js\nexport function helperMethod() {\n  console.info(`I\'m helping!`);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>但是如果我们想要实现 <code>import axios from \'axios\'</code> 还需要借助于 <a href="https://github.com/WICG/import-maps" target="_blank" rel="noopener noreferrer"><code>importmap</code><OutboundLink/></a>。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>importmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n    <span class="token punctuation">{</span>\n       <span class="token string">"imports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token string">"axios"</span><span class="token operator">:</span> <span class="token string">"https://cdn.jsdelivr.net/npm/axios@0.20.0/dist/axios.min.js"</span>\n       <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">\'axios\'</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在低版本浏览器中，我们就需要借助于一些 “Polyfill” 来实现模块化了。SystemJS 就是解决这个问题的。所以 single-spa 的样例中大量采用了 SystemJS 来加载应用。</p>\n<p>其实也可以不用 SystemJS，webpack 也可以实现类似的能力，但是会加深主应用与子应用间的工程耦合。</p>\n<h2 id="隔离" tabindex="-1"><a class="header-anchor" href="#隔离" aria-hidden="true">#</a> 隔离</h2>\n<p>在<RouterLink to="/solutions/micro-frontend/microfrontend.html">理解微前端技术原理</RouterLink>中，我们花了很长的篇幅来说明子应用隔离的思路。那么，single-spa 中是如何来实现隔离的呢？</p>\n<h3 id="样式隔离" tabindex="-1"><a class="header-anchor" href="#样式隔离" aria-hidden="true">#</a> 样式隔离</h3>\n<p>single-spa 中的样式隔离可以分为两块来说。</p>\n<p>首先是子应用样式的加载和卸载。single-spa 提供了 <a href="https://single-spa.js.org/docs/ecosystem-css#single-spa-css" target="_blank" rel="noopener noreferrer">single-spa-css<OutboundLink/></a> 这个工具来实现。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> singleSpaCss <span class="token keyword">from</span> <span class="token string">\'single-spa-css\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> cssLifecycles <span class="token operator">=</span> <span class="token function">singleSpaCss</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 需要加载的 css 列表</span>\n  cssUrls<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'https://example.com/main.css\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n\n  <span class="token comment">// 是否是 webpack 导出的 css，如果是要做额外处理（webpack 导出的文件名通常会有 hash）</span>\n  webpackExtractedCss<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n\n  <span class="token comment">// 当子应用 unmount 的时候，css 是否需要一并删除</span>\n  shouldUnmount<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> reactLifecycles <span class="token operator">=</span> <span class="token function">singleSpaReact</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 加入到子应用的 bootstrap 里</span>\n<span class="token keyword">export</span> <span class="token keyword">const</span> bootstrap <span class="token operator">=</span> <span class="token punctuation">[</span>\n  cssLifecycles<span class="token punctuation">.</span>bootstrap<span class="token punctuation">,</span>\n  reactLifecycles<span class="token punctuation">.</span>bootstrap\n<span class="token punctuation">]</span>\n\n<span class="token keyword">export</span> <span class="token keyword">const</span> mount <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token comment">// 加入到子应用的 mount 里，css 放前面，不然 mount 后会有样式闪烁（FOUC）的问题</span>\n  cssLifecycles<span class="token punctuation">.</span>mount<span class="token punctuation">,</span>\n  reactLifecycles<span class="token punctuation">.</span>mount\n<span class="token punctuation">]</span>\n\n<span class="token keyword">export</span> <span class="token keyword">const</span> unmount <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token comment">// 后卸载 css，防止样式闪烁</span>\n  reactLifecycles<span class="token punctuation">.</span>unmount<span class="token punctuation">,</span>\n  cssLifecycles<span class="token punctuation">.</span>unmount\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>如果样式是 webpack 导出的，则每次构建后都要更新样式文件列表。single-spa 贴心的准备了一个插件来解决这个问题。只要在 webpack 的配置文件中添加如下插件即可。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"mini-css-extract-plugin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> ExposeRuntimeCssAssetsPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"single-spa-css/ExposeRuntimeCssAssetsPlugin.cjs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      filename<span class="token operator">:</span> <span class="token string">"[name].css"</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token keyword">new</span> <span class="token class-name">ExposeRuntimeCssAssetsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      <span class="token comment">// filename 必须与 MiniCssExtractPlugin 中的 filename 一一对应</span>\n      filename<span class="token operator">:</span> <span class="token string">"[name].css"</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>解决了子应用样式加载和卸载问题以后，我们再来看子应用样式隔离的问题。</p>\n<p>single-spa 给出了一些建议，比如使用 <a href="https://single-spa.js.org/docs/ecosystem-css#scoped-css" target="_blank" rel="noopener noreferrer">Scoped CSS<OutboundLink/></a>，每个子应用都有一个固定前缀，类似于下面这样：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token comment">/*\n&lt;div class="app1__settings-67f89dd87sf89ds">&lt;/div>\n*/</span>\n<span class="token selector">.app1__settings-67f89dd87sf89ds</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">/*\n&lt;div data-df65s76dfs class="settings">&lt;/div>\n*/</span>\n<span class="token selector">.settings[data-df65s76dfs]</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">/*\n&lt;div id="single-spa-application:@org-name/project-name">\n    &lt;div class="settings">&lt;/div>\n  &lt;/div>\n*/</span>\n#single-spa-application\\<span class="token punctuation">:</span>\\<span class="token atrule"><span class="token rule">@org-name</span>\\/project-name .settings</span> <span class="token punctuation">{</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>有很多工具可以实现 Scoped CSS，比如 <a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener noreferrer">CSS Modules<OutboundLink/></a> 等。</p>\n<p>最后一种方式我们可以通过 webpack 自动化的实现。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> prefixer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'postcss-prefix-selector\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token function">prefixer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      prefix<span class="token operator">:</span> <span class="token string">"#single-spa-application\\\\:\\\\@org-name\\\\/project-name"</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>single-spa 也提到了 Shadow DOM，我们在上一篇文章中已经分析过，这里不再赘述了。</p>\n<h3 id="js-隔离" tabindex="-1"><a class="header-anchor" href="#js-隔离" aria-hidden="true">#</a> JS 隔离</h3>\n<p>single-spa 采用了类似于<RouterLink to="/solutions/micro-frontend/microfrontend.html#%E5%BF%AB%E7%85%A7%E6%A8%A1%E5%BC%8F">快照模式</RouterLink>的隔离机制，通过 <a href="https://single-spa.js.org/docs/ecosystem-leaked-globals" target="_blank" rel="noopener noreferrer">single-spa-leaked-globals<OutboundLink/></a> 来实现。</p>\n<p>用法如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> singleSpaLeakedGlobals <span class="token keyword">from</span> <span class="token string">\'single-spa-leaked-globals\'</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 其它 single-spa-xxx 提供的生命周期函数</span>\n<span class="token keyword">const</span> frameworkLifecycles <span class="token operator">=</span> <span class="token operator">...</span>\n\n<span class="token comment">// 新添加的全局变量</span>\n<span class="token keyword">const</span> leakedGlobalsLifecycles <span class="token operator">=</span> <span class="token function">singleSpaLeakedGlobals</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  globalVariableNames<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'$\'</span><span class="token punctuation">,</span> <span class="token string">\'jQuery\'</span><span class="token punctuation">,</span> <span class="token string">\'_\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">export</span> <span class="token keyword">const</span> bootstrap <span class="token operator">=</span> <span class="token punctuation">[</span>\n  leakedGlobalsLifecycles<span class="token punctuation">.</span>bootstrap<span class="token punctuation">,</span> <span class="token comment">// 放在第一位</span>\n  frameworkLifecycles<span class="token punctuation">.</span>bootstrap<span class="token punctuation">,</span>\n<span class="token punctuation">]</span>\n\n<span class="token keyword">export</span> <span class="token keyword">const</span> mount <span class="token operator">=</span> <span class="token punctuation">[</span>\n  leakedGlobalsLifecycles<span class="token punctuation">.</span>mount<span class="token punctuation">,</span> <span class="token comment">// mount 时添加全局变量，如果之前有记录在案的，直接恢复</span>\n  frameworkLifecycles<span class="token punctuation">.</span>mount<span class="token punctuation">,</span>\n<span class="token punctuation">]</span>\n\n<span class="token keyword">export</span> <span class="token keyword">const</span> unmount <span class="token operator">=</span> <span class="token punctuation">[</span>\n  leakedGlobalsLifecycles<span class="token punctuation">.</span>unmount<span class="token punctuation">,</span> <span class="token comment">// 删掉新添加的全局变量</span>\n  frameworkLifecycles<span class="token punctuation">.</span>unmount<span class="token punctuation">,</span>\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote>\n<p>前面已经说过，快照模式的一个缺点是无法保证多个子应用同时运行时的有效隔离。</p>\n</blockquote>\n<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>总体来说，single-spa 算是基本实现了一个微前端框架需要具备的各种功能，但是又实现的不够彻底，遗留了很多问题需要解决。虽然官方提供了很多样例和最佳实践，但是总显得过于单薄，总给人一种“问题解决了，但是又没有完全解决”的感觉。</p>\n<p>qiankun 基于 single-spa 开发，一定程度上解决了很多 single-spa 没有解决的问题。我们下篇详细说明。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-12-01",deps:[],hoistedTags:[],links:[{raw:"./microfrontend.md",relative:"solutions/micro-frontend/microfrontend.md",absolute:"/solutions/micro-frontend/microfrontend.md"},{raw:"./microfrontend.md",relative:"solutions/micro-frontend/microfrontend.md",absolute:"/solutions/micro-frontend/microfrontend.md"},{raw:"./microfrontend.md#%E5%BF%AB%E7%85%A7%E6%A8%A1%E5%BC%8F",relative:"solutions/micro-frontend/microfrontend.md",absolute:"/solutions/micro-frontend/microfrontend.md"}],pathInferred:"/solutions/micro-frontend/single-spa.html",pathLocale:"/",permalink:null,slug:"single-spa",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/micro-frontend/single-spa.md",filePathRelative:"solutions/micro-frontend/single-spa.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/micro-frontend/single-spa.html.vue",componentFilePathRelative:"pages/solutions/micro-frontend/single-spa.html.vue",componentFileChunkName:"v-b1c699d8",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/micro-frontend/single-spa.html.js",dataFilePathRelative:"pages/solutions/micro-frontend/single-spa.html.js",dataFileChunkName:"v-b1c699d8",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/micro-frontend/single-spa.html",htmlFilePathRelative:"solutions/micro-frontend/single-spa.html"}]}},6742:(n,s,a)=>{a.r(s),a.d(s,{default:()=>o});var t=a(6252);const e=(0,t.Wm)("div",{class:"custom-container tip"},[(0,t.Wm)("p",{class:"custom-container-title"},"TIP"),(0,t.Wm)("p",null,"微前端的实践方案总结")],-1),p=(0,t.uE)('<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',1),o={render:function(n,s){const a=(0,t.up)("ArticleList");return(0,t.wg)(),(0,t.j4)(t.HY,null,[e,(0,t.Wm)(a),p],64)}}}}]);