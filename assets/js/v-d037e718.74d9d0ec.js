"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[363],{7580:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-d037e718",path:"/solutions/graphql/",title:"GraphQL 实践方案",lang:"zh-CN",frontmatter:{title:"GraphQL 实践方案",description:"GraphQL 一经推出就获得了广泛关注，解决了前端数据按需聚合裁减的问题。本系列从概念出发，详细说明为什么前端需要 GraphQL，GraphQL 会带来那些优势。之后，结合 NestJS、Apollo，构建前端数据聚合裁减服务。",sidebar:!1,key:2},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[],filePathRelative:"solutions/graphql/README.md",articleList:[{key:"v-60d0b1eb",path:"/solutions/graphql/bff.html",title:"快速理解 BFF",lang:"zh-CN",frontmatter:{title:"快速理解 BFF",description:"什么是 BFF？如何建设 BFF？",keywords:["BFF"],date:"2021-06-23T00:00:00.000Z",key:1,tags:["概念"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"BFF 的诞生背景",slug:"bff-的诞生背景",children:[]},{level:2,title:"如何建设 BFF？",slug:"如何建设-bff",children:[]},{level:2,title:"BFF 带来了哪些挑战？",slug:"bff-带来了哪些挑战",children:[]},{level:2,title:"参考文献",slug:"参考文献",children:[]}],content:"\nBFF（Backend For Frontend）这个模式出来很多年了，业界也有很多不错的实践。本文旨在对什么是 BFF，以及在什么情况下适合使用 BFF 做一些说明。\n\n## BFF 的诞生背景\n\n在互联网的发展过程中，Web 应用的功能变得越来越丰富。极端情况下，有一些页面甚至需要调用几十个接口来完成数据的获取。随着移动互联网的发展，移动 APP、H5 页面大大拓宽了前端的工作领域，同时也带来了多样的页面数据获取需求。\n\n在传统的开发模式中，后端服务直接为前端页面提供 API 接口。换句话说，后端的接口设计受页面的影响非常大。在互联网场景下，前端页面的变化是非常快的，也就意味着后端的接口也要跟着变。那么，势必会影响到后端的领域能力沉淀。同时，由于不同的 UI 端对数据的需求不尽相同，后端往往需要针对不同的端提供定制化的接口，这加剧了这个问题的影响。\n\n那么，如何才能有效解决这个问题呢？\n\n## 如何建设 BFF？\n\nBFF 全称是 Backend For Frontend。这里面有两个关键词，一个是 BFF 的服务对象，即 BFF 是为前端数据服务的。一个是 BFF 的本身存在形式，BFF 是一个后端服务，负责对后端领域数据接口进行聚合、裁剪以及编排。\n\n在回答如何建设 BFF 这个问题之前，我们需要先明确一个问题，就是由谁来构建 BFF？\n\n现在各大互联网公司都有关于 BFF 的实践，有的是前端团队负责 BFF，有的是后端团队负责 BFF。\n\n我们不妨可以对比下前端和后端团队来构建 BFF 的优缺点。\n\n|谁来构建|优势|劣势|\n|---|---|---|\n|前端|能对页面的定制化需求做出快速反应，几乎没有沟通成本|需要具备后端开发能力，对人的要求更高；同时需要前端深入理解业务模型|\n|后端|对业务模型理解更加透彻；服务管理的工具更丰富|沟通成本高|\n\n这两种实践没有孰优孰劣，无非是哪种方式更适合各自技术团队的技术能力构成和组织架构罢了。\n\n我所在的团队中，前端团队有一定的服务端开发能力，同时前端更接近于用户，对数据的定制化需求更加迫切，因此，我们采用的是由前端团队来负责建设 BFF。\n\n#### 如何划分 BFF？\n\n单一服务的 BFF 只适合于业务初始阶段，当业务逐步发展，BFF 对接的业务模型越来越多，对接的前端展现形式也越来越多，我们就需要思考 BFF 如何划分了。\n\n这里有两个问题需要解决，一个是如何处理各端差异的问题，一个是如何管理业务模型的问题。\n\n##### 如何处理各端差异\n\n我们前面就说到，BFF 诞生的一个出发点就是要解决因为端的差异导致对数据需求的不同的问题。\n\n为了能快速响应各端的数据需求，同时减少各端之间的相互影响，我们需要针对各端单独起 BFF 服务。\n\n```plantuml\nnode PC\nnode APP\nnode Web_BFF\nnode APP_BFF\nnode 商品服务\nnode 订单服务\nnode 营销服务\nnode 用户服务\n\nPC --\x3e Web_BFF\nAPP --\x3e APP_BFF\nWeb_BFF ..> 商品服务\nWeb_BFF ..> 订单服务\nWeb_BFF ..> 营销服务\nWeb_BFF ..> 用户服务\nAPP_BFF ..> 商品服务\nAPP_BFF ..> 订单服务\nAPP_BFF ..> 营销服务\nAPP_BFF ..> 用户服务\n```\n\n##### 如何管理业务模型\n\n后端的业务模型都是领域相关的，比如用户模型、订单模型、商品模型，这些模型不会在同一个服务内，而是分别在用户领域、订单领域、商品领域的服务里面。\n\n通常情况下，我们有两种方式来建立 BFF 的领域能力。一种是在 BFF 中通过目录、模块的形式进行规范管理，BFF 以单体服务的形式存在。一种是将领域能力独立成服务，对后端领域能力进行领域内的数据聚合。面向各个端的 BFF 服务再将各个领域的 BFF 服务数据进行二次聚合。\n\n前一种方式的架构图与上面一样，后一种的架构图如下。\n\n```plantuml\nnode PC\nnode APP\nnode Web_BFF\nnode APP_BFF\nnode 商品_BFF\nnode 订单_BFF\nnode 营销_BFF\nnode 用户_BFF\nnode 商品服务\nnode 订单服务\nnode 营销服务\nnode 用户服务\n\nPC --\x3e Web_BFF\nAPP --\x3e APP_BFF\nWeb_BFF ..> 商品_BFF\nWeb_BFF ..> 订单_BFF\nWeb_BFF ..> 营销_BFF\nWeb_BFF ..> 用户_BFF\nAPP_BFF ..> 商品_BFF\nAPP_BFF ..> 订单_BFF\nAPP_BFF ..> 营销_BFF\nAPP_BFF ..> 用户_BFF\n商品_BFF ..> 商品服务\n订单_BFF ..> 订单服务\n营销_BFF ..> 营销服务\n用户_BFF ..> 用户服务\n```\n\n将领域 BFF 服务单独拆分出来，需要面向端的 BFF 将数据做二次聚合。这增加了额外的复杂性。同时，如果后端领域服务拆分的很细的话，BFF 服务的颗粒度划分也需要做一些深入的思考。这个我们会在后面的文章中详细分析。\n\n#### 构建 BFF 的基本原则是什么？\n\nBFF 作为一个沟通前后端的中间层服务，势必在建设过程中遇到很多难以确定边界的事情。比如一个功能到底是放在 BFF 做还是放在后端服务来做，有时候这样的问题最终得依赖经验丰富的开发同学来解决。\n\n那么，我们在构建 BFF 的时候，需要确定一些基本原则，来尽量减少这类问题的发生。\n\n- **BFF 要聚焦在对数据的聚合、裁剪和编排上**\n\nBFF 作为一个服务，理论上什么功能都可以做。但是我们要明确构建 BFF 的目的，就是为了解决前端页面差异化的展示需求。因此，BFF 应该聚焦在对数据的聚合、裁剪，以及在必要情况对后端接口进行一定的编排的能力。其他的问题，虽然 BFF 也可以轻松解决，但是还是要交给后端服务来实现。\n\n- **所有的 UI 都应该与 BFF 对接**\n\n有了 BFF 以后，我们应该将所有针对 UI 的数据支持都收口到 BFF 上来。换句话说就是所有 UI 的数据都应该从 BFF 中获取，尽量避免即从后端服务直接获取数据，又从 BFF 获取数据的情况。\n\n## BFF 带来了哪些挑战？\n\n对于前端开发人员来说，BFF 带来了一个全新的技术环境。需要开发人员快速学习并掌握服务端开发的基本技能，包括但不限于基础的服务端开发能力、基础的运维能力等。\n\n同时，前端同学要完成思维方式的转变，BFF 虽然为前端页面的数据服务，但是其本身是一个后端服务，作为 API 的消费者的同时，也是 API 的生产者，所有后端服务可能遇到的问题，BFF 都可能遇到。比如对外提供的 API 如何保证兼容性等。\n\n除了硬性的技能要求以外，BFF 带给前端开发人员最大的挑战是需要开发人员更加细致的了解业务。需要从具体业务、乃至整个产品的角度来思考，这对习惯于聚焦页面展现效果的前端开发人员来说，也是一个极大的工作思路的转变。\n\n## 参考文献\n\n- [Pattern: Backends For Frontends](https://samnewman.io/patterns/architectural/bff/)\n- [康威定律](https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B)\n",contentRendered:'<p>BFF（Backend For Frontend）这个模式出来很多年了，业界也有很多不错的实践。本文旨在对什么是 BFF，以及在什么情况下适合使用 BFF 做一些说明。</p>\n<h2 id="bff-的诞生背景" tabindex="-1"><a class="header-anchor" href="#bff-的诞生背景" aria-hidden="true">#</a> BFF 的诞生背景</h2>\n<p>在互联网的发展过程中，Web 应用的功能变得越来越丰富。极端情况下，有一些页面甚至需要调用几十个接口来完成数据的获取。随着移动互联网的发展，移动 APP、H5 页面大大拓宽了前端的工作领域，同时也带来了多样的页面数据获取需求。</p>\n<p>在传统的开发模式中，后端服务直接为前端页面提供 API 接口。换句话说，后端的接口设计受页面的影响非常大。在互联网场景下，前端页面的变化是非常快的，也就意味着后端的接口也要跟着变。那么，势必会影响到后端的领域能力沉淀。同时，由于不同的 UI 端对数据的需求不尽相同，后端往往需要针对不同的端提供定制化的接口，这加剧了这个问题的影响。</p>\n<p>那么，如何才能有效解决这个问题呢？</p>\n<h2 id="如何建设-bff" tabindex="-1"><a class="header-anchor" href="#如何建设-bff" aria-hidden="true">#</a> 如何建设 BFF？</h2>\n<p>BFF 全称是 Backend For Frontend。这里面有两个关键词，一个是 BFF 的服务对象，即 BFF 是为前端数据服务的。一个是 BFF 的本身存在形式，BFF 是一个后端服务，负责对后端领域数据接口进行聚合、裁剪以及编排。</p>\n<p>在回答如何建设 BFF 这个问题之前，我们需要先明确一个问题，就是由谁来构建 BFF？</p>\n<p>现在各大互联网公司都有关于 BFF 的实践，有的是前端团队负责 BFF，有的是后端团队负责 BFF。</p>\n<p>我们不妨可以对比下前端和后端团队来构建 BFF 的优缺点。</p>\n<table>\n<thead>\n<tr>\n<th>谁来构建</th>\n<th>优势</th>\n<th>劣势</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>前端</td>\n<td>能对页面的定制化需求做出快速反应，几乎没有沟通成本</td>\n<td>需要具备后端开发能力，对人的要求更高；同时需要前端深入理解业务模型</td>\n</tr>\n<tr>\n<td>后端</td>\n<td>对业务模型理解更加透彻；服务管理的工具更丰富</td>\n<td>沟通成本高</td>\n</tr>\n</tbody>\n</table>\n<p>这两种实践没有孰优孰劣，无非是哪种方式更适合各自技术团队的技术能力构成和组织架构罢了。</p>\n<p>我所在的团队中，前端团队有一定的服务端开发能力，同时前端更接近于用户，对数据的定制化需求更加迫切，因此，我们采用的是由前端团队来负责建设 BFF。</p>\n<h4 id="如何划分-bff" tabindex="-1"><a class="header-anchor" href="#如何划分-bff" aria-hidden="true">#</a> 如何划分 BFF？</h4>\n<p>单一服务的 BFF 只适合于业务初始阶段，当业务逐步发展，BFF 对接的业务模型越来越多，对接的前端展现形式也越来越多，我们就需要思考 BFF 如何划分了。</p>\n<p>这里有两个问题需要解决，一个是如何处理各端差异的问题，一个是如何管理业务模型的问题。</p>\n<h5 id="如何处理各端差异" tabindex="-1"><a class="header-anchor" href="#如何处理各端差异" aria-hidden="true">#</a> 如何处理各端差异</h5>\n<p>我们前面就说到，BFF 诞生的一个出发点就是要解决因为端的差异导致对数据需求的不同的问题。</p>\n<p>为了能快速响应各端的数据需求，同时减少各端之间的相互影响，我们需要针对各端单独起 BFF 服务。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuShBJqbL2726q8u10H16U6fIl9ER6rmKmNawjUtfvCPdStgVTYs4YBnOj-XfxrGKaGbBNqvfG1PvFcN5iuxjK16k06S5NLqxk2L0yy5yc3rGSGKzFJjKwv0bK6n5aK2s75a2nGrGkp3jG9P0iGD50jaEP0aKEnnIyrA0GGm0" alt="uml diagram">\n<h5 id="如何管理业务模型" tabindex="-1"><a class="header-anchor" href="#如何管理业务模型" aria-hidden="true">#</a> 如何管理业务模型</h5>\n<p>后端的业务模型都是领域相关的，比如用户模型、订单模型、商品模型，这些模型不会在同一个服务内，而是分别在用户领域、订单领域、商品领域的服务里面。</p>\n<p>通常情况下，我们有两种方式来建立 BFF 的领域能力。一种是在 BFF 中通过目录、模块的形式进行规范管理，BFF 以单体服务的形式存在。一种是将领域能力独立成服务，对后端领域能力进行领域内的数据聚合。面向各个端的 BFF 服务再将各个领域的 BFF 服务数据进行二次聚合。</p>\n<p>前一种方式的架构图与上面一样，后一种的架构图如下。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuShBJqbL2726q8u10H16U6fIl9ER6rmKmNawjUtfv4O4_yMwHKzxfoBn9onzEQK1mNy-PSMpZkte-f_DwNtQjH3P11GHi1d88X1Je29S0SuAkhfsS4S2tGVcmzm95LVGqxD3TYwoC9AhKOGHZaSMHl83r0vqiv65aSn64KQOZIoCP3R2F2JZeNv668fa1qmERZAIHL0vXF58ja7b75BpKe190000" alt="uml diagram">\n<p>将领域 BFF 服务单独拆分出来，需要面向端的 BFF 将数据做二次聚合。这增加了额外的复杂性。同时，如果后端领域服务拆分的很细的话，BFF 服务的颗粒度划分也需要做一些深入的思考。这个我们会在后面的文章中详细分析。</p>\n<h4 id="构建-bff-的基本原则是什么" tabindex="-1"><a class="header-anchor" href="#构建-bff-的基本原则是什么" aria-hidden="true">#</a> 构建 BFF 的基本原则是什么？</h4>\n<p>BFF 作为一个沟通前后端的中间层服务，势必在建设过程中遇到很多难以确定边界的事情。比如一个功能到底是放在 BFF 做还是放在后端服务来做，有时候这样的问题最终得依赖经验丰富的开发同学来解决。</p>\n<p>那么，我们在构建 BFF 的时候，需要确定一些基本原则，来尽量减少这类问题的发生。</p>\n<ul>\n<li><strong>BFF 要聚焦在对数据的聚合、裁剪和编排上</strong></li>\n</ul>\n<p>BFF 作为一个服务，理论上什么功能都可以做。但是我们要明确构建 BFF 的目的，就是为了解决前端页面差异化的展示需求。因此，BFF 应该聚焦在对数据的聚合、裁剪，以及在必要情况对后端接口进行一定的编排的能力。其他的问题，虽然 BFF 也可以轻松解决，但是还是要交给后端服务来实现。</p>\n<ul>\n<li><strong>所有的 UI 都应该与 BFF 对接</strong></li>\n</ul>\n<p>有了 BFF 以后，我们应该将所有针对 UI 的数据支持都收口到 BFF 上来。换句话说就是所有 UI 的数据都应该从 BFF 中获取，尽量避免即从后端服务直接获取数据，又从 BFF 获取数据的情况。</p>\n<h2 id="bff-带来了哪些挑战" tabindex="-1"><a class="header-anchor" href="#bff-带来了哪些挑战" aria-hidden="true">#</a> BFF 带来了哪些挑战？</h2>\n<p>对于前端开发人员来说，BFF 带来了一个全新的技术环境。需要开发人员快速学习并掌握服务端开发的基本技能，包括但不限于基础的服务端开发能力、基础的运维能力等。</p>\n<p>同时，前端同学要完成思维方式的转变，BFF 虽然为前端页面的数据服务，但是其本身是一个后端服务，作为 API 的消费者的同时，也是 API 的生产者，所有后端服务可能遇到的问题，BFF 都可能遇到。比如对外提供的 API 如何保证兼容性等。</p>\n<p>除了硬性的技能要求以外，BFF 带给前端开发人员最大的挑战是需要开发人员更加细致的了解业务。需要从具体业务、乃至整个产品的角度来思考，这对习惯于聚焦页面展现效果的前端开发人员来说，也是一个极大的工作思路的转变。</p>\n<h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2>\n<ul>\n<li><a href="https://samnewman.io/patterns/architectural/bff/" target="_blank" rel="noopener noreferrer">Pattern: Backends For Frontends<OutboundLink/></a></li>\n<li><a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener noreferrer">康威定律<OutboundLink/></a></li>\n</ul>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-06-23",deps:[],hoistedTags:[],links:[],pathInferred:"/solutions/graphql/bff.html",pathLocale:"/",permalink:null,slug:"bff",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/graphql/bff.md",filePathRelative:"solutions/graphql/bff.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/bff.html.vue",componentFilePathRelative:"pages/solutions/graphql/bff.html.vue",componentFileChunkName:"v-60d0b1eb",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/bff.html.js",dataFilePathRelative:"pages/solutions/graphql/bff.html.js",dataFileChunkName:"v-60d0b1eb",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/graphql/bff.html",htmlFilePathRelative:"solutions/graphql/bff.html"},{key:"v-14c956fa",path:"/solutions/graphql/client.html",title:"在 React 项目中使用 GraphQL 查询数据",lang:"zh-CN",frontmatter:{title:"在 React 项目中使用 GraphQL 查询数据",description:"介绍在 React 中如何通过 GraphQL、代码自动生成工具查询数据",keywords:["GraphQL","GraphQL Code Generator"],date:"2021-07-16T00:00:00.000Z",key:5,tags:["实践"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"初始化项目",slug:"初始化项目",children:[{level:3,title:"初始化和安装依赖",slug:"初始化和安装依赖",children:[]},{level:3,title:"配置文件",slug:"配置文件",children:[]}]},{level:2,title:"第一个查询",slug:"第一个查询",children:[{level:3,title:"自动化生成查询代码",slug:"自动化生成查询代码",children:[]},{level:3,title:"使用 ApolloClient",slug:"使用-apolloclient",children:[]}]},{level:2,title:"总结",slug:"总结",children:[]}],content:'\n本文介绍如何在 React 项目中使用 GraphQL 查询，同时配合 [@graphql-codegen/cli](https://npmjs.org/package/@graphql-codegen/cli) 代码自动生成工具提高开发效率。\n\n## 初始化项目\n\n### 初始化和安装依赖\n我们使用 [create-react-app](https://www.npmjs.com/package/create-react-app) 来初始化前端项目，使用官方的 [typescript](https://www.npmjs.com/package/cra-template-typescript) 模板。\n\n假设我们的项目名称是 [bff-graphql-client](https://github.com/everfind/bff-graphql-client)\n\n```bash\nyarn create react-app bff-graphql-client --template typescript\n```\n\n等待几分钟后，项目初始化完成。\n\n现在我们安装 GraphQL 的包。\n\n```bash\nyarn add graphql\n```\n\n由于 [graphql](https://www.npmjs.com/package/graphql) 这个包使用起来非常繁琐，我们通过 @graphql-codegen/cli 来自动生成这些类型代码，我们只需要编写查询的 `Query` 即可。\n\n```bash\nyarn add -D @graphql-codegen/cli\n```\n\n我们使用 Apollo 客户端来实现查询，同时添加一些 typescript 插件来生成 typescript 代码。\n\n```bash\nyarn add -D @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo\n\nyarn add @apollo/client\n```\n\n### 配置文件\n\n安装完依赖包以后，我们通过 GraphQL Code Generator 的指引来生成配置文件，GraphQL Code Generator 会根据这个配置文件来生成代码。\n\n```bash\nyarn graphql-codegen init\n```\n\n根据命令行提示，我们生成配置文件。\n\n![codegen config](/solutions/graphql/codegen-c.png)\n\n在生成的配置如下：\n\n```yaml\noverwrite: true\nschema: "http://localhost:3000/graphql" # graphql 服务的地址\ndocuments: "src/**/*.graphql" # 查找项目中所有已 .graphql 结尾的文件，来生成代码\ngenerates:\n  src/generated/graphql.tsx: # 代码输出地址\n    plugins:\n      - "typescript"\n      - "typescript-operations"\n      - "typescript-react-apollo"\n  ./graphql.schema.json:\n    plugins:\n      - "introspection"\n```\n\n因为我们要使用 Apollo 的客户端，同时使用 React Hook，因此需要对配置做一些修改：\n\n```yaml\noverwrite: true\nschema: "http://localhost:3000/graphql"\ndocuments: "src/**/*.graphql"\ngenerates:\n  src/generated/graphql.tsx:\n    plugins:\n      - "typescript"\n      - "typescript-operations"\n      - "typescript-react-apollo"\n    config:\n      noComponents: true\n      noNamespaces: true\n      skipTypename: true\n      withHooks: true # 使用 React Hook\n      withComponent: false\n      withHOC: false\n      apolloReactHooksImportFrom: "@apollo/client" # 使用 Apollo Client\n      apolloReactCommonImportFrom: "@apollo/client"\n  ./graphql.schema.json:\n    plugins:\n      - "introspection"\n\n```\n\n相关配置的功能说明可以在[这里](https://www.graphql-code-generator.com/docs/plugins/typescript-react-apollo)找到，就不一一赘述了，这里只标出来比较关键的两个配置。\n\n## 第一个查询\n\n完成配置以后，我们现在来尝试查一下在上一篇文章中定义的商品信息。\n\n### 自动化生成查询代码\n\n先启动 GraphQL 服务，打开 playground 看看系统内有哪些模型可查。在上一篇文章中，我们定义了商品模型、订单模型。我们先来查一下商品模型。\n\n我们先在 `src` 目录下新建一个 `graphql` 目录，用来存在所有的 `.graphql` 文件。\n\n```graphql\nquery Goods($param: GoodsParam!) {\n  goodsData(param: $param) {\n    goodsId\n    goodsName\n  }\n}\n```\n\n将上面的内容保存在 `src/graphql/goods.graphl` 中。运行 `yarn codegen`，我们看到命令行显示运行成功，查看 `src/generated/graphql.tsx` 中生成了很多代码。\n\n![codegen output](/solutions/graphql/codegen-output-c.png)\n\n我们在生成的代码中看到了这两个函数，我们会用他们来查询商品信息：\n\n```ts\nexport function useGoodsQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GoodsQuery, GoodsQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return ApolloReactHooks.useQuery<GoodsQuery, GoodsQueryVariables>(GoodsDocument, options);\n      }\nexport function useGoodsLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GoodsQuery, GoodsQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return ApolloReactHooks.useLazyQuery<GoodsQuery, GoodsQueryVariables>(GoodsDocument, options);\n        }\n```\n\n> `useGoodsQuery` 是立即查询，`useGoodsLazyQuery` 会返回一个函数，调用这个函数才会触发查询。详细信息可以查看这两函数的签名。\n\n每次修改 `.graphql` 文件都执行一次 `yarn codegen` 是非常麻烦的。我们来开启 `@graphql-codegen/cli` 的 `watch` 模式，来实现自动化生成。\n\n```json\n{\n    "scripts": {\n        "codegen": "graphql-codegen --config codegen.yml --watch"\n    },\n}\n```\n\n此时再执行 `yarn codegen`，控制台显示：\n\n![codegen watch](/solutions/graphql/codegen-watch-c.png)\n\n\n\n### 使用 ApolloClient\n\n先在 `src/index.tsx` 中完成 ApolloClient 的初始化和配置。\n\n```tsx\nimport { ApolloClient, ApolloProvider, HttpLink, InMemoryCache } from "@apollo/client";\n\nconst apolloClient = new ApolloClient({\n  link: new HttpLink({\n    uri: "http://localhost:3000/graphql",\n  }),\n  cache: new InMemoryCache(),\n  defaultOptions: {\n    query: {\n      errorPolicy: "all",\n      fetchPolicy: "network-only",\n    },\n    watchQuery: {\n      errorPolicy: "all",\n      fetchPolicy: "network-only",\n    },\n  },\n});\n\nReactDOM.render(\n  <React.StrictMode>\n    <ApolloProvider client={apolloClient}>\n      <App />\n    </ApolloProvider>\n  </React.StrictMode>,\n  document.getElementById("root")\n);\n```\n\n配置完成后，稍微改造下 `App.tsx`，使用 `useGoodsQuery` 查询数据，并将数据展示出来：\n\n```tsx\nimport React from "react";\nimport { useGoodsQuery } from "./generated/graphql";\n\nfunction App() {\n  const { data, loading } = useGoodsQuery({\n    variables: {\n      param: {\n        goodsId: "g-00001",\n      },\n    },\n  });\n  if (loading) {\n    return <div className="App">loading data...</div>;\n  }\n  return <div className="App">{JSON.stringify(data?.goodsData, null, 4)}</div>;\n}\n\nexport default App;\n```\n\n此时运行 `yarn start`，我们可以在浏览器中看到输出的商品信息。\n\n我们可以看到页面先显示 `loading data...` 然后显示查到的商品信息：\n\n```json\n{ "__typename": "GoodsData", "goodsId": "g-0001", "goodsName": "商品名称" }\n```\n\n至此，我们就实现了在 React 项目中使用 GraphQL 查询数据。\n\n## 总结\n\n本文介绍如何在 React 项目中使用 GraphQL 查询数据。\n\n通过 `@graphql-codegen/cli` 自动化生成代码，提高开发效率。文中展示了如何编写配置文件来启用 React Hook。\n\n通过 `--watch` 参数来开启 `@graphql-codegen/cli` 的监听模式，实现 `.graphql` 变动自动化生成代码。\n\n同时，我们使用 Apollo Client 来实现 GraphQL 查询，并展示了如何配置 Apollo Client。\n',contentRendered:'<p>本文介绍如何在 React 项目中使用 GraphQL 查询，同时配合 <a href="https://npmjs.org/package/@graphql-codegen/cli" target="_blank" rel="noopener noreferrer">@graphql-codegen/cli<OutboundLink/></a> 代码自动生成工具提高开发效率。</p>\n<h2 id="初始化项目" tabindex="-1"><a class="header-anchor" href="#初始化项目" aria-hidden="true">#</a> 初始化项目</h2>\n<h3 id="初始化和安装依赖" tabindex="-1"><a class="header-anchor" href="#初始化和安装依赖" aria-hidden="true">#</a> 初始化和安装依赖</h3>\n<p>我们使用 <a href="https://www.npmjs.com/package/create-react-app" target="_blank" rel="noopener noreferrer">create-react-app<OutboundLink/></a> 来初始化前端项目，使用官方的 <a href="https://www.npmjs.com/package/cra-template-typescript" target="_blank" rel="noopener noreferrer">typescript<OutboundLink/></a> 模板。</p>\n<p>假设我们的项目名称是 <a href="https://github.com/everfind/bff-graphql-client" target="_blank" rel="noopener noreferrer">bff-graphql-client<OutboundLink/></a></p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> create react-app bff-graphql-client --template typescript\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>等待几分钟后，项目初始化完成。</p>\n<p>现在我们安装 GraphQL 的包。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> graphql\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>由于 <a href="https://www.npmjs.com/package/graphql" target="_blank" rel="noopener noreferrer">graphql<OutboundLink/></a> 这个包使用起来非常繁琐，我们通过 @graphql-codegen/cli 来自动生成这些类型代码，我们只需要编写查询的 <code>Query</code> 即可。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> -D @graphql-codegen/cli\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>我们使用 Apollo 客户端来实现查询，同时添加一些 typescript 插件来生成 typescript 代码。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> -D @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo\n\n<span class="token function">yarn</span> <span class="token function">add</span> @apollo/client\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="配置文件" tabindex="-1"><a class="header-anchor" href="#配置文件" aria-hidden="true">#</a> 配置文件</h3>\n<p>安装完依赖包以后，我们通过 GraphQL Code Generator 的指引来生成配置文件，GraphQL Code Generator 会根据这个配置文件来生成代码。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> graphql-codegen init\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>根据命令行提示，我们生成配置文件。</p>\n<p><img src="/solutions/graphql/codegen-c.png" alt="codegen config"></p>\n<p>在生成的配置如下：</p>\n<div class="language-yaml ext-yml line-numbers-mode"><pre v-pre class="language-yaml"><code><span class="token key atrule">overwrite</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>\n<span class="token key atrule">schema</span><span class="token punctuation">:</span> <span class="token string">"http://localhost:3000/graphql"</span> <span class="token comment"># graphql 服务的地址</span>\n<span class="token key atrule">documents</span><span class="token punctuation">:</span> <span class="token string">"src/**/*.graphql"</span> <span class="token comment"># 查找项目中所有已 .graphql 结尾的文件，来生成代码</span>\n<span class="token key atrule">generates</span><span class="token punctuation">:</span>\n  <span class="token key atrule">src/generated/graphql.tsx</span><span class="token punctuation">:</span> <span class="token comment"># 代码输出地址</span>\n    <span class="token key atrule">plugins</span><span class="token punctuation">:</span>\n      <span class="token punctuation">-</span> <span class="token string">"typescript"</span>\n      <span class="token punctuation">-</span> <span class="token string">"typescript-operations"</span>\n      <span class="token punctuation">-</span> <span class="token string">"typescript-react-apollo"</span>\n  <span class="token key atrule">./graphql.schema.json</span><span class="token punctuation">:</span>\n    <span class="token key atrule">plugins</span><span class="token punctuation">:</span>\n      <span class="token punctuation">-</span> <span class="token string">"introspection"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>因为我们要使用 Apollo 的客户端，同时使用 React Hook，因此需要对配置做一些修改：</p>\n<div class="language-yaml ext-yml line-numbers-mode"><pre v-pre class="language-yaml"><code><span class="token key atrule">overwrite</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>\n<span class="token key atrule">schema</span><span class="token punctuation">:</span> <span class="token string">"http://localhost:3000/graphql"</span>\n<span class="token key atrule">documents</span><span class="token punctuation">:</span> <span class="token string">"src/**/*.graphql"</span>\n<span class="token key atrule">generates</span><span class="token punctuation">:</span>\n  <span class="token key atrule">src/generated/graphql.tsx</span><span class="token punctuation">:</span>\n    <span class="token key atrule">plugins</span><span class="token punctuation">:</span>\n      <span class="token punctuation">-</span> <span class="token string">"typescript"</span>\n      <span class="token punctuation">-</span> <span class="token string">"typescript-operations"</span>\n      <span class="token punctuation">-</span> <span class="token string">"typescript-react-apollo"</span>\n    <span class="token key atrule">config</span><span class="token punctuation">:</span>\n      <span class="token key atrule">noComponents</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>\n      <span class="token key atrule">noNamespaces</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>\n      <span class="token key atrule">skipTypename</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>\n      <span class="token key atrule">withHooks</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 使用 React Hook</span>\n      <span class="token key atrule">withComponent</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>\n      <span class="token key atrule">withHOC</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>\n      <span class="token key atrule">apolloReactHooksImportFrom</span><span class="token punctuation">:</span> <span class="token string">"@apollo/client"</span> <span class="token comment"># 使用 Apollo Client</span>\n      <span class="token key atrule">apolloReactCommonImportFrom</span><span class="token punctuation">:</span> <span class="token string">"@apollo/client"</span>\n  <span class="token key atrule">./graphql.schema.json</span><span class="token punctuation">:</span>\n    <span class="token key atrule">plugins</span><span class="token punctuation">:</span>\n      <span class="token punctuation">-</span> <span class="token string">"introspection"</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>相关配置的功能说明可以在<a href="https://www.graphql-code-generator.com/docs/plugins/typescript-react-apollo" target="_blank" rel="noopener noreferrer">这里<OutboundLink/></a>找到，就不一一赘述了，这里只标出来比较关键的两个配置。</p>\n<h2 id="第一个查询" tabindex="-1"><a class="header-anchor" href="#第一个查询" aria-hidden="true">#</a> 第一个查询</h2>\n<p>完成配置以后，我们现在来尝试查一下在上一篇文章中定义的商品信息。</p>\n<h3 id="自动化生成查询代码" tabindex="-1"><a class="header-anchor" href="#自动化生成查询代码" aria-hidden="true">#</a> 自动化生成查询代码</h3>\n<p>先启动 GraphQL 服务，打开 playground 看看系统内有哪些模型可查。在上一篇文章中，我们定义了商品模型、订单模型。我们先来查一下商品模型。</p>\n<p>我们先在 <code>src</code> 目录下新建一个 <code>graphql</code> 目录，用来存在所有的 <code>.graphql</code> 文件。</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">query</span> <span class="token definition-query function">Goods</span><span class="token punctuation">(</span><span class="token variable">$param</span><span class="token punctuation">:</span> <span class="token class-name">GoodsParam</span><span class="token operator">!</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token property-query">goodsData</span><span class="token punctuation">(</span><span class="token attr-name">param</span><span class="token punctuation">:</span> <span class="token variable">$param</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token property">goodsId</span>\n    <span class="token property">goodsName</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>将上面的内容保存在 <code>src/graphql/goods.graphl</code> 中。运行 <code>yarn codegen</code>，我们看到命令行显示运行成功，查看 <code>src/generated/graphql.tsx</code> 中生成了很多代码。</p>\n<p><img src="/solutions/graphql/codegen-output-c.png" alt="codegen output"></p>\n<p>我们在生成的代码中看到了这两个函数，我们会用他们来查询商品信息：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useGoodsQuery</span><span class="token punctuation">(</span>baseOptions<span class="token operator">:</span> ApolloReactHooks<span class="token punctuation">.</span>QueryHookOptions<span class="token operator">&lt;</span>GoodsQuery<span class="token punctuation">,</span> GoodsQueryVariables<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>defaultOptions<span class="token punctuation">,</span> <span class="token operator">...</span>baseOptions<span class="token punctuation">}</span>\n        <span class="token keyword">return</span> ApolloReactHooks<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">useQuery</span><span class="token generic class-name"><span class="token operator">&lt;</span>GoodsQuery<span class="token punctuation">,</span> GoodsQueryVariables<span class="token operator">></span></span></span><span class="token punctuation">(</span>GoodsDocument<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useGoodsLazyQuery</span><span class="token punctuation">(</span>baseOptions<span class="token operator">?</span><span class="token operator">:</span> ApolloReactHooks<span class="token punctuation">.</span>LazyQueryHookOptions<span class="token operator">&lt;</span>GoodsQuery<span class="token punctuation">,</span> GoodsQueryVariables<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>defaultOptions<span class="token punctuation">,</span> <span class="token operator">...</span>baseOptions<span class="token punctuation">}</span>\n          <span class="token keyword">return</span> ApolloReactHooks<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">useLazyQuery</span><span class="token generic class-name"><span class="token operator">&lt;</span>GoodsQuery<span class="token punctuation">,</span> GoodsQueryVariables<span class="token operator">></span></span></span><span class="token punctuation">(</span>GoodsDocument<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote>\n<p><code>useGoodsQuery</code> 是立即查询，<code>useGoodsLazyQuery</code> 会返回一个函数，调用这个函数才会触发查询。详细信息可以查看这两函数的签名。</p>\n</blockquote>\n<p>每次修改 <code>.graphql</code> 文件都执行一次 <code>yarn codegen</code> 是非常麻烦的。我们来开启 <code>@graphql-codegen/cli</code> 的 <code>watch</code> 模式，来实现自动化生成。</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n    <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token property">"codegen"</span><span class="token operator">:</span> <span class="token string">"graphql-codegen --config codegen.yml --watch"</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>此时再执行 <code>yarn codegen</code>，控制台显示：</p>\n<p><img src="/solutions/graphql/codegen-watch-c.png" alt="codegen watch"></p>\n<h3 id="使用-apolloclient" tabindex="-1"><a class="header-anchor" href="#使用-apolloclient" aria-hidden="true">#</a> 使用 ApolloClient</h3>\n<p>先在 <code>src/index.tsx</code> 中完成 ApolloClient 的初始化和配置。</p>\n<div class="language-tsx ext-tsx line-numbers-mode"><pre v-pre class="language-tsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ApolloClient<span class="token punctuation">,</span> ApolloProvider<span class="token punctuation">,</span> HttpLink<span class="token punctuation">,</span> InMemoryCache <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"@apollo/client"</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> apolloClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApolloClient</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  link<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">HttpLink</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    uri<span class="token operator">:</span> <span class="token string">"http://localhost:3000/graphql"</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  cache<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">InMemoryCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  defaultOptions<span class="token operator">:</span> <span class="token punctuation">{</span>\n    query<span class="token operator">:</span> <span class="token punctuation">{</span>\n      errorPolicy<span class="token operator">:</span> <span class="token string">"all"</span><span class="token punctuation">,</span>\n      fetchPolicy<span class="token operator">:</span> <span class="token string">"network-only"</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    watchQuery<span class="token operator">:</span> <span class="token punctuation">{</span>\n      errorPolicy<span class="token operator">:</span> <span class="token string">"all"</span><span class="token punctuation">,</span>\n      fetchPolicy<span class="token operator">:</span> <span class="token string">"network-only"</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">React.StrictMode</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ApolloProvider</span></span> <span class="token attr-name">client</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>apolloClient<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">App</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ApolloProvider</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">React.StrictMode</span></span><span class="token punctuation">></span></span><span class="token punctuation">,</span>\n  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>配置完成后，稍微改造下 <code>App.tsx</code>，使用 <code>useGoodsQuery</code> 查询数据，并将数据展示出来：</p>\n<div class="language-tsx ext-tsx line-numbers-mode"><pre v-pre class="language-tsx"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> useGoodsQuery <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./generated/graphql"</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span> data<span class="token punctuation">,</span> loading <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useGoodsQuery</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    variables<span class="token operator">:</span> <span class="token punctuation">{</span>\n      param<span class="token operator">:</span> <span class="token punctuation">{</span>\n        goodsId<span class="token operator">:</span> <span class="token string">"g-00001"</span><span class="token punctuation">,</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>loading<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>App<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">loading data...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>App<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token operator">?.</span>goodsData<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>此时运行 <code>yarn start</code>，我们可以在浏览器中看到输出的商品信息。</p>\n<p>我们可以看到页面先显示 <code>loading data...</code> 然后显示查到的商品信息：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span> <span class="token property">"__typename"</span><span class="token operator">:</span> <span class="token string">"GoodsData"</span><span class="token punctuation">,</span> <span class="token property">"goodsId"</span><span class="token operator">:</span> <span class="token string">"g-0001"</span><span class="token punctuation">,</span> <span class="token property">"goodsName"</span><span class="token operator">:</span> <span class="token string">"商品名称"</span> <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>至此，我们就实现了在 React 项目中使用 GraphQL 查询数据。</p>\n<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>\n<p>本文介绍如何在 React 项目中使用 GraphQL 查询数据。</p>\n<p>通过 <code>@graphql-codegen/cli</code> 自动化生成代码，提高开发效率。文中展示了如何编写配置文件来启用 React Hook。</p>\n<p>通过 <code>--watch</code> 参数来开启 <code>@graphql-codegen/cli</code> 的监听模式，实现 <code>.graphql</code> 变动自动化生成代码。</p>\n<p>同时，我们使用 Apollo Client 来实现 GraphQL 查询，并展示了如何配置 Apollo Client。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-07-16",deps:[],hoistedTags:[],links:[],pathInferred:"/solutions/graphql/client.html",pathLocale:"/",permalink:null,slug:"client",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/graphql/client.md",filePathRelative:"solutions/graphql/client.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/client.html.vue",componentFilePathRelative:"pages/solutions/graphql/client.html.vue",componentFileChunkName:"v-14c956fa",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/client.html.js",dataFilePathRelative:"pages/solutions/graphql/client.html.js",dataFileChunkName:"v-14c956fa",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/graphql/client.html",htmlFilePathRelative:"solutions/graphql/client.html"},{key:"v-90694540",path:"/solutions/graphql/federation-server.html",title:"Apollo Federation 实践",lang:"zh-CN",frontmatter:{title:"Apollo Federation 实践",description:"使用 Apollo Federation 对 BFF 单体服务进行拆分，代码样例。",keywords:["GraphQL","Apollo Federation"],date:"2021-08-02T00:00:00.000Z",key:7,tags:["实践"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"应用架构",slug:"应用架构",children:[]},{level:2,title:"开发拆分后的子服务",slug:"开发拆分后的子服务",children:[{level:3,title:"商品子服务",slug:"商品子服务",children:[]},{level:3,title:"订单子服务",slug:"订单子服务",children:[]}]},{level:2,title:"开发网关（Gateway）",slug:"开发网关-gateway",children:[]},{level:2,title:"总结",slug:"总结",children:[]}],content:"\n上一篇我们介绍了 Apollo Federation 的架构以及一些开发原则，本篇我们来结合代码说明如何借助于 Federation 来拆分单体 BFF 服务。\n\n## 应用架构\n\n在前面的 [BFF 单体服务](./server.md)中，我们定义了两个模型，商品模型和订单模型。本文中，我们划分两个领域，商品域和订单域。这两个域分别由一个服务来承载，加上网关，我们的应用架构如下：\n\n```plantuml\nnode 用户\nnode 网关\nnode 商品服务\nnode 订单服务\n\n用户 --\x3e 网关\n网关 ..> 商品服务\n网关 ..> 订单服务\n```\n\n## 开发拆分后的子服务\n\n### 商品子服务\n\n> 商品服务的所有代码在[这里](https://github.com/everfind/bff-goods-service)，文中只展示关键点。\n\n定义商品服务：\n\n```ts\nimport { Directive, Field, ObjectType } from '@nestjs/graphql';\n\n@ObjectType({ description: '商品信息' })\n@Directive('@key(fields: \"goodsId\")')\nexport class GoodsData {\n  @Field(() => String, { nullable: false, description: '商品 ID' })\n  goodsId: string;\n\n  @Field(() => String, { nullable: false, description: '商品名称' })\n  goodsName: string;\n\n  @Field(() => String, { nullable: true, description: '商品简介' })\n  goodsBrief?: string;\n}\n```\n\n通过 nestjs 的 `Directive` 装饰器，我们使用 Apollo Federation 的 `@key` 指令告诉 Federation 可以使用 `goodsId` 来查询 `GoodsData` 实例信息。\n\n同时我们在 `GoodsResolver` 中添加一个 `ResolveReference`，来实现在 Federation 场景下的查找动作。\n\n```ts\n\n@Resolver(() => GoodsData)\nexport class GoodsResolver {\n  constructor(private readonly goodsService: GoodsService) {}\n\n  // 其他业务代码\n\n  @ResolveReference()\n  resolveReference(reference: {\n    __typename: string;\n    goodsId: string;\n  }): Promise<GoodsData> {\n    return this.goodsService.getGoods({ goodsId: reference.goodsId });\n  }\n}\n```\n\n除了上面的改造以外，我们还需将原来 `src/app.module.ts` 中的 `GraphQLModule` 换成 `GraphQLFederationModule`，其他保持不变。\n\n```ts\n@Module({\n  imports: [\n    GraphQLFederationModule.forRoot({\n      introspection: true, // 生产环境中需要关闭\n      path: '/goods/graphql',\n      autoSchemaFile: true,\n      // 其他配置信息\n    } as GqlModuleOptions),\n  ],\n  controllers: [AppController],\n  providers: [...services, ...resolvers],\n})\nexport class AppModule {}\n```\n\n至此，新的商品子服务就改造完成了。\n\n启动服务。\n\n```bash\nyarn start:dev\n```\n\n访问 `http://localhost:3001/goods/graphql`。\n\n我们可以像使用单体服务一样使用新的商品子服务。\n\n![商品子服务](/solutions/graphql/bff-goods-service-c.gif)\n\n### 订单子服务\n\n> 订单子服务的代码在[这里](https://github.com/everfind/bff-order-service)，文中只展示关键点。\n\n因为订单要引用商品模型，拆分以后，我们需要在订单中定义一下对商品模型的引用。\n\n```ts\nimport { Directive, Field, ObjectType } from '@nestjs/graphql';\n\n@ObjectType({ description: '商品信息' })\n@Directive('@extends')\n@Directive('@key(fields: \"goodsId\")')\nexport class GoodsData {\n  @Field(() => String, { nullable: false, description: '商品 ID' })\n  @Directive('@external')\n  goodsId: string;\n}\n```\n\n通过 `@extends` 指令告诉 Federation `GoodsData` 继承自一个其他服务定义的类型。`@key` 指令告诉 Federation 使用 `goodsId` 作为主键，同时在 `goodsId` 字段上的`@external` 指令告诉 Federation 这个字段也是来自于其他服务定义的。\n\n> 在订单服务中，我们可以在这个 `GoodsData` 上定义订单服务额外增加的字段，此处不做过多说明。关于类型如何定义，Federation 指令如何使用，可以参考 [Federation 文档](https://www.apollographql.com/docs/federation/entities/).\n\n定义好 `GoodsData` 以后，我们需要在订单模型中定义引用这个类型。\n\n```ts\n@ObjectType({ description: '订单数据' })\nexport class OrderData {\n  // 其他字段定义\n\n  @Field(() => GoodsData, { nullable: true, description: '商品信息' })\n  @Directive('@provides(fields: \"goodsId\")')\n  goodsData?: GoodsData;\n}\n```\n\n`@provides` 指令告诉 Federation 订单服务可以提供商品信息的查询。\n\n同时，我们需要对 `OrderResolver` 做一些改造。\n\n```ts\n@Resolver(() => OrderData)\nexport class OrderPropertyResolver {\n  @ResolveField(() => GoodsData, {\n    name: 'goodsData',\n    nullable: true,\n  })\n  goodsData(@Parent() orderData: OrderData): any {\n    return { __typename: 'GoodsData', goodsId: orderData.goodsId };\n  }\n}\n```\n\n在 `goodsData` 方法中，我们不再直接查商品数据库，而是返回一个 Reference 对象，包含两个字段，`__typename` 告诉 Federation 引用的具体的类型名称，`goodsId` 就是我们在商品子服务中通过 `@key` 定义的主键。\n\n我们同样需要对 `src/app.module.ts` 做一些改造。\n\n```ts\n@Module({\n  imports: [\n    HttpModule,\n    GraphQLFederationModule.forRoot({\n      // 其他配置项\n      introspection: true, // 生产环境中需要关闭\n      path: '/order/graphql',\n      autoSchemaFile: true,\n      buildSchemaOptions: {\n        orphanedTypes: [GoodsData],\n      },\n    } as GqlModuleOptions),\n  ],\n  controllers: [AppController],\n  providers: [...services, ...resolvers],\n})\nexport class AppModule {}\n```\n\n我们将 `GraphQLModule` 换成 `GraphQLFederationModule`，同时通过 `buildSchemaOptions` 将 `GoodsData` 标记为其他系统定义的类型。\n\n## 开发网关（Gateway）\n\n子服务只定义了领域内的类型，以及类型间的依赖关系，Apollo Federation 的网关在运行时将会分析查询信息，根据类型间的关系将请求分发到各个子服务上去。\n\n> 网关的完整代码在[这里](https://github.com/everfind/bff-gateway)，本文只针对关键代码做说明。\n\nFederation 网关的代码非常简单，如下：\n\n```ts\nimport { Module } from '@nestjs/common';\nimport { GraphQLGatewayModule } from '@nestjs/graphql';\n\nconst graphqlGatewayModule = GraphQLGatewayModule.forRootAsync({\n  useFactory: async () => ({\n    server: {\n      path: '/bff/graphql',\n    },\n    gateway: {\n      serviceList: [\n        {\n          name: 'goods',\n          url: 'http://localhost:3001/goods/graphql',\n        },\n        {\n          name: 'order',\n          url: 'http://localhost:3002/order/graphql',\n        },\n      ],\n    },\n  }),\n});\n\n@Module({\n  imports: [graphqlGatewayModule],\n})\nexport class AppModule {}\n```\n\n我们通过 `serviceList` 指定了两个子服务。网关在启动后，会根据 `serviceList` 拉取子服务的 schema。\n\n![从网关查数据](/solutions/graphql/bff-gateway-c.gif)\n\n上图中我们可以看出，从网关查询数据与前面单体服务完全相同，客户端完全感知不到差别。\n\n## 总结\n\n本文借助于 NestJS，对如何使用 Apollo Federation 拆分 BFF 单体服务做了样例说明。\n\n我们定义了商品和订单两个子服务，订单服务中引用了商品服务的模型。\n\n我们还定义了一个网关来聚合子服务，并对外提供服务。在网关中我们通过 `serviceList` 来定义服务列表。从工程实践的角度来说，这种方式非常不便，每新增一个服务都需要更改这个配置，下一篇我们来介绍如何解决这个问题。\n",contentRendered:'<p>上一篇我们介绍了 Apollo Federation 的架构以及一些开发原则，本篇我们来结合代码说明如何借助于 Federation 来拆分单体 BFF 服务。</p>\n<h2 id="应用架构" tabindex="-1"><a class="header-anchor" href="#应用架构" aria-hidden="true">#</a> 应用架构</h2>\n<p>在前面的 <RouterLink to="/solutions/graphql/server.html">BFF 单体服务</RouterLink>中，我们定义了两个模型，商品模型和订单模型。本文中，我们划分两个领域，商品域和订单域。这两个域分别由一个服务来承载，加上网关，我们的应用架构如下：</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuShBJqbLU3vbnREExL3stebFMpT3s4-djZsTtFXiJk_JheKGaHVh5ZtjdGeLuOBeKz3LjODfWr0AUdfsg9gHn56CS4ZDIm4w0m00" alt="uml diagram">\n<h2 id="开发拆分后的子服务" tabindex="-1"><a class="header-anchor" href="#开发拆分后的子服务" aria-hidden="true">#</a> 开发拆分后的子服务</h2>\n<h3 id="商品子服务" tabindex="-1"><a class="header-anchor" href="#商品子服务" aria-hidden="true">#</a> 商品子服务</h3>\n<blockquote>\n<p>商品服务的所有代码在<a href="https://github.com/everfind/bff-goods-service" target="_blank" rel="noopener noreferrer">这里<OutboundLink/></a>，文中只展示关键点。</p>\n</blockquote>\n<p>定义商品服务：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Directive<span class="token punctuation">,</span> Field<span class="token punctuation">,</span> ObjectType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">ObjectType</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> description<span class="token operator">:</span> <span class="token string">\'商品信息\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Directive</span></span><span class="token punctuation">(</span><span class="token string">\'@key(fields: "goodsId")\'</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">GoodsData</span> <span class="token punctuation">{</span>\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品 ID\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  goodsId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品名称\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  goodsName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品简介\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  goodsBrief<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>通过 nestjs 的 <code>Directive</code> 装饰器，我们使用 Apollo Federation 的 <code>@key</code> 指令告诉 Federation 可以使用 <code>goodsId</code> 来查询 <code>GoodsData</code> 实例信息。</p>\n<p>同时我们在 <code>GoodsResolver</code> 中添加一个 <code>ResolveReference</code>，来实现在 Federation 场景下的查找动作。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code>\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Resolver</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> GoodsData<span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">GoodsResolver</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> goodsService<span class="token operator">:</span> GoodsService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n  <span class="token comment">// 其他业务代码</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">ResolveReference</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token function">resolveReference</span><span class="token punctuation">(</span>reference<span class="token operator">:</span> <span class="token punctuation">{</span>\n    __typename<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n    goodsId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>GoodsData<span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>goodsService<span class="token punctuation">.</span><span class="token function">getGoods</span><span class="token punctuation">(</span><span class="token punctuation">{</span> goodsId<span class="token operator">:</span> reference<span class="token punctuation">.</span>goodsId <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>除了上面的改造以外，我们还需将原来 <code>src/app.module.ts</code> 中的 <code>GraphQLModule</code> 换成 <code>GraphQLFederationModule</code>，其他保持不变。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  imports<span class="token operator">:</span> <span class="token punctuation">[</span>\n    GraphQLFederationModule<span class="token punctuation">.</span><span class="token function">forRoot</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      introspection<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 生产环境中需要关闭</span>\n      path<span class="token operator">:</span> <span class="token string">\'/goods/graphql\'</span><span class="token punctuation">,</span>\n      autoSchemaFile<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      <span class="token comment">// 其他配置信息</span>\n    <span class="token punctuation">}</span> <span class="token keyword">as</span> GqlModuleOptions<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>AppController<span class="token punctuation">]</span><span class="token punctuation">,</span>\n  providers<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>services<span class="token punctuation">,</span> <span class="token operator">...</span>resolvers<span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>至此，新的商品子服务就改造完成了。</p>\n<p>启动服务。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> start:dev\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>访问 <code>http://localhost:3001/goods/graphql</code>。</p>\n<p>我们可以像使用单体服务一样使用新的商品子服务。</p>\n<p><img src="/solutions/graphql/bff-goods-service-c.gif" alt="商品子服务"></p>\n<h3 id="订单子服务" tabindex="-1"><a class="header-anchor" href="#订单子服务" aria-hidden="true">#</a> 订单子服务</h3>\n<blockquote>\n<p>订单子服务的代码在<a href="https://github.com/everfind/bff-order-service" target="_blank" rel="noopener noreferrer">这里<OutboundLink/></a>，文中只展示关键点。</p>\n</blockquote>\n<p>因为订单要引用商品模型，拆分以后，我们需要在订单中定义一下对商品模型的引用。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Directive<span class="token punctuation">,</span> Field<span class="token punctuation">,</span> ObjectType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">ObjectType</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> description<span class="token operator">:</span> <span class="token string">\'商品信息\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Directive</span></span><span class="token punctuation">(</span><span class="token string">\'@extends\'</span><span class="token punctuation">)</span>\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Directive</span></span><span class="token punctuation">(</span><span class="token string">\'@key(fields: "goodsId")\'</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">GoodsData</span> <span class="token punctuation">{</span>\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品 ID\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Directive</span></span><span class="token punctuation">(</span><span class="token string">\'@external\'</span><span class="token punctuation">)</span>\n  goodsId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>通过 <code>@extends</code> 指令告诉 Federation <code>GoodsData</code> 继承自一个其他服务定义的类型。<code>@key</code> 指令告诉 Federation 使用 <code>goodsId</code> 作为主键，同时在 <code>goodsId</code> 字段上的<code>@external</code> 指令告诉 Federation 这个字段也是来自于其他服务定义的。</p>\n<blockquote>\n<p>在订单服务中，我们可以在这个 <code>GoodsData</code> 上定义订单服务额外增加的字段，此处不做过多说明。关于类型如何定义，Federation 指令如何使用，可以参考 <a href="https://www.apollographql.com/docs/federation/entities/" target="_blank" rel="noopener noreferrer">Federation 文档<OutboundLink/></a>.</p>\n</blockquote>\n<p>定义好 <code>GoodsData</code> 以后，我们需要在订单模型中定义引用这个类型。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">ObjectType</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> description<span class="token operator">:</span> <span class="token string">\'订单数据\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">OrderData</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 其他字段定义</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> GoodsData<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品信息\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Directive</span></span><span class="token punctuation">(</span><span class="token string">\'@provides(fields: "goodsId")\'</span><span class="token punctuation">)</span>\n  goodsData<span class="token operator">?</span><span class="token operator">:</span> GoodsData<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>@provides</code> 指令告诉 Federation 订单服务可以提供商品信息的查询。</p>\n<p>同时，我们需要对 <code>OrderResolver</code> 做一些改造。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Resolver</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> OrderData<span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">OrderPropertyResolver</span> <span class="token punctuation">{</span>\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">ResolveField</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> GoodsData<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">\'goodsData\'</span><span class="token punctuation">,</span>\n    nullable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token function">goodsData</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Parent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> orderData<span class="token operator">:</span> OrderData<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span> __typename<span class="token operator">:</span> <span class="token string">\'GoodsData\'</span><span class="token punctuation">,</span> goodsId<span class="token operator">:</span> orderData<span class="token punctuation">.</span>goodsId <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在 <code>goodsData</code> 方法中，我们不再直接查商品数据库，而是返回一个 Reference 对象，包含两个字段，<code>__typename</code> 告诉 Federation 引用的具体的类型名称，<code>goodsId</code> 就是我们在商品子服务中通过 <code>@key</code> 定义的主键。</p>\n<p>我们同样需要对 <code>src/app.module.ts</code> 做一些改造。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  imports<span class="token operator">:</span> <span class="token punctuation">[</span>\n    HttpModule<span class="token punctuation">,</span>\n    GraphQLFederationModule<span class="token punctuation">.</span><span class="token function">forRoot</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      <span class="token comment">// 其他配置项</span>\n      introspection<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 生产环境中需要关闭</span>\n      path<span class="token operator">:</span> <span class="token string">\'/order/graphql\'</span><span class="token punctuation">,</span>\n      autoSchemaFile<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      buildSchemaOptions<span class="token operator">:</span> <span class="token punctuation">{</span>\n        orphanedTypes<span class="token operator">:</span> <span class="token punctuation">[</span>GoodsData<span class="token punctuation">]</span><span class="token punctuation">,</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span> <span class="token keyword">as</span> GqlModuleOptions<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>AppController<span class="token punctuation">]</span><span class="token punctuation">,</span>\n  providers<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>services<span class="token punctuation">,</span> <span class="token operator">...</span>resolvers<span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>我们将 <code>GraphQLModule</code> 换成 <code>GraphQLFederationModule</code>，同时通过 <code>buildSchemaOptions</code> 将 <code>GoodsData</code> 标记为其他系统定义的类型。</p>\n<h2 id="开发网关-gateway" tabindex="-1"><a class="header-anchor" href="#开发网关-gateway" aria-hidden="true">#</a> 开发网关（Gateway）</h2>\n<p>子服务只定义了领域内的类型，以及类型间的依赖关系，Apollo Federation 的网关在运行时将会分析查询信息，根据类型间的关系将请求分发到各个子服务上去。</p>\n<blockquote>\n<p>网关的完整代码在<a href="https://github.com/everfind/bff-gateway" target="_blank" rel="noopener noreferrer">这里<OutboundLink/></a>，本文只针对关键代码做说明。</p>\n</blockquote>\n<p>Federation 网关的代码非常简单，如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/common\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> GraphQLGatewayModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> graphqlGatewayModule <span class="token operator">=</span> GraphQLGatewayModule<span class="token punctuation">.</span><span class="token function">forRootAsync</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function-variable function">useFactory</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    server<span class="token operator">:</span> <span class="token punctuation">{</span>\n      path<span class="token operator">:</span> <span class="token string">\'/bff/graphql\'</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    gateway<span class="token operator">:</span> <span class="token punctuation">{</span>\n      serviceList<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n          name<span class="token operator">:</span> <span class="token string">\'goods\'</span><span class="token punctuation">,</span>\n          url<span class="token operator">:</span> <span class="token string">\'http://localhost:3001/goods/graphql\'</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token punctuation">{</span>\n          name<span class="token operator">:</span> <span class="token string">\'order\'</span><span class="token punctuation">,</span>\n          url<span class="token operator">:</span> <span class="token string">\'http://localhost:3002/order/graphql\'</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  imports<span class="token operator">:</span> <span class="token punctuation">[</span>graphqlGatewayModule<span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>我们通过 <code>serviceList</code> 指定了两个子服务。网关在启动后，会根据 <code>serviceList</code> 拉取子服务的 schema。</p>\n<p><img src="/solutions/graphql/bff-gateway-c.gif" alt="从网关查数据"></p>\n<p>上图中我们可以看出，从网关查询数据与前面单体服务完全相同，客户端完全感知不到差别。</p>\n<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>\n<p>本文借助于 NestJS，对如何使用 Apollo Federation 拆分 BFF 单体服务做了样例说明。</p>\n<p>我们定义了商品和订单两个子服务，订单服务中引用了商品服务的模型。</p>\n<p>我们还定义了一个网关来聚合子服务，并对外提供服务。在网关中我们通过 <code>serviceList</code> 来定义服务列表。从工程实践的角度来说，这种方式非常不便，每新增一个服务都需要更改这个配置，下一篇我们来介绍如何解决这个问题。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-02",deps:[],hoistedTags:[],links:[{raw:"./server.md",relative:"solutions/graphql/server.md",absolute:"/solutions/graphql/server.md"}],pathInferred:"/solutions/graphql/federation-server.html",pathLocale:"/",permalink:null,slug:"federation-server",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/graphql/federation-server.md",filePathRelative:"solutions/graphql/federation-server.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/federation-server.html.vue",componentFilePathRelative:"pages/solutions/graphql/federation-server.html.vue",componentFileChunkName:"v-90694540",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/federation-server.html.js",dataFilePathRelative:"pages/solutions/graphql/federation-server.html.js",dataFileChunkName:"v-90694540",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/graphql/federation-server.html",htmlFilePathRelative:"solutions/graphql/federation-server.html"},{key:"v-b6d04efc",path:"/solutions/graphql/federation.html",title:"利用 Apollo Federation 对 BFF 进行拆分",lang:"zh-CN",frontmatter:{title:"利用 Apollo Federation 对 BFF 进行拆分",description:"BFF 服务功能越来越多，亟需按领域进行拆分。本文介绍拆分的必要性，以及 Apollo Federation 方案的详细说明。",keywords:["GraphQL","Apollo Federation"],date:"2021-07-25T00:00:00.000Z",key:6,tags:["概念"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"单体服务",slug:"单体服务",children:[{level:3,title:"开发维护成本高",slug:"开发维护成本高",children:[]},{level:3,title:"发布效率低",slug:"发布效率低",children:[]}]},{level:2,title:"Apollo Federation",slug:"apollo-federation",children:[{level:3,title:"Federation 架构",slug:"federation-架构",children:[]},{level:3,title:"开发原则",slug:"开发原则",children:[]}]},{level:2,title:"总结",slug:"总结",children:[]}],content:'\n前面我们使用 GraphQL 搭建了一个 BFF 单体服务。当业务越来越复杂，协作的团队越来越多，单体服务存在很多问题。我们现在介绍一种拆分方法。\n\n## 单体服务\n\n单体服务在业务规模较小的时候，开发效率很高，能够很好的满足业务的迭代诉求。但是，当业务规模逐步增长，特别是需要多个团队一起协作的时候，单体服务的一些问题就逐步显现出来了。\n\n### 开发维护成本高\n\n在业务规模比较小的时候，或者说业务成长初期，两三个人就可以支撑业务需求。当业务逐步扩大，领域模型越来越丰富，BFF 服务体量越来越大，单个开发人员已经无法掌握所有的领域模型，势必要在人员组织上做团队划分。\n\n这时候，单体的 BFF 服务就开始面临多团队协作问题。具体会比现在这几个方面：\n\n- 代码规范问题\n\n  不同的团队代码规范会有差异，揉在一个项目里非常混乱。\n\n- 模型管理问题\n\n  BFF 的模型是对后端模型的映射，多个团队存在模型的重复定义问题。虽然能够通过充分沟通在一定程度上进行缓解，但也额外增加的沟通成本。\n\n- 沟通问题\n\n  BFF 本身负责沟通前端和后端服务。划分团队以后，一次业务需求就需要多个团队一起开发 BFF 层，同一个项目要不停地确认各个分支的开发进度，并 merge 分支才能保证功能的正常。\n\n### 发布效率低\n\n除了对团队的协作问题外，多个需求并行开发，极大概率会导致 BFF 工程的发布冲突，造成发布拥堵问题。\n\n举个例子加以说明。\n\n订单侧进行了一次订单优化的日常更新，不涉及其他领域，在发布的当天，发现 BFF 项目被商品侧的需求占用，需要等待商品侧发布完成之后合并分支才能发布。\n\n发布之前合并了分支，代码发生了变动，从质量的角度来看，就需要再做一次功能的回归验证。\n\n如果在合并代码的时候还发生了代码冲突，那问题就会更加严重，直接给发布的质量带来隐患。\n\n## Apollo Federation\n\n为了解决 BFF 单体服务的种种问题，我们需要对 BFF 进行拆分。\n\n[Apollo Federation](https://www.apollographql.com/docs/federation/) 给出了一个不错的拆分方案。\n\n> 为什么不用 GraphQL Stitching？\n>\n> GraphQL Stitching 也提供了服务拆分、子图 schema 拼接的能力。但是，相较于 Apollo Federation 申明式的 schema 定义、gateway 自动合并子图来说，GraphQL Stitching 需要手动调用 API 合并各个子图，这无疑会增加各服务之间的依赖，导致后期高昂的维护成本。\n\n### Federation 架构\n\n```plantuml\nnode "Web 应用" as A1\nnode "网关 Gateway" as C\nnode "App 应用" as A2\nnode "商品子服务 subgraph" as D1\nnode "订单子服务 subgraph" as D2\nnode "优惠子服务 subgraph" as D3\n\nA1 --\x3e C\nA2 --\x3e C\nC ..> D1\nC ..> D2\nC ..> D3\n```\n\nApollo Federation 架构主要包含两个部分，一个是领域服务，是整个 GraphQL 图中的一个子图。一个是网关，负责将所有的领域服务的子图拼合成一张完整的图。\n\n用户的 GraphQL 请求都将指向网关，再由网关根据请求的 Query 分析，向后面的自服务发起请求，在所有子服务的请求都返回之后，Gateway 将这些请求合并，返回给用户。\n\n使用了 Apollo Federation 以后，中间层被划分为两层。某一子服务负责某一具体领域的能力，定义该领域内的模型图。这样，人员组织的划分与具体的应用项目一一对应。\n\n比如商品小组的同学负责开发维护商品子服务，订单小组的同学负责开发维护订单子服务。一个业务需求过来，就需要评估涉及的业务模块，叫上相关的开发同学一起评审，在评审的同时，开发同学就可以明确子服务之间交互的边界。比如订单如何调用商品等就可以在评审阶段明确。\n\n服务拆分以后，订单服务的发布于商品服务的发布可以实现并行，互不干扰，大大提高了发布效率。\n\nBFF 服务拆分后，Gateway 负责将这些领域定义的模型图拼合成一张整图，对外提供服务。Gateway 的能力与业务无关，不需要随业务迭代，只需要随着技术架构升级迭代即可，更新频次不高。\n\n### 开发原则\n\n- 增量更新\n\nFederation 架构通常不会在业务刚开始的时候就采用，因此就存在一个如何从单体应用升级到 Federation 架构的问题。\n\n我们不建议将原有的单体服务进行一次彻底的重构，来升级到 Federation 架构。我们提倡增量更新，逐步的从原有服务中将子服务拆出来。\n\n比如在一次需求迭代中，我们可以先将比较底层的商品子服务拆出来，独立成子服务上线。之后，在一次需求迭代中，将订单子服务拆出来，同时将查询商品的部分，切换到新的商品子服务上。\n\n- 通过业务领域划分子服务\n\n通常在进行子服务拆分的时候，最直观的方法是通过类型拆分。\n\n比如商品类型定义一个子服务，订单类型定义一个子服务。\n\n这么划分虽然简单明确，但是会导致子服务数量太多。同时类型之间的关系错综复杂，一个业务需求会涉及到非常多的类型，从而导致每个子服务都需要更新。\n\n我们提倡通过领域来划分子服务。商品领域内的模型都划分到商品子服务内。订单领域内的模型都划分到订单子服务内。\n\n这样，业务能力是按领域内聚的，系统内的子服务数量也不会太多，与人员的组织结构可以相对应。\n\n## 总结\n\n本篇我们介绍了单体服务在业务规模逐渐扩大的时候遇到的问题。同时，我们也介绍了 Apollo Federation 的架构，以及在解决单体服务的问题时的一些开发原则。\n',contentRendered:'<p>前面我们使用 GraphQL 搭建了一个 BFF 单体服务。当业务越来越复杂，协作的团队越来越多，单体服务存在很多问题。我们现在介绍一种拆分方法。</p>\n<h2 id="单体服务" tabindex="-1"><a class="header-anchor" href="#单体服务" aria-hidden="true">#</a> 单体服务</h2>\n<p>单体服务在业务规模较小的时候，开发效率很高，能够很好的满足业务的迭代诉求。但是，当业务规模逐步增长，特别是需要多个团队一起协作的时候，单体服务的一些问题就逐步显现出来了。</p>\n<h3 id="开发维护成本高" tabindex="-1"><a class="header-anchor" href="#开发维护成本高" aria-hidden="true">#</a> 开发维护成本高</h3>\n<p>在业务规模比较小的时候，或者说业务成长初期，两三个人就可以支撑业务需求。当业务逐步扩大，领域模型越来越丰富，BFF 服务体量越来越大，单个开发人员已经无法掌握所有的领域模型，势必要在人员组织上做团队划分。</p>\n<p>这时候，单体的 BFF 服务就开始面临多团队协作问题。具体会比现在这几个方面：</p>\n<ul>\n<li>\n<p>代码规范问题</p>\n<p>不同的团队代码规范会有差异，揉在一个项目里非常混乱。</p>\n</li>\n<li>\n<p>模型管理问题</p>\n<p>BFF 的模型是对后端模型的映射，多个团队存在模型的重复定义问题。虽然能够通过充分沟通在一定程度上进行缓解，但也额外增加的沟通成本。</p>\n</li>\n<li>\n<p>沟通问题</p>\n<p>BFF 本身负责沟通前端和后端服务。划分团队以后，一次业务需求就需要多个团队一起开发 BFF 层，同一个项目要不停地确认各个分支的开发进度，并 merge 分支才能保证功能的正常。</p>\n</li>\n</ul>\n<h3 id="发布效率低" tabindex="-1"><a class="header-anchor" href="#发布效率低" aria-hidden="true">#</a> 发布效率低</h3>\n<p>除了对团队的协作问题外，多个需求并行开发，极大概率会导致 BFF 工程的发布冲突，造成发布拥堵问题。</p>\n<p>举个例子加以说明。</p>\n<p>订单侧进行了一次订单优化的日常更新，不涉及其他领域，在发布的当天，发现 BFF 项目被商品侧的需求占用，需要等待商品侧发布完成之后合并分支才能发布。</p>\n<p>发布之前合并了分支，代码发生了变动，从质量的角度来看，就需要再做一次功能的回归验证。</p>\n<p>如果在合并代码的时候还发生了代码冲突，那问题就会更加严重，直接给发布的质量带来隐患。</p>\n<h2 id="apollo-federation" tabindex="-1"><a class="header-anchor" href="#apollo-federation" aria-hidden="true">#</a> Apollo Federation</h2>\n<p>为了解决 BFF 单体服务的种种问题，我们需要对 BFF 进行拆分。</p>\n<p><a href="https://www.apollographql.com/docs/federation/" target="_blank" rel="noopener noreferrer">Apollo Federation<OutboundLink/></a> 给出了一个不错的拆分方案。</p>\n<blockquote>\n<p>为什么不用 GraphQL Stitching？</p>\n<p>GraphQL Stitching 也提供了服务拆分、子图 schema 拼接的能力。但是，相较于 Apollo Federation 申明式的 schema 定义、gateway 自动合并子图来说，GraphQL Stitching 需要手动调用 API 合并各个子图，这无疑会增加各服务之间的依赖，导致后期高昂的维护成本。</p>\n</blockquote>\n<h3 id="federation-架构" tabindex="-1"><a class="header-anchor" href="#federation-架构" aria-hidden="true">#</a> Federation 架构</h3>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuShBJqbLK0fFJL9ukclAyoahb1GIYnKS3Q7Yp_TEVDgwMS4ziIIrFB4IBESCbN8iA43HOWGLVpgrxUdangTh9poRq_kqQw52SMbIUb5YGGPObGlCu1Vh5ZtjdOfB5Soi9tjcF6jUW4kLCHUNew62hguTq4sEHb26iuAUdXt87YZ32COmvd98pKi1UXa0" alt="uml diagram">\n<p>Apollo Federation 架构主要包含两个部分，一个是领域服务，是整个 GraphQL 图中的一个子图。一个是网关，负责将所有的领域服务的子图拼合成一张完整的图。</p>\n<p>用户的 GraphQL 请求都将指向网关，再由网关根据请求的 Query 分析，向后面的自服务发起请求，在所有子服务的请求都返回之后，Gateway 将这些请求合并，返回给用户。</p>\n<p>使用了 Apollo Federation 以后，中间层被划分为两层。某一子服务负责某一具体领域的能力，定义该领域内的模型图。这样，人员组织的划分与具体的应用项目一一对应。</p>\n<p>比如商品小组的同学负责开发维护商品子服务，订单小组的同学负责开发维护订单子服务。一个业务需求过来，就需要评估涉及的业务模块，叫上相关的开发同学一起评审，在评审的同时，开发同学就可以明确子服务之间交互的边界。比如订单如何调用商品等就可以在评审阶段明确。</p>\n<p>服务拆分以后，订单服务的发布于商品服务的发布可以实现并行，互不干扰，大大提高了发布效率。</p>\n<p>BFF 服务拆分后，Gateway 负责将这些领域定义的模型图拼合成一张整图，对外提供服务。Gateway 的能力与业务无关，不需要随业务迭代，只需要随着技术架构升级迭代即可，更新频次不高。</p>\n<h3 id="开发原则" tabindex="-1"><a class="header-anchor" href="#开发原则" aria-hidden="true">#</a> 开发原则</h3>\n<ul>\n<li>增量更新</li>\n</ul>\n<p>Federation 架构通常不会在业务刚开始的时候就采用，因此就存在一个如何从单体应用升级到 Federation 架构的问题。</p>\n<p>我们不建议将原有的单体服务进行一次彻底的重构，来升级到 Federation 架构。我们提倡增量更新，逐步的从原有服务中将子服务拆出来。</p>\n<p>比如在一次需求迭代中，我们可以先将比较底层的商品子服务拆出来，独立成子服务上线。之后，在一次需求迭代中，将订单子服务拆出来，同时将查询商品的部分，切换到新的商品子服务上。</p>\n<ul>\n<li>通过业务领域划分子服务</li>\n</ul>\n<p>通常在进行子服务拆分的时候，最直观的方法是通过类型拆分。</p>\n<p>比如商品类型定义一个子服务，订单类型定义一个子服务。</p>\n<p>这么划分虽然简单明确，但是会导致子服务数量太多。同时类型之间的关系错综复杂，一个业务需求会涉及到非常多的类型，从而导致每个子服务都需要更新。</p>\n<p>我们提倡通过领域来划分子服务。商品领域内的模型都划分到商品子服务内。订单领域内的模型都划分到订单子服务内。</p>\n<p>这样，业务能力是按领域内聚的，系统内的子服务数量也不会太多，与人员的组织结构可以相对应。</p>\n<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>\n<p>本篇我们介绍了单体服务在业务规模逐渐扩大的时候遇到的问题。同时，我们也介绍了 Apollo Federation 的架构，以及在解决单体服务的问题时的一些开发原则。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-07-25",deps:[],hoistedTags:[],links:[],pathInferred:"/solutions/graphql/federation.html",pathLocale:"/",permalink:null,slug:"federation",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/graphql/federation.md",filePathRelative:"solutions/graphql/federation.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/federation.html.vue",componentFilePathRelative:"pages/solutions/graphql/federation.html.vue",componentFileChunkName:"v-b6d04efc",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/federation.html.js",dataFilePathRelative:"pages/solutions/graphql/federation.html.js",dataFileChunkName:"v-b6d04efc",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/graphql/federation.html",htmlFilePathRelative:"solutions/graphql/federation.html"},{key:"v-71ca9b38",path:"/solutions/graphql/graph-is-better-rest.html",title:"GraphQL 是更好的 REST",lang:"zh-CN",frontmatter:{title:"GraphQL 是更好的 REST",description:"对 GraphQL 和 REST 进行对比，说明 GraphQL 的优越性",keywords:["GraphQL"],date:"2021-07-05T00:00:00.000Z",key:3,tags:["概念"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"数据获取",slug:"数据获取",children:[]},{level:2,title:"开发效率",slug:"开发效率",children:[]},{level:2,title:"性能",slug:"性能",children:[]},{level:2,title:"迭代升级",slug:"迭代升级",children:[]},{level:2,title:"细粒度的字段控制",slug:"细粒度的字段控制",children:[]},{level:2,title:"文档能力",slug:"文档能力",children:[]}],content:"\n我们在前面的文章中已经讨论过使用 BFF 的必要性和 GraphQL 的基础知识。本文将对 GraphQL 和传统 REST 进行对比，来说明相较于传统 REST，在 BFF 中使用 GraphQL 的优越性。\n\n## 数据获取\n\n传统的 REST 接口，前端在获取数据的时候，一直存在两个老大难问题，一个是多获取了数据，另一个是少获取了数据。\n\n- 多获取了数据\n\n在传统 REST 接口中，一个接口返回的信息往往会比页面真实需要的数据要多。比如商品详情接口，接口返回的商品信息是必然比页面上展示的信息多的，除非给每个前端页面都定制接口。这就是多获取了数据的问题。\n\n一般情况下，多获取了数据并没有太大的危害。但是，如果数据模型比较复杂，尤其在这个接口中还要聚合其他模型的信息的时候，接口性能、可用性等有时候会被多余的信息所拖累。\n\n还是以商品详情为例。通常情况下，在商品购买页面，我们需要获取尽可能多的商品信息，传统 REST 可以满足页面需求。但是在订单页面中，我们只需要展示商品的简版信息，比如名称、规格、价格等，其他的信息一概不要。这时候，如果商品详情中聚合了其他信息，需要查询其他服务的，在订单页面中就完全没有必要获取这些信息。如果被依赖的服务稳定性较差，也会导致订单页面的稳定性比较差。\n\nGraphQL 很好了解决了这个问题。我们通过 `Query` 明确地告知 BFF 需要哪些数据，BFF 在从下游服务获取这些数据返回给前端。不需要的数据，就不会被获取，减少了不必要的系统调用。\n\n- 少获取了数据\n\n少获取数据，通常表现在列表中。一般在列表接口中，每个列表元素返回的信息都比较简要，而页面上有时候又想展示一些关联的信息。比如商品列表，列表接口中只返回商品的基本信息，如果页面上要展示每个商品的优惠信息的话，需要根据列表返回的信息再调接口获取。\n\n在 GraphQL 中如何解决少获取了数据的问题呢？在 GraphQL 服务端实现中，有个 `Resolver` 的概念，即每个字段都有一个 `Resolver` 函数，GraphQL 在执行的时候，会根据 `Query` 中查询的字段调用每一个 `Resolver` 函数获取这个字段的值。因此，我们只需要在服务实现时定义好每个字段的 `Resolver` 函数即可。比如我们可以给每个商品模型定义一个优惠信息的 `Resolver`，那么在商品列表中的查询中，在 `Query` 上添加这个优惠信息字段，GraphQL 就会自动查询每个商品的优惠信息。\n\n**N+ 1** 问题\n\nN + 1 问题说的就是上面商品列表查询优惠信息的问题。在传统 REST 接口中，如果列表返回 10 条数据，前端就需要在通过 10 次请求查询商品的优惠信息，总共需要 11 次请求。N + 1 问题最大的危害是占用数据库资源太多。如果一次返回 100 个商品，那就需要查询数据库 100 次，很容易耗尽数据库的连接资源。\n\nGraphQL 中通过 [dataloader](https://www.npmjs.com/package/dataloader) 来解决 N + 1 问题。在商品列表的例子中，dataloader 会将这些查询优惠信息的请求合并成一个请求，再将数据库返回的信息分配给每一个商品模型。当然，如果 BFF 不是直接读取数据库，需要后端服务支持批量查询的接口。\n\n## 开发效率\n\n在传统 REST 模式下，页面变化通常需要后端接口跟着做调整，需要前后端之间重新对接口进行约定、联调、发布。这一串动作都是非常耗时的。\n\n在 GraphQL 中，如果页面变化的内容原先系统中模型之间的关系已经建立，那么只需要前端页面调整查询的内容即可，减少了接口约定、联调等流程，同时纯前端静态资源的发布也比后端服务发布要方便很多。\n\n## 性能\n\n通常，一个页面的数据请求不止一个。比如商品详情页，需要商品信息、优惠信息、广告信息等各种数据接口。在传统 REST 接口，我们需要分别调用这些接口获取数据。\n\n在 GraphQL 中，我们可以通过一次请求将这些数据全部都拿到。只需要在 `Query` 中查询多个数据信息即可，GraphQL 会返回多棵 JSON 树。在弱网环境下，GraphQL 可以比传统 REST 获得更好的性能体验。\n\n## 迭代升级\n\n在传统 REST 接口中，我们升级原有的接口都是通过在路径中增加版本号来实现。比如从 `/rest/v1` 升级到 `/rest/v2`。而在 GraphQL 中，我们可以渐进式的实现 API 的升级。\n\n比如在一个影片管理系统中，我们有如下定义：\n\n```graphql\ntype Film {\n  title: String\n  episode: Int\n}\n```\n\n现在我们可以导演信息，我们只添加了导演名称：\n\n```graphql\ntype Film {\n  title: String\n  episode: Int\n  dirctor: String\n}\n```\n\n过段时间，发现需要导演的详细信息：\n\n```graphql\ntype File {\n  title: String\n  episode: Int\n  director: String @deprecated\n  directedBy: Person\n}\ntype Person {\n  name: String\n  directed: [Film!]\n}\n```\n\n通过新添加一个字段 `directedBy` 同时将原来的 `director` 标记为 `deprecated`。GraphQL 的工具会将标记为 `deprecated` 的字段隐藏掉。这样，我们就可以实现 API 的渐进式升级，同时不需要引入版本号。\n\n## 细粒度的字段控制\n\n前面说到，GraphQL 可以实现前端页面按需获取数据。在服务端，GraphQL 依然可以对每个字段进行细粒度的数据收集。因为每个字段都有对应的 `Resolver` 函数，因此我们可以在这些函数中搜集很多信息，比如字段是否还在使用，字段对应的处理性能数据等。\n\n## 文档能力\n\n在上一篇文章中，我们知道 GraphQL 有一个类型系统，我们通过 SDL 定义 Schema。有了 Schema，我们就有了系统内的所有类型信息。相当于一个字典，我们可以按图索骥查询所需数据。实现了代码即文档的效果。\n\n在 GraphQL 的内省模式中，我们可以查到系统支持的所有 `Query` 类型、`Mutation` 类型，以及每个类型的字段说明等信息。避免了 API 文档的维护工作。\n",contentRendered:'<p>我们在前面的文章中已经讨论过使用 BFF 的必要性和 GraphQL 的基础知识。本文将对 GraphQL 和传统 REST 进行对比，来说明相较于传统 REST，在 BFF 中使用 GraphQL 的优越性。</p>\n<h2 id="数据获取" tabindex="-1"><a class="header-anchor" href="#数据获取" aria-hidden="true">#</a> 数据获取</h2>\n<p>传统的 REST 接口，前端在获取数据的时候，一直存在两个老大难问题，一个是多获取了数据，另一个是少获取了数据。</p>\n<ul>\n<li>多获取了数据</li>\n</ul>\n<p>在传统 REST 接口中，一个接口返回的信息往往会比页面真实需要的数据要多。比如商品详情接口，接口返回的商品信息是必然比页面上展示的信息多的，除非给每个前端页面都定制接口。这就是多获取了数据的问题。</p>\n<p>一般情况下，多获取了数据并没有太大的危害。但是，如果数据模型比较复杂，尤其在这个接口中还要聚合其他模型的信息的时候，接口性能、可用性等有时候会被多余的信息所拖累。</p>\n<p>还是以商品详情为例。通常情况下，在商品购买页面，我们需要获取尽可能多的商品信息，传统 REST 可以满足页面需求。但是在订单页面中，我们只需要展示商品的简版信息，比如名称、规格、价格等，其他的信息一概不要。这时候，如果商品详情中聚合了其他信息，需要查询其他服务的，在订单页面中就完全没有必要获取这些信息。如果被依赖的服务稳定性较差，也会导致订单页面的稳定性比较差。</p>\n<p>GraphQL 很好了解决了这个问题。我们通过 <code>Query</code> 明确地告知 BFF 需要哪些数据，BFF 在从下游服务获取这些数据返回给前端。不需要的数据，就不会被获取，减少了不必要的系统调用。</p>\n<ul>\n<li>少获取了数据</li>\n</ul>\n<p>少获取数据，通常表现在列表中。一般在列表接口中，每个列表元素返回的信息都比较简要，而页面上有时候又想展示一些关联的信息。比如商品列表，列表接口中只返回商品的基本信息，如果页面上要展示每个商品的优惠信息的话，需要根据列表返回的信息再调接口获取。</p>\n<p>在 GraphQL 中如何解决少获取了数据的问题呢？在 GraphQL 服务端实现中，有个 <code>Resolver</code> 的概念，即每个字段都有一个 <code>Resolver</code> 函数，GraphQL 在执行的时候，会根据 <code>Query</code> 中查询的字段调用每一个 <code>Resolver</code> 函数获取这个字段的值。因此，我们只需要在服务实现时定义好每个字段的 <code>Resolver</code> 函数即可。比如我们可以给每个商品模型定义一个优惠信息的 <code>Resolver</code>，那么在商品列表中的查询中，在 <code>Query</code> 上添加这个优惠信息字段，GraphQL 就会自动查询每个商品的优惠信息。</p>\n<p><strong>N+ 1</strong> 问题</p>\n<p>N + 1 问题说的就是上面商品列表查询优惠信息的问题。在传统 REST 接口中，如果列表返回 10 条数据，前端就需要在通过 10 次请求查询商品的优惠信息，总共需要 11 次请求。N + 1 问题最大的危害是占用数据库资源太多。如果一次返回 100 个商品，那就需要查询数据库 100 次，很容易耗尽数据库的连接资源。</p>\n<p>GraphQL 中通过 <a href="https://www.npmjs.com/package/dataloader" target="_blank" rel="noopener noreferrer">dataloader<OutboundLink/></a> 来解决 N + 1 问题。在商品列表的例子中，dataloader 会将这些查询优惠信息的请求合并成一个请求，再将数据库返回的信息分配给每一个商品模型。当然，如果 BFF 不是直接读取数据库，需要后端服务支持批量查询的接口。</p>\n<h2 id="开发效率" tabindex="-1"><a class="header-anchor" href="#开发效率" aria-hidden="true">#</a> 开发效率</h2>\n<p>在传统 REST 模式下，页面变化通常需要后端接口跟着做调整，需要前后端之间重新对接口进行约定、联调、发布。这一串动作都是非常耗时的。</p>\n<p>在 GraphQL 中，如果页面变化的内容原先系统中模型之间的关系已经建立，那么只需要前端页面调整查询的内容即可，减少了接口约定、联调等流程，同时纯前端静态资源的发布也比后端服务发布要方便很多。</p>\n<h2 id="性能" tabindex="-1"><a class="header-anchor" href="#性能" aria-hidden="true">#</a> 性能</h2>\n<p>通常，一个页面的数据请求不止一个。比如商品详情页，需要商品信息、优惠信息、广告信息等各种数据接口。在传统 REST 接口，我们需要分别调用这些接口获取数据。</p>\n<p>在 GraphQL 中，我们可以通过一次请求将这些数据全部都拿到。只需要在 <code>Query</code> 中查询多个数据信息即可，GraphQL 会返回多棵 JSON 树。在弱网环境下，GraphQL 可以比传统 REST 获得更好的性能体验。</p>\n<h2 id="迭代升级" tabindex="-1"><a class="header-anchor" href="#迭代升级" aria-hidden="true">#</a> 迭代升级</h2>\n<p>在传统 REST 接口中，我们升级原有的接口都是通过在路径中增加版本号来实现。比如从 <code>/rest/v1</code> 升级到 <code>/rest/v2</code>。而在 GraphQL 中，我们可以渐进式的实现 API 的升级。</p>\n<p>比如在一个影片管理系统中，我们有如下定义：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">type</span> <span class="token class-name">Film</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">title</span><span class="token punctuation">:</span> <span class="token scalar">String</span>\n  <span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>现在我们可以导演信息，我们只添加了导演名称：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">type</span> <span class="token class-name">Film</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">title</span><span class="token punctuation">:</span> <span class="token scalar">String</span>\n  <span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>\n  <span class="token attr-name">dirctor</span><span class="token punctuation">:</span> <span class="token scalar">String</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>过段时间，发现需要导演的详细信息：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">type</span> <span class="token class-name">File</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">title</span><span class="token punctuation">:</span> <span class="token scalar">String</span>\n  <span class="token attr-name">episode</span><span class="token punctuation">:</span> <span class="token scalar">Int</span>\n  <span class="token attr-name">director</span><span class="token punctuation">:</span> <span class="token scalar">String</span> <span class="token directive function">@deprecated</span>\n  <span class="token attr-name">directedBy</span><span class="token punctuation">:</span> <span class="token class-name">Person</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">type</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span>\n  <span class="token attr-name">directed</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Film</span><span class="token operator">!</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>通过新添加一个字段 <code>directedBy</code> 同时将原来的 <code>director</code> 标记为 <code>deprecated</code>。GraphQL 的工具会将标记为 <code>deprecated</code> 的字段隐藏掉。这样，我们就可以实现 API 的渐进式升级，同时不需要引入版本号。</p>\n<h2 id="细粒度的字段控制" tabindex="-1"><a class="header-anchor" href="#细粒度的字段控制" aria-hidden="true">#</a> 细粒度的字段控制</h2>\n<p>前面说到，GraphQL 可以实现前端页面按需获取数据。在服务端，GraphQL 依然可以对每个字段进行细粒度的数据收集。因为每个字段都有对应的 <code>Resolver</code> 函数，因此我们可以在这些函数中搜集很多信息，比如字段是否还在使用，字段对应的处理性能数据等。</p>\n<h2 id="文档能力" tabindex="-1"><a class="header-anchor" href="#文档能力" aria-hidden="true">#</a> 文档能力</h2>\n<p>在上一篇文章中，我们知道 GraphQL 有一个类型系统，我们通过 SDL 定义 Schema。有了 Schema，我们就有了系统内的所有类型信息。相当于一个字典，我们可以按图索骥查询所需数据。实现了代码即文档的效果。</p>\n<p>在 GraphQL 的内省模式中，我们可以查到系统支持的所有 <code>Query</code> 类型、<code>Mutation</code> 类型，以及每个类型的字段说明等信息。避免了 API 文档的维护工作。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-07-05",deps:[],hoistedTags:[],links:[],pathInferred:"/solutions/graphql/graph-is-better-rest.html",pathLocale:"/",permalink:null,slug:"graph-is-better-rest",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/graphql/graph-is-better-rest.md",filePathRelative:"solutions/graphql/graph-is-better-rest.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/graph-is-better-rest.html.vue",componentFilePathRelative:"pages/solutions/graphql/graph-is-better-rest.html.vue",componentFileChunkName:"v-71ca9b38",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/graph-is-better-rest.html.js",dataFilePathRelative:"pages/solutions/graphql/graph-is-better-rest.html.js",dataFileChunkName:"v-71ca9b38",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/graphql/graph-is-better-rest.html",htmlFilePathRelative:"solutions/graphql/graph-is-better-rest.html"},{key:"v-35c59504",path:"/solutions/graphql/graphql.html",title:"快速理解 GraphQL",lang:"zh-CN",frontmatter:{title:"快速理解 GraphQL",description:"对 GraphQL 进行概念和原理性说明",keywords:["GraphQL"],date:"2021-06-29T00:00:00.000Z",key:2,tags:["概念"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"BFF 的遇到的问题",slug:"bff-的遇到的问题",children:[]},{level:2,title:"什么是 GraphQL",slug:"什么是-graphql",children:[]},{level:2,title:"GraphQL 的精髓",slug:"graphql-的精髓",children:[]},{level:2,title:"小结",slug:"小结",children:[]}],content:'\nGraphQL 是一种 API 查询语言，核心特性是数据聚合和裁减。目前被广泛应用在前后端之间，解决客户端灵活使用数据问题。\n\n## BFF 的遇到的问题\n\n在[快速理解 BFF](./bff.md) 中，我们知道构建 BFF 的主要目的是为了应对前端页面的高频变化，同时我们还探讨几种构建 BFF 的方案。\n\n在实践过程中，我们发现，不管是按那种方式构建 BFF 我们都会遇到一个棘手的问题。那就是，随着业务场景越来越多，API 呈爆炸趋势，业务支持效率与人力成线性关系，系统难以支撑业务场景的规模化拓展。同时，核心功能不停迭代，内部逻辑充斥着各种 `if...else...` 判断，系统复杂度极度上升，慢慢的难以维护。\n\n因此，在这种场景多、场景间存在差异的背景下，如何满足场景拓展效率同时能够控制系统的复杂性，就成了我们构建 BFF 索要面临的核心问题\n\n## 什么是 GraphQL\n\nGraphQL 最早由 Facebook 在 2012 年提出，它是一种查询语言，用于描述客户端-服务器应用中数据模型的功能和要求。同时 GraphQL 还是一个服务端运行时，基于一个事先定义好的类型系统来为客户端的查询提供符合要求的数据。\n\n从物理上看，GraphQL 分为服务端运行时和查询客户端。从逻辑上看，GraphQL 是一套由类型系统定义的 schema 或者说类型。我们通过[Schema 定义语言](https://graphql.org/learn/schema/)（Schema Definition Language, SDL）来定义系统中的 schema。\n\n比如我们定义一个 `Persion` 类型：\n\n```graphql\ntype Person {\n  name: String!\n  age: Int!\n}\n```\n\n这个类型有两个字段，`name` 和 `age`，分别是字符串和整型，感叹号表示该字段是必须的。定义类型间的依赖关系也非常简单。\n\n比如再定义一个 `Post` 类型：\n\n```graphql\ntype Post {\n  title: String!\n  author: Person!\n}\n```\n\n`Post` 的 `author` 字段是 `Persion` 类型。同时，`Persion` 中也可以添加 `posts` 信息：\n\n```graphql\ntype Person {\n  name: String!\n  age: Int!\n  posts: [Post!]!\n}\n```\n\n上面的例子，我们定义了两个类型，并建立了这两个类型间的关联关系。\n\n通过上面的方法，我们可以在系统中定义任意业务类型，同时建立类型间的关系。\n\n有了这些类型，我们就可以定义查询（Query）和修改（Mutation）来操作这些类型。\n\nGraphQL 的查询非常直接，所查即所得。比如我们要查 `Person` 列表信息，则可以进行如下查询：\n\n```graphql\n{\n  personList {\n    name\n  }\n}\n```\n\n则系统会返回：\n\n```json\n{\n  "personList": [\n    {\n      "name": "张三"\n    }\n  ]\n}\n```\n\n如果我们要查询更多的 `Person` 信息，只需要在查询语句中添加要查询的字段即可：\n\n```graphql\n{\n  personList {\n    name\n    age\n    posts {\n      title\n    }\n  }\n}\n```\n\n系统会返回：\n\n```json\n{\n  "personList": [\n    {\n      "name": "张三",\n      "age": 21,\n      "posts": [\n        {\n          "title": "什么是 GraphQL？"\n        }\n      ]\n    }\n  ]\n}\n```\n\n按照 GraphQL 的定义，我们查询任何我们需要的信息，同时系统也只会返回这些信息，没有任何冗余。同时，我们应该注意到，`Post` 类型中还有 `Person` 类型的字段，理论上我们可以无限递归查询下去。\n\n上面的例子展示了如何查询数据，要实现这个查询能力，我们还需要定义查询类型：\n\n```graphql\ntype Query {\n  personList: [Person!]!\n}\n```\n\n有查询就会有修改，我们也需要定义修改类型：\n\n```graphql\ntype Mutation {\n  createPersion(name: String!, age: Int!): Person!\n}\n```\n\n> 括号内的是参数，查询同理也支持传入参数。\n\n`Query` 和 `Mutation` 这两个类型比较特殊，是 GraphQL 的保留类型，用来定义系统内有哪些查询和修改操作。\n\n规整一下，在我们这个例子中，我们的 schema 为：\n\n```graphql\ntype Query {\n  personList: [Person!]!\n}\n\ntype Mutation {\n  createPersion(name: String!, age: Int!): Person!\n}\n\ntype Person {\n  name: String!\n  age: Int!\n  posts: [Post!]!\n}\n\ntype Post {\n  title: String!\n  author: Person!\n}\n```\n\n定义好了 schema 以后，我们就可以通过客户端和运行时来进行数据的聚合和裁减了。\n\n除了最基本的 `Query` 和 `Mutation` 以外，GraphQL 还提供了[Directive (指令)](https://graphql.org/learn/queries/#directives) ，用来实现动态查询。即通过指令可以实现同一个 `Query`，在不同场景下查询不同的数据，用于精细化的场景控制。\n\n## GraphQL 的精髓\n\nGraphQL 通过类型定义的方式，构建了系统内各个模型之间的关系，形成了一张关系图。这也是 GraphQL 的精髓。\n\n通常，我们一次数据请求返回的数据都是树形结构，JSON 就是典型的树形结构。那为什么我们还需要定义一张图呢？\n\n在传统 REST 场景下，一次数据请求返回的数据，后端服务都需要构建一棵树。从根节点到叶子节点，所有信息都需要按照页面的要求来。如下图所以，如果页面发生变化，则需要需改接口，生成新的树。\n\n```plantuml\nnode A\nnode B\nnode C\nnode D\n\nA --\x3e B\nA --\x3e C\nA --\x3e D\n```\n\n在 GraphQL 中，系统里预先已经有了一张图，这张图里描述了任意模型间的关系，理论上我们可以从任何节点触发构建出来任意棵各种各样的树。换句话说，页面可以在这张图里构建任何它需要的数据。\n\n如下图所示，我们不需要后端接口改动，就可以实现各种数据查询。\n\n```plantuml\nnode A\nnode B\nnode C\nnode D\n\nA --\x3e B\nA --\x3e C\nA --\x3e D\nB --\x3e D\nC --\x3e D\nB --\x3e C\n```\n\n前面的例子我们并不能体会到图的巨大价值。如果在社交应用中，比如 Facebook，我们需要查询用户的好友的好友的好友的好友的好友，在传统 REST API 中，我们可以说没有什么好的解法。在 GraphQL 中，我们却跟普通查询一样简单。\n\n```graphql\nquery PersonWithFriends {\n  persion {\n    name\n    friends {\n      name {\n        friends {\n          name\n          friends {\n            name\n            friends {\n              name\n              friends {\n                name\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## 小结\n\n本文主要对 GraphQL 进行概念上的介绍。GraphQL 主要帮助我们解决页面的高频变化给 BFF 层带来的挑战问题。\n\n通过类型系统，将系统中模型之间的关系预先定义清楚，形成一张关系图。再根据页面的实际需要，从这张图中查找生成数据。\n\n使用了 GraphQL 以后，数据结构化清晰。所见即所得，输入和输出结构一致，前端需要什么数据字段，就在查询上填写什么字段，同时支持多层级结构，也可以平级展现，由调用方根据业务决定合适的输出形式。\n\n同时，BFF 还可以进行精细化场景控制。即便是类似的场景，需要的数据也可能不完全相同，指令可以实现这样的精细化控制。graphql 中没有一个数据是多余的\n',contentRendered:'<p>GraphQL 是一种 API 查询语言，核心特性是数据聚合和裁减。目前被广泛应用在前后端之间，解决客户端灵活使用数据问题。</p>\n<h2 id="bff-的遇到的问题" tabindex="-1"><a class="header-anchor" href="#bff-的遇到的问题" aria-hidden="true">#</a> BFF 的遇到的问题</h2>\n<p>在<RouterLink to="/solutions/graphql/bff.html">快速理解 BFF</RouterLink> 中，我们知道构建 BFF 的主要目的是为了应对前端页面的高频变化，同时我们还探讨几种构建 BFF 的方案。</p>\n<p>在实践过程中，我们发现，不管是按那种方式构建 BFF 我们都会遇到一个棘手的问题。那就是，随着业务场景越来越多，API 呈爆炸趋势，业务支持效率与人力成线性关系，系统难以支撑业务场景的规模化拓展。同时，核心功能不停迭代，内部逻辑充斥着各种 <code>if...else...</code> 判断，系统复杂度极度上升，慢慢的难以维护。</p>\n<p>因此，在这种场景多、场景间存在差异的背景下，如何满足场景拓展效率同时能够控制系统的复杂性，就成了我们构建 BFF 索要面临的核心问题</p>\n<h2 id="什么是-graphql" tabindex="-1"><a class="header-anchor" href="#什么是-graphql" aria-hidden="true">#</a> 什么是 GraphQL</h2>\n<p>GraphQL 最早由 Facebook 在 2012 年提出，它是一种查询语言，用于描述客户端-服务器应用中数据模型的功能和要求。同时 GraphQL 还是一个服务端运行时，基于一个事先定义好的类型系统来为客户端的查询提供符合要求的数据。</p>\n<p>从物理上看，GraphQL 分为服务端运行时和查询客户端。从逻辑上看，GraphQL 是一套由类型系统定义的 schema 或者说类型。我们通过<a href="https://graphql.org/learn/schema/" target="_blank" rel="noopener noreferrer">Schema 定义语言<OutboundLink/></a>（Schema Definition Language, SDL）来定义系统中的 schema。</p>\n<p>比如我们定义一个 <code>Persion</code> 类型：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">type</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>\n  <span class="token attr-name">age</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个类型有两个字段，<code>name</code> 和 <code>age</code>，分别是字符串和整型，感叹号表示该字段是必须的。定义类型间的依赖关系也非常简单。</p>\n<p>比如再定义一个 <code>Post</code> 类型：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">type</span> <span class="token class-name">Post</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">title</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>\n  <span class="token attr-name">author</span><span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token operator">!</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>Post</code> 的 <code>author</code> 字段是 <code>Persion</code> 类型。同时，<code>Persion</code> 中也可以添加 <code>posts</code> 信息：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">type</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>\n  <span class="token attr-name">age</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span>\n  <span class="token attr-name">posts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Post</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面的例子，我们定义了两个类型，并建立了这两个类型间的关联关系。</p>\n<p>通过上面的方法，我们可以在系统中定义任意业务类型，同时建立类型间的关系。</p>\n<p>有了这些类型，我们就可以定义查询（Query）和修改（Mutation）来操作这些类型。</p>\n<p>GraphQL 的查询非常直接，所查即所得。比如我们要查 <code>Person</code> 列表信息，则可以进行如下查询：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token punctuation">{</span>\n  <span class="token object">personList</span> <span class="token punctuation">{</span>\n    <span class="token property">name</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>则系统会返回：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"personList"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"张三"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果我们要查询更多的 <code>Person</code> 信息，只需要在查询语句中添加要查询的字段即可：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token punctuation">{</span>\n  <span class="token object">personList</span> <span class="token punctuation">{</span>\n    <span class="token property">name</span>\n    <span class="token property">age</span>\n    <span class="token object">posts</span> <span class="token punctuation">{</span>\n      <span class="token property">title</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>系统会返回：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"personList"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>\n      <span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">21</span><span class="token punctuation">,</span>\n      <span class="token property">"posts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n          <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"什么是 GraphQL？"</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>按照 GraphQL 的定义，我们查询任何我们需要的信息，同时系统也只会返回这些信息，没有任何冗余。同时，我们应该注意到，<code>Post</code> 类型中还有 <code>Person</code> 类型的字段，理论上我们可以无限递归查询下去。</p>\n<p>上面的例子展示了如何查询数据，要实现这个查询能力，我们还需要定义查询类型：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">personList</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Person</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>有查询就会有修改，我们也需要定义修改类型：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">type</span> <span class="token class-name">Mutation</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">createPersion</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">,</span> <span class="token attr-name">age</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token operator">!</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote>\n<p>括号内的是参数，查询同理也支持传入参数。</p>\n</blockquote>\n<p><code>Query</code> 和 <code>Mutation</code> 这两个类型比较特殊，是 GraphQL 的保留类型，用来定义系统内有哪些查询和修改操作。</p>\n<p>规整一下，在我们这个例子中，我们的 schema 为：</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">personList</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Person</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">type</span> <span class="token class-name">Mutation</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">createPersion</span><span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span><span class="token punctuation">,</span> <span class="token attr-name">age</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token operator">!</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">type</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>\n  <span class="token attr-name">age</span><span class="token punctuation">:</span> <span class="token scalar">Int</span><span class="token operator">!</span>\n  <span class="token attr-name">posts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Post</span><span class="token operator">!</span><span class="token punctuation">]</span><span class="token operator">!</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">type</span> <span class="token class-name">Post</span> <span class="token punctuation">{</span>\n  <span class="token attr-name">title</span><span class="token punctuation">:</span> <span class="token scalar">String</span><span class="token operator">!</span>\n  <span class="token attr-name">author</span><span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token operator">!</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>定义好了 schema 以后，我们就可以通过客户端和运行时来进行数据的聚合和裁减了。</p>\n<p>除了最基本的 <code>Query</code> 和 <code>Mutation</code> 以外，GraphQL 还提供了<a href="https://graphql.org/learn/queries/#directives" target="_blank" rel="noopener noreferrer">Directive (指令)<OutboundLink/></a> ，用来实现动态查询。即通过指令可以实现同一个 <code>Query</code>，在不同场景下查询不同的数据，用于精细化的场景控制。</p>\n<h2 id="graphql-的精髓" tabindex="-1"><a class="header-anchor" href="#graphql-的精髓" aria-hidden="true">#</a> GraphQL 的精髓</h2>\n<p>GraphQL 通过类型定义的方式，构建了系统内各个模型之间的关系，形成了一张关系图。这也是 GraphQL 的精髓。</p>\n<p>通常，我们一次数据请求返回的数据都是树形结构，JSON 就是典型的树形结构。那为什么我们还需要定义一张图呢？</p>\n<p>在传统 REST 场景下，一次数据请求返回的数据，后端服务都需要构建一棵树。从根节点到叶子节点，所有信息都需要按照页面的要求来。如下图所以，如果页面发生变化，则需要需改接口，生成新的树。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuShBJqbLS8HGJX3A6KAvS74vAkZgsW658RGpb7RXSaZDIm5g1W00" alt="uml diagram">\n<p>在 GraphQL 中，系统里预先已经有了一张图，这张图里描述了任意模型间的关系，理论上我们可以从任何节点触发构建出来任意棵各种各样的树。换句话说，页面可以在这张图里构建任何它需要的数据。</p>\n<p>如下图所示，我们不需要后端接口改动，就可以实现各种数据查询。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuShBJqbLS8HGJX3A6KAvS74vAkZgsW658RGpb7RXSeBIpYXyPow7rBmKeA40" alt="uml diagram">\n<p>前面的例子我们并不能体会到图的巨大价值。如果在社交应用中，比如 Facebook，我们需要查询用户的好友的好友的好友的好友的好友，在传统 REST API 中，我们可以说没有什么好的解法。在 GraphQL 中，我们却跟普通查询一样简单。</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">query</span> <span class="token definition-query function">PersonWithFriends</span> <span class="token punctuation">{</span>\n  <span class="token object">persion</span> <span class="token punctuation">{</span>\n    <span class="token property">name</span>\n    <span class="token object">friends</span> <span class="token punctuation">{</span>\n      <span class="token object">name</span> <span class="token punctuation">{</span>\n        <span class="token object">friends</span> <span class="token punctuation">{</span>\n          <span class="token property">name</span>\n          <span class="token object">friends</span> <span class="token punctuation">{</span>\n            <span class="token property">name</span>\n            <span class="token object">friends</span> <span class="token punctuation">{</span>\n              <span class="token property">name</span>\n              <span class="token object">friends</span> <span class="token punctuation">{</span>\n                <span class="token property">name</span>\n              <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>本文主要对 GraphQL 进行概念上的介绍。GraphQL 主要帮助我们解决页面的高频变化给 BFF 层带来的挑战问题。</p>\n<p>通过类型系统，将系统中模型之间的关系预先定义清楚，形成一张关系图。再根据页面的实际需要，从这张图中查找生成数据。</p>\n<p>使用了 GraphQL 以后，数据结构化清晰。所见即所得，输入和输出结构一致，前端需要什么数据字段，就在查询上填写什么字段，同时支持多层级结构，也可以平级展现，由调用方根据业务决定合适的输出形式。</p>\n<p>同时，BFF 还可以进行精细化场景控制。即便是类似的场景，需要的数据也可能不完全相同，指令可以实现这样的精细化控制。graphql 中没有一个数据是多余的</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-06-29",deps:[],hoistedTags:[],links:[{raw:"./bff.md",relative:"solutions/graphql/bff.md",absolute:"/solutions/graphql/bff.md"}],pathInferred:"/solutions/graphql/graphql.html",pathLocale:"/",permalink:null,slug:"graphql",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/graphql/graphql.md",filePathRelative:"solutions/graphql/graphql.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/graphql.html.vue",componentFilePathRelative:"pages/solutions/graphql/graphql.html.vue",componentFileChunkName:"v-35c59504",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/graphql.html.js",dataFilePathRelative:"pages/solutions/graphql/graphql.html.js",dataFileChunkName:"v-35c59504",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/graphql/graphql.html",htmlFilePathRelative:"solutions/graphql/graphql.html"},{key:"v-8b04edb2",path:"/solutions/graphql/schema-composition.html",title:"Schema 合成管理系统",lang:"zh-CN",frontmatter:{title:"Schema 合成管理系统",description:"采用 Apollo Federation 以后，需要对子服务的 Schema 做合成和管理，以及一些工程问题需要解决。我们通过一个独立的 Schema 合成管理系统来解决。",keywords:["GraphQL","Apollo Federation","Schema"],date:"2021-08-03T00:00:00.000Z",key:8,tags:["实践","概念"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"Schema 的合成校验",slug:"schema-的合成校验",children:[]},{level:2,title:"数据字段设计",slug:"数据字段设计",children:[]},{level:2,title:"与 CI/CD 系统的交互",slug:"与-ci-cd-系统的交互",children:[{level:3,title:"子服务构建时推送 Schema",slug:"子服务构建时推送-schema",children:[]},{level:3,title:"子服务启动时确定 Schema 是否合法",slug:"子服务启动时确定-schema-是否合法",children:[]}]},{level:2,title:"网关拉取 Schema",slug:"网关拉取-schema",children:[]},{level:2,title:"总结",slug:"总结",children:[]}],content:'\n上一篇我们在说网关的时候，遗留了一个问题，就是通过 `serviceList` 配置子服务无法实现动态更新。同时，各个子服务的 Schema 在合成的时候可能会出错，比如类型重复定义等。\n\n因此，我们需要一个独立的 Schema 合成管理系统来处理 Schema 的合成校验、不同环境的隔离、CI/CD 等工程问题。\n\n首先要说明的是，Apollo 官方提供了一个 [Apollo Studio](https://www.apollographql.com/docs/studio/) 解决方案，可以解决我们本文讨论的问题。缺点是没有提供自托管（self host）方案，需要将 schema 上传到 Apollo 的服务中。\n\n本文来探讨实现一个 Schema 合成管理系统。\n\n在我们这个系统中，存储各个子服务的 Schema，同时提供 Schema 的合并校验能力，将合并后的 Schema 提供给网关使用。\n\n通常来说，服务部署都会依赖 CI/CD 来实现。因此，我们的 Schema 合成管理系统应该与 CI/CD 对接，而不是手动上传 Schema。\n\n## Schema 的合成校验\n\n在子服务中，我们可以通过如何 GraphQL 查询获取子服务的 Schema 信息。\n\n```graphql\nquery SDL {\n  _service {\n    sdl\n  }\n}\n```\n\n在上传到 Schema 合成管理系统中后，可以通过如下方法校验各个子服务的 Schema 是否合法。\n\n```ts\nimport { parse } from \'graphql\';\nimport { composeAndValidate } from \'@apollo/federation\';\n\n// serviceList 为查到的所有子服务的 Schema 信息\nconst serviceDefinitions = [\n  {\n    typeDefs: parse(service1.sdl),\n    name: service1.name,\n  },\n  {\n    typeDefs: parse(service2.sdl),\n    name: service2.name,\n  }\n];\n\n// 获取合成结果\nconst validateResult = composeAndValidate(serviceDefinitions);\n```\n\n## 数据字段设计\n\n知道如何获取子服务的 Schema 以及如何进行校验之后，我们来定义系统的数据库表。\n\n首先定义一张存储各个子服务信息的表。\n\n```plantuml\nobject Service {\n  id = 123\n  name = "bff-goods-service"\n  desc = "商品中间层服务"\n  tag = ["userend", "backend"]\n  endpoint = "/goods/graphql"\n}\n```\n\n`tag` 字段可以给每个服务打上不同的标签，方便后续管理。\n\n再来定义每个服务的 Schema 信息表。\n\n```plantuml\nobject SDL {\n  id = 123\n  service_name = "bff-goods-service"\n  version = "git_commit_hash"\n  content = "sdl content"\n  operator = "git commiter"\n}\n```\n\n在 SDL 表中，除了记录 Schema 的 `content` 字段以外，我们使用 `git_commit_hash` 来作为每次发布的版本号，同时记录提交人，方便后续问题的追踪。\n\n为了方便网关拉取合成后的数据，我们单独定义一张表记录合成后的各服务 Schema 信息。\n\n```plantuml\nobject Running_Config {\n  id = 123\n  service_name = "bff-goods-service"\n  version = "git_commit_hash"\n  env = "pro"\n}\n\nnote "只有校验通过以后才会更新环境标" as ENV_NOTE\nRunning_Config -- ENV_NOTE\n```\n\n不同的环境都会有网关，因此通过 `env` 字段记录环境。\n\n## 与 CI/CD 系统的交互\n\n前面说到，Schema 合成管理系统应该与 CI/CD 对接，杜绝个人上传 Schema 的操作。因此，我们需要定义与 CI/CD 的交过流程。\n\n### 子服务构建时推送 Schema\n\n如下是子服务构建时与 Schema 合成管理系统的交互时序图。\n\n```plantuml\nautonumber\n\nparticipant "CI" as CI\nparticipant "Schema 合成管理系统" as SIS\n\nactivate CI\n\nCI -> CI: 构建生成 SDL\n\nactivate SIS\n\nCI -> SIS: 上传 SDL  + 版本号\nSIS --\x3e CI\n\nCI -> CI: 确定构建成功或者失败\n```\n### 子服务启动时确定 Schema 是否合法\n\n如下是子服务启动时与 Schema 合成管理系统的交互时序图。\n\n```plantuml\nautonumber\n\nparticipant "子服务" as Service\nparticipant "Schema 合成管理系统" as SIS\n\nactivate Service\n\nService -> SIS: 环境标 + 版本号 + 服务名称\n\nactivate SIS\n\nSIS -> SIS: 找到对应版本号的 SDL 进行校验\nnote right of SIS: 与其他同环境的 service sdl 进行校验\n\nSIS -> Service: 返回结果\n\ndeactivate SIS\n\nService -> Service: 确定启动成功或者失败\n```\n\n之所以要在子服务启动时才校验 Schema 是否合法，是因为服务部署需要考虑环境，而 CI 在构建打包的时候应该与环境无关，因此，我们在服务启动时做校验。\n\n## 网关拉取 Schema\n\n网关是对外提供服务的，需要拉取最新可用的全部 Schema。前面的设计中，Schema 合成管理系统的 `Running_Config` 表记录了当前可用的所有子服务的 Schema。网关只需要从 Schema 合成管理系统中拉取这个信息就可以了。\n\n```plantuml\nautonumber\n\nparticipant "Gateway" as GW\nparticipant "Schema 合成管理系统" as SIS\n\nactivate GW\n\nGW -> SIS: 标签 + 环境\n\nactivate SIS\n\nSIS -> SIS: 校验 SDL\nnote right of SIS: 满足标签的所有服务的 SDL 进行校验\n\nSIS -> GW: 返回配置信息\ndeactivate SIS\n\nGW -> GW: 更新配置信息\n```\n\n在拉取到配置以后，可以通过如下方式实现自动更新网关的 Schema 信息。\n\n```ts\nconst graphqlGatewayModule = GraphQLGatewayModule.forRootAsync({\n  useFactory: async () => ({\n    server: {\n      // 其他配置项\n      path: \'/bff/graphql\',\n    },\n    gateway: {\n      // 一分钟轮询时间\n      experimental_pollInterval: 60 * 1000,\n      experimental_updateServiceDefinitions: updateServicesDefinitions,\n    }\n  }),\n});\n```\n我们将原来的 `serviceList` 换成 `updateServicesDefinitions`，而 `updateServicesDefinitions` 负责从 Schema 合成管理系统拉取最新的 Schema 信息返回给网关。\n\n```ts\nasync function updateServicesDefinitions() {\n  const data = await fetch(\'https://gateway-running-config-endpoint\')\n  const serviceDefinitions = data.map(({ name, url, sdl }) => ({\n    typeDefs: parse(sdl),\n    name,\n    url,\n  }));\n\n  return {\n    serviceDefinitions,\n    isNewSchema: true,\n  };\n}\n```\n\n通过这个方法就可以实现网关自动拉取最新的 Schema 信息了。\n\n## 总结\n\n我们先探索了获取子服务 Schema，并进行合成校验的方法，这是构建 Schema 合成管理系统的技术基石。然后我们设计了实现最简功能所需的数据库表。\n\n完成了 Schema 合成管理系统的内部设计以后，我们对 CI/CD 以及网关如何与 Schema 合成管理系统交互做了定义和说明。\n',contentRendered:'<p>上一篇我们在说网关的时候，遗留了一个问题，就是通过 <code>serviceList</code> 配置子服务无法实现动态更新。同时，各个子服务的 Schema 在合成的时候可能会出错，比如类型重复定义等。</p>\n<p>因此，我们需要一个独立的 Schema 合成管理系统来处理 Schema 的合成校验、不同环境的隔离、CI/CD 等工程问题。</p>\n<p>首先要说明的是，Apollo 官方提供了一个 <a href="https://www.apollographql.com/docs/studio/" target="_blank" rel="noopener noreferrer">Apollo Studio<OutboundLink/></a> 解决方案，可以解决我们本文讨论的问题。缺点是没有提供自托管（self host）方案，需要将 schema 上传到 Apollo 的服务中。</p>\n<p>本文来探讨实现一个 Schema 合成管理系统。</p>\n<p>在我们这个系统中，存储各个子服务的 Schema，同时提供 Schema 的合并校验能力，将合并后的 Schema 提供给网关使用。</p>\n<p>通常来说，服务部署都会依赖 CI/CD 来实现。因此，我们的 Schema 合成管理系统应该与 CI/CD 对接，而不是手动上传 Schema。</p>\n<h2 id="schema-的合成校验" tabindex="-1"><a class="header-anchor" href="#schema-的合成校验" aria-hidden="true">#</a> Schema 的合成校验</h2>\n<p>在子服务中，我们可以通过如何 GraphQL 查询获取子服务的 Schema 信息。</p>\n<div class="language-graphql ext-graphql line-numbers-mode"><pre v-pre class="language-graphql"><code><span class="token keyword">query</span> <span class="token constant">SDL</span> <span class="token punctuation">{</span>\n  <span class="token object">_service</span> <span class="token punctuation">{</span>\n    <span class="token property">sdl</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在上传到 Schema 合成管理系统中后，可以通过如下方法校验各个子服务的 Schema 是否合法。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> parse <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'graphql\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> composeAndValidate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@apollo/federation\'</span><span class="token punctuation">;</span>\n\n<span class="token comment">// serviceList 为查到的所有子服务的 Schema 信息</span>\n<span class="token keyword">const</span> serviceDefinitions <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token punctuation">{</span>\n    <span class="token keyword">type</span>Defs<span class="token operator">:</span> <span class="token function">parse</span><span class="token punctuation">(</span>service1<span class="token punctuation">.</span>sdl<span class="token punctuation">)</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> service1<span class="token punctuation">.</span>name<span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span>\n    <span class="token keyword">type</span>Defs<span class="token operator">:</span> <span class="token function">parse</span><span class="token punctuation">(</span>service2<span class="token punctuation">.</span>sdl<span class="token punctuation">)</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> service2<span class="token punctuation">.</span>name<span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 获取合成结果</span>\n<span class="token keyword">const</span> validateResult <span class="token operator">=</span> <span class="token function">composeAndValidate</span><span class="token punctuation">(</span>serviceDefinitions<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="数据字段设计" tabindex="-1"><a class="header-anchor" href="#数据字段设计" aria-hidden="true">#</a> 数据字段设计</h2>\n<p>知道如何获取子服务的 Schema 以及如何进行校验之后，我们来定义系统的数据库表。</p>\n<p>首先定义一张存储各个子服务信息的表。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuSfFoafDBb48JYqgoqnELQZcKb38J56mLJ0qCWOoyn9pKu4SfQIqDDtq_FoKOjrYY48be6HAQd4oIFBfrBQdankVx5ZxSlgMfnkRditfVTgr4AIW934TA1-jL0hKb9gNegG3D2WnEHl4Z0LA0-c2_Coy4f0P-c3JzTEB4Wio2dEKk6gv783IG0S20000" alt="uml diagram">\n<p><code>tag</code> 字段可以给每个服务打上不同的标签，方便后续管理。</p>\n<p>再来定义每个服务的 Schema 信息表。</p>\n<img src="https://www.plantuml.com/plantuml/svg/DSux3i8m30RWFQUmidS0PgGEZ6mSe4eJjmrgOcIxNH1tnn5bykFpBxaN3QnRMHsDJumAZziTtWuW9xZ2wNonLf3t776eeQ0j_JXDtKoKf3l4sz6EB9bgypdh4AaKAqkGfMcagbYrgQJrFpQX5t9GuYC8lo2oTn_NOqtssXS0" alt="uml diagram">\n<p>在 SDL 表中，除了记录 Schema 的 <code>content</code> 字段以外，我们使用 <code>git_commit_hash</code> 来作为每次发布的版本号，同时记录提交人，方便后续问题的追踪。</p>\n<p>为了方便网关拉取合成后的数据，我们单独定义一张表记录合成后的各服务 Schema 信息。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuSfFoafDBb48AitBoynBZtVEpqlBJ5Uevb9Go4nHi5KmD386CejJYyeoarFZyn9pKu62IabfQRhf-VafnRfG6IMWehBKekBC_3oGV7fcINnoVcukaCf8BCu0oQRcbO5a2ehobRXgkRZoyajI5PIUzgzwDgVpsOA5BrVrl6oOzM9_-vFTIvzEw7lMsVjapwndixSycxRXUT_wfukQdoreLr98B5PmzGkBz_CFSUL2Sx2kBaBA8JKl1UWr0000" alt="uml diagram">\n<p>不同的环境都会有网关，因此通过 <code>env</code> 字段记录环境。</p>\n<h2 id="与-ci-cd-系统的交互" tabindex="-1"><a class="header-anchor" href="#与-ci-cd-系统的交互" aria-hidden="true">#</a> 与 CI/CD 系统的交互</h2>\n<p>前面说到，Schema 合成管理系统应该与 CI/CD 对接，杜绝个人上传 Schema 的操作。因此，我们需要定义与 CI/CD 的交过流程。</p>\n<h3 id="子服务构建时推送-schema" tabindex="-1"><a class="header-anchor" href="#子服务构建时推送-schema" aria-hidden="true">#</a> 子服务构建时推送 Schema</h3>\n<p>如下是子服务构建时与 Schema 合成管理系统的交互时序图。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuKeiBSdFAyrDIYtYuYe0YcKcPnOavfKeA3bxAYaa5YiuUw8A1oTdfEOcAZoTqF6iOyBpTGkVJsXxlddtyztpmQg3FOEvk1AJIpBB4ajIGNgvd3qLTEs0B2k5P_DQdkxUzNpAVA16XM0N7oI5O6qGbK2cbSAJ7LrFzYm0AL9Gq5PutjdnRCwQf_tRkO2I2hfWuv0DVhvmtTDrio360yr-sWMqOTgBXjQdIpQ-sBAKoo4rBmNeKm00" alt="uml diagram">\n<h3 id="子服务启动时确定-schema-是否合法" tabindex="-1"><a class="header-anchor" href="#子服务启动时确定-schema-是否合法" aria-hidden="true">#</a> 子服务启动时确定 Schema 是否合法</h3>\n<p>如下是子服务启动时与 Schema 合成管理系统的交互时序图。</p>\n<img src="https://www.plantuml.com/plantuml/svg/NP7DIiD058NtynH3j-8BT25Tk17SvGd6PBI1DYd9f6j1gsbewu2bYpQqZIYAQ59H_0leo_JEnBTmGcfetGoNcVETU-RUcik8mxnc0n6FsPRNFA0EGYrrP-fcYrWCL-2HYx0FGLJ1nCKQTTgcJZSbcbwdJOA1-yBdCeuaFvFFgKnd1RAd8KHqPhO9ewK1MXLuUoTNLB4S971r8kRdU0lBhY_21xXuKtNH77XVtYxMVN9NTPIyw7w1lu3a0pw79I_7frZRtSVPzoIBUc8U_Tpta6KhtZ6FwWpRXmMyV1z0vtMPZe3tYY0vwQuYkaPZqw5iN0YgwdK8awbCByKqHCYW_sAkVVMFa54CyHXu0i6TcXe4C-6FikCEN3zbBpUeHYr3hUKN" alt="uml diagram">\n<p>之所以要在子服务启动时才校验 Schema 是否合法，是因为服务部署需要考虑环境，而 CI 在构建打包的时候应该与环境无关，因此，我们在服务启动时做校验。</p>\n<h2 id="网关拉取-schema" tabindex="-1"><a class="header-anchor" href="#网关拉取-schema" aria-hidden="true">#</a> 网关拉取 Schema</h2>\n<p>网关是对外提供服务的，需要拉取最新可用的全部 Schema。前面的设计中，Schema 合成管理系统的 <code>Running_Config</code> 表记录了当前可用的所有子服务的 Schema。网关只需要从 Schema 合成管理系统中拉取这个信息就可以了。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuKeiBSdFAyrDIYtYuYe0YcKcPnOavfKeABadbgIM9rOgAIGMAxY7eye59sUavYOgF9tGyQnZmlDr2vzFQ7k-UVVptVF1geCzWxcu4fDBCik0He3qShc7A-ZQWSIj59ujQ7--Tf-2jiBpllLF5pKZAGHh0n98IXU-NDMZ4EpYmvMN3rHGb9cUKQAGdmQLtRtmnRRD4EEUpsfvrjdmR4xdipczJxiM0haWNGelziz-iR07OWpSQFTmAw34bAUpvxrixNs-TzsJ_GkVDQxdIab5TGZ4oI35psPlUJPj0ufYXzIy563W0G00" alt="uml diagram">\n<p>在拉取到配置以后，可以通过如下方式实现自动更新网关的 Schema 信息。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">const</span> graphqlGatewayModule <span class="token operator">=</span> GraphQLGatewayModule<span class="token punctuation">.</span><span class="token function">forRootAsync</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function-variable function">useFactory</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    server<span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 其他配置项</span>\n      path<span class="token operator">:</span> <span class="token string">\'/bff/graphql\'</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    gateway<span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 一分钟轮询时间</span>\n      experimental_pollInterval<span class="token operator">:</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span>\n      experimental_updateServiceDefinitions<span class="token operator">:</span> updateServicesDefinitions<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>我们将原来的 <code>serviceList</code> 换成 <code>updateServicesDefinitions</code>，而 <code>updateServicesDefinitions</code> 负责从 Schema 合成管理系统拉取最新的 Schema 信息返回给网关。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">updateServicesDefinitions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://gateway-running-config-endpoint\'</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> serviceDefinitions <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">,</span> url<span class="token punctuation">,</span> sdl <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token keyword">type</span>Defs<span class="token operator">:</span> <span class="token function">parse</span><span class="token punctuation">(</span>sdl<span class="token punctuation">)</span><span class="token punctuation">,</span>\n    name<span class="token punctuation">,</span>\n    url<span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    serviceDefinitions<span class="token punctuation">,</span>\n    isNewSchema<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>通过这个方法就可以实现网关自动拉取最新的 Schema 信息了。</p>\n<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>\n<p>我们先探索了获取子服务 Schema，并进行合成校验的方法，这是构建 Schema 合成管理系统的技术基石。然后我们设计了实现最简功能所需的数据库表。</p>\n<p>完成了 Schema 合成管理系统的内部设计以后，我们对 CI/CD 以及网关如何与 Schema 合成管理系统交互做了定义和说明。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-03",deps:[],hoistedTags:[],links:[],pathInferred:"/solutions/graphql/schema-composition.html",pathLocale:"/",permalink:null,slug:"schema-composition",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/graphql/schema-composition.md",filePathRelative:"solutions/graphql/schema-composition.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/schema-composition.html.vue",componentFilePathRelative:"pages/solutions/graphql/schema-composition.html.vue",componentFileChunkName:"v-8b04edb2",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/schema-composition.html.js",dataFilePathRelative:"pages/solutions/graphql/schema-composition.html.js",dataFileChunkName:"v-8b04edb2",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/graphql/schema-composition.html",htmlFilePathRelative:"solutions/graphql/schema-composition.html"},{key:"v-1c26f2fc",path:"/solutions/graphql/server.html",title:"构建一个基于 GraphQL 的单体 BFF 服务",lang:"zh-CN",frontmatter:{title:"构建一个基于 GraphQL 的单体 BFF 服务",description:"介绍如何通过 GraphQL、NestJS 构建一个 BFF 服务",keywords:["BFF","GraphQL","ApolloServer","NestJS"],date:"2021-07-14T00:00:00.000Z",key:4,tags:["实践"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"项目初始化",slug:"项目初始化",children:[]},{level:2,title:"添加应用代码",slug:"添加应用代码",children:[{level:3,title:"初始化 GraphQLModule",slug:"初始化-graphqlmodule",children:[]},{level:3,title:"商品模型",slug:"商品模型",children:[]},{level:3,title:"订单模型",slug:"订单模型",children:[]}]},{level:2,title:"小结",slug:"小结",children:[]}],content:"\n本文通过搭建一个简单的商品订单系统，来介绍如何基于 GraphQL、NestJS 构建一个 BFF 服务。\n\nTypeScript 这几年迅猛发展，不仅在前端开发中使用越来越广泛，在 NodeJS 端也逐步铺开。本文选择基于 TypeScript 开发的服务端框架 [NestJS](https://nestjs.com/) 和已经被社区广泛使用的 [Apollo](https://www.apollographql.com/) 来实现 BFF 服务。\n\n## 项目初始化\n\n我们直接使用 NestJS 的 CLI（命令行）工具来初始化项目，假设我们的应用名称是 `bff-graphql-server`。\n\n```bash\nyarn global add @nestjs/cli\nnest new bff-graphql-server\n```\n\n> 注意，在写这篇文章的时候，NestJS 官方刚刚将 NestJS 的版本升级到 v8，一些周边的依赖包存在版本不匹配问题，因此建议使用 v7 版本，或者直接 fork demo 项目 [repo](https://github.com/everfind/bff-graphql-server)。\n\n初始化完成后，我们添加 GraphQL 依赖。\n\n```bash\nyarn add @nestjs/graphql graphql-tools graphql apollo-server-express\n```\n\n至此，我们已经完成了项目初始化。\n\n## 添加应用代码\n\n在开始写业务代码之前，我们先规划一下目录结构。\n\n默认初始化出来的项目目录如下：\n\n```\n-- src\n  -- main.ts // 系统启动入口\n  -- app.module.ts // 应用主模块\n  -- app.controller.ts // 控制器\n  -- app.service.ts // 服务，用于获取数据\n```\n\n我们新增加三个目录，分别是 `models`、`services`、`resolvers`：\n\n```\n-- src\n  -- modules  // 存放模型定义，最终生成 GraphQL 的 Schema\n  -- resolvers // 存放 Resolver，实现数据的聚合裁减\n  -- services // 对接后端服务接口，用于获取数据\n```\n\n在 BFF 中任何一个领域模型，都需要一份模型定义，一个获取数据的 `Service` 和一个用于数据聚合和裁减的 `Resolver`。\n\n在这个例子中，我们需要定义两个模型，商品模型和订单模型。\n\n### 初始化 GraphQLModule\n\n在 NestJS 中，我们通过 module 来管理代码，因此，我们需要初始化 `GraphQLModule`。\n\n修改默认的 `src/app.module.ts` 代码如下：\n\n```ts\nimport { HttpModule, Module } from '@nestjs/common';\nimport { GqlModuleOptions, GraphQLModule } from '@nestjs/graphql';\nimport { AppController } from './app.controller';\nimport resolvers from './resolvers';\nimport services from './services';\n\n@Module({\n  imports: [\n    HttpModule,\n    GraphQLModule.forRoot({\n      debug: true, // 生产环境中需要关闭\n      introspection: true, // 开启内省模式，生产环境中需要关闭\n      path: '/graphql', // 定义 GraphQL 的请求路径\n      autoSchemaFile: true, // 自动生成 schema 文件\n      playground: { // UI 界面\n        // 生产环境中需要关闭\n        settings: {\n          'request.credentials': 'same-origin',\n        },\n      },\n    } as GqlModuleOptions),\n  ],\n  controllers: [AppController],\n  providers: [...services, ...resolvers], // 系统中定义的 service 和 resolver\n})\nexport class AppModule {}\n```\n\n### 商品模型\n\n#### 定义模型\n在 `models` 目录下新建一个 `goods` 目录：\n\n```\n-- src\n  -- models\n    -- goods\n```\n\n定义商品模型，在这个模型中，商品有三个字段：\n\n```ts\nimport { Field, ObjectType } from '@nestjs/graphql';\n\n@ObjectType({ description: '商品信息' })\nexport class GoodsData {\n  @Field(() => String, { nullable: false, description: '商品 ID' })\n  goodsId: string;\n\n  @Field(() => String, { nullable: false, description: '商品名称' })\n  goodsName: string;\n\n  @Field(() => String, { nullable: true, description: '商品简介' })\n  goodsBrief?: string;\n}\n```\n\n现在我们定义查询商品模型的参数：\n\n```ts\nimport { Field, InputType } from '@nestjs/graphql';\n\n@InputType({ description: '商品详情参数' })\nexport class GoodsParam {\n  @Field(() => String, { nullable: false, description: '商品 ID' })\n  goodsId: string;\n}\n```\n\n#### 定义 Service\n\n在 `services` 目录下新建 `goods` 目录：\n\n```\n-- src\n  -- services\n    -- goods\n```\n\n创建一个 `GoodsService` 类：\n\n```ts\nimport { HttpService, Injectable } from '@nestjs/common';\nimport { GoodsData, GoodsParam } from 'src/models/goods/model';\n\n@Injectable()\nexport class GoodsService {\n  constructor(private readonly http: HttpService) {}\n\n  getGoods(param: GoodsParam): Promise<GoodsData> {\n    return this.http\n      .get<GoodsData>('/goodsservice/rest/goods/detail', { params: param })\n      .toPromise()\n      .then((resp) => resp.data);\n  }\n}\n```\n\n> 我们假定通过 `/goodsservice/rest/goods/detail` 可以查询商品详情。 `HttpService` 是 NestJS 提供的基于 [Axios](https://www.npmjs.com/package/axios) 的封装。\n\n定义好 `GoodsService` 以后，我们将这个类添加到 `src/services/index.ts` 中导出。\n\n```ts\nimport { GoodsService } from './goods';\n\nexport default [GoodsService];\n```\n\n#### 定义 Resolver\n\n在 `resolvers` 目录下新建 `goods` 目录：\n\n```\n-- src\n  -- resolvers\n    -- goods\n```\n\n创建一个 `GoodsResolver` 类：\n\n```ts\nimport { Args, Query, Resolver } from '@nestjs/graphql';\nimport { GoodsData, GoodsParam } from 'src/models/goods/model';\nimport { GoodsService } from 'src/services/goods/goods';\n\n@Resolver()\nexport class GoodsResolver {\n  constructor(private readonly goodsService: GoodsService) {}\n\n  @Query(() => GoodsData, {\n    name: 'goodsData',\n  })\n  goods(@Args('param') param: GoodsParam): Promise<GoodsData> {\n    return this.goodsService.getGoods(param.goodsId);\n  }\n}\n```\n\n定义好 `GoodsResolver` 以后，我们将这个类添加到 `src/resolvers/index.ts` 中导出。\n\n```ts\nimport { GoodsResolver } from './goods';\n\nexport default [GoodsResolver];\n```\n\n完成以后，启动进程，我们就可以在 playground 里面看到定义的商品模型了，如下图。\n\n![GraphQL Schema 图形展示](/solutions/graphql/schema-c.png)\n\n我们在 playground 中做一些查询看看效果。\n\n![GraphQL playground](/solutions/graphql/playground-c.png)\n\n### 订单模型\n\n与商品模型类似，我们需要做一些定义。\n\n#### 定义模型\n\n在 `models` 目录下新建一个 `orders` 目录：\n\n```\n-- src\n  -- models\n    -- orders\n```\n\n定义订单模型和查询参数，如下：\n\n```ts\nimport { Field, Float, InputType, ObjectType } from '@nestjs/graphql';\n\n@ObjectType({ description: '订单数据' })\nexport class OrderData {\n  @Field(() => String, { nullable: false, description: '订单号' })\n  orderNo: string;\n\n  @Field(() => String, { nullable: false, description: '商品 ID' })\n  goodsId: string;\n\n  @Field(() => Float, { nullable: false, description: '金额' })\n  pay: number;\n\n  @Field(() => String, { nullable: true, description: '备注信息' })\n  comment?: string;\n}\n\n@InputType({ description: '订单详情参数' })\nexport class OrderParam {\n  @Field(() => String, { nullable: false, description: '订单号' })\n  orderNo: string;\n}\n```\n\n需要注意的是，`OrderData` 中有一个 `goodsId` 字段与商品建立关系，我们后面在 `Resolver` 中需要借助于这个字段来查询商品信息。\n\n#### 定义 Service\n\n在 `services` 目录下新建 `orders` 目录：\n\n```\n-- src\n  -- services\n    -- orders\n```\n\n创建一个 `OrderService` 类：\n\n```ts\nimport { HttpService, Injectable } from '@nestjs/common';\nimport { OrderData, OrderParam } from 'src/models/orders/model';\n\n@Injectable()\nexport class OrderService {\n  constructor(private readonly http: HttpService) {}\n\n  getOrder(param: OrderParam): Promise<OrderData> {\n    return this.http\n      .get<OrderData>('/goodsservice/rest/order/detail', { params: param })\n      .toPromise()\n      .then((resp) => resp.data);\n  }\n}\n```\n\n> 别忘了在 `src/services/index.ts` 添加 `OrderService` 的导出。\n\n#### 定义 Resolver\n\n在 `resolvers` 目录下新建 `orders` 目录：\n\n```\n-- src\n  -- resolvers\n    -- orders\n```\n\n创建一个 `OrderResolver` 类：\n\n```ts\nimport { Args, Query, Resolver } from '@nestjs/graphql';\nimport { OrderData OrderParam } from 'src/models/orders/model';\nimport { OrderService } from 'src/services/orders/order';\n\n@Resolver()\nexport class OrderResolver {\n  constructor(private readonly orderService: OrderService) {}\n\n  @Query(() => OrderData, {\n    name: 'orderData',\n  })\n  order(@Args('param') param: OrderParam): Promise<OrderData> {\n    return this.orderService.getOrder(param);\n  }\n}\n```\n\n> 注意，别忘了在 `src/resolvers/index.ts` 中添加 `OrderResolver` 的导出。\n\n定义好 `OrderResolver` 以后，我们就可以查询订单信息。\n\n这时候，如果我们直接查询订单上的商品信息是查不到，因为还没建立相关的 Resolver。\n\n我们现在添加一个 `OrderPropertyResolver` 类：\n\n```ts\nimport { Args, Parent, Query, ResolveField, Resolver } from '@nestjs/graphql';\nimport { GoodsData } from 'src/models/goods/model';\nimport { OrderData } from 'src/models/orders/model';\nimport { GoodsService } from 'src/services/goods/goods';\n\n@Resolver(() => OrderData)\nexport class OrderPropertyResolver {\n  constructor(private readonly goodsService: GoodsService) {}\n\n  @ResolveField(() => GoodsData, {\n    name: 'goodsData',\n    nullable: true,\n  })\n  goodsData(@Parent() orderData: OrderData): Promise<GoodsData> {\n    return this.goodsService.getGoodsById(orderData.goodsId);\n  }\n}\n```\n\n注意这里 `@Resolver(() => OrderData)` 的写法，它告诉 GraphQL，当需要解析 `OrderData` 上的字段信息时，使用这个 Resolver 类。\n\n我们通过 `@Parent()` 装饰器可以拿到 `OrderData` 上的数据，在这个例子中就是 `goodsId`。\n\n这里要额外说一点，通常来说，单个订单直接通过商品详情接口查商品数据没有问题，但是如果是订单列表要查商品数据，依然通过商品详情接口查的话就会产生 N + 1 问题了。\n\n在前面的文章中我们提到过，可以借助于 [DataLoader](https://npmjs.org/package/dataloader) 来解决 N + 1 问题。\n\n我们对 `GoodsService` 做一些改造，引入 DataLoader。\n\n```ts\nimport DataLoader from 'dataloader';\n\n@Injectable()\nexport class GoodsService {\n  // 其他代码\n\n  private goodsLoader = new DataLoader<string, GoodsData>(\n    async (goodsIdList: readonly string[]) => {\n      const goodsList = await this.batchGetGoodsByGoodsId(\n        goodsIdList as string[],\n      );\n      return goodsIdList.map((goodsId) =>\n        goodsList.find((goodsData) => goodsData.goodsId === goodsId),\n      );\n    },\n  );\n\n  private batchGetGoodsByGoodsId(goodsIdList: string[]): Promise<GoodsData[]> {\n    return this.http\n      .get<GoodsData[]>('/goodsservice/rest/goods/list-by-id', {\n        params: goodsIdList,\n      })\n      .toPromise()\n      .then((resp) => {\n        return resp.data;\n      });\n  }\n\n  getGoodsById(goodsId: string): Promise<GoodsData> {\n    return this.goodsLoader.load(goodsId);\n  }\n\n  getGoodsByIdList(goodsIdList: string[]): Promise<(GoodsData | Error)[]> {\n    return this.goodsLoader.loadMany(goodsIdList);\n  }\n}\n```\n\n> 正如代码中所示，DataLoader 依赖后端提供一个批量接口，即通过 `goodsId` 批量查询 `GoodsData` 信息。\n\n完成以后，我们就可以愉快的在查询订单的时候也查询商品信息了。\n\n![查询订单信息](/solutions/graphql/order-demo-c.png)\n\n## 小结\n\n我们通过搭建一个简单的订单、商品系统展示了如果开发一个基于 GraphQL 的 BFF 服务。\n\n结合 NestJS 和 Apollo，我们可以方便的通过 TypeScript 来开发 GraphQL 服务，极大的提升开发效率。\n\n借助于 GraphQL 的 playground，我们可以方便的对系统进行查询，不依赖前端代码实现。\n",contentRendered:'<p>本文通过搭建一个简单的商品订单系统，来介绍如何基于 GraphQL、NestJS 构建一个 BFF 服务。</p>\n<p>TypeScript 这几年迅猛发展，不仅在前端开发中使用越来越广泛，在 NodeJS 端也逐步铺开。本文选择基于 TypeScript 开发的服务端框架 <a href="https://nestjs.com/" target="_blank" rel="noopener noreferrer">NestJS<OutboundLink/></a> 和已经被社区广泛使用的 <a href="https://www.apollographql.com/" target="_blank" rel="noopener noreferrer">Apollo<OutboundLink/></a> 来实现 BFF 服务。</p>\n<h2 id="项目初始化" tabindex="-1"><a class="header-anchor" href="#项目初始化" aria-hidden="true">#</a> 项目初始化</h2>\n<p>我们直接使用 NestJS 的 CLI（命令行）工具来初始化项目，假设我们的应用名称是 <code>bff-graphql-server</code>。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> global <span class="token function">add</span> @nestjs/cli\nnest new bff-graphql-server\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote>\n<p>注意，在写这篇文章的时候，NestJS 官方刚刚将 NestJS 的版本升级到 v8，一些周边的依赖包存在版本不匹配问题，因此建议使用 v7 版本，或者直接 fork demo 项目 <a href="https://github.com/everfind/bff-graphql-server" target="_blank" rel="noopener noreferrer">repo<OutboundLink/></a>。</p>\n</blockquote>\n<p>初始化完成后，我们添加 GraphQL 依赖。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> @nestjs/graphql graphql-tools graphql apollo-server-express\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>至此，我们已经完成了项目初始化。</p>\n<h2 id="添加应用代码" tabindex="-1"><a class="header-anchor" href="#添加应用代码" aria-hidden="true">#</a> 添加应用代码</h2>\n<p>在开始写业务代码之前，我们先规划一下目录结构。</p>\n<p>默认初始化出来的项目目录如下：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>-- src\n  -- main.ts // 系统启动入口\n  -- app.module.ts // 应用主模块\n  -- app.controller.ts // 控制器\n  -- app.service.ts // 服务，用于获取数据\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们新增加三个目录，分别是 <code>models</code>、<code>services</code>、<code>resolvers</code>：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>-- src\n  -- modules  // 存放模型定义，最终生成 GraphQL 的 Schema\n  -- resolvers // 存放 Resolver，实现数据的聚合裁减\n  -- services // 对接后端服务接口，用于获取数据\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在 BFF 中任何一个领域模型，都需要一份模型定义，一个获取数据的 <code>Service</code> 和一个用于数据聚合和裁减的 <code>Resolver</code>。</p>\n<p>在这个例子中，我们需要定义两个模型，商品模型和订单模型。</p>\n<h3 id="初始化-graphqlmodule" tabindex="-1"><a class="header-anchor" href="#初始化-graphqlmodule" aria-hidden="true">#</a> 初始化 GraphQLModule</h3>\n<p>在 NestJS 中，我们通过 module 来管理代码，因此，我们需要初始化 <code>GraphQLModule</code>。</p>\n<p>修改默认的 <code>src/app.module.ts</code> 代码如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> HttpModule<span class="token punctuation">,</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/common\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> GqlModuleOptions<span class="token punctuation">,</span> GraphQLModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> AppController <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./app.controller\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> resolvers <span class="token keyword">from</span> <span class="token string">\'./resolvers\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> services <span class="token keyword">from</span> <span class="token string">\'./services\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  imports<span class="token operator">:</span> <span class="token punctuation">[</span>\n    HttpModule<span class="token punctuation">,</span>\n    GraphQLModule<span class="token punctuation">.</span><span class="token function">forRoot</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      debug<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 生产环境中需要关闭</span>\n      introspection<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 开启内省模式，生产环境中需要关闭</span>\n      path<span class="token operator">:</span> <span class="token string">\'/graphql\'</span><span class="token punctuation">,</span> <span class="token comment">// 定义 GraphQL 的请求路径</span>\n      autoSchemaFile<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 自动生成 schema 文件</span>\n      playground<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// UI 界面</span>\n        <span class="token comment">// 生产环境中需要关闭</span>\n        settings<span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token string">\'request.credentials\'</span><span class="token operator">:</span> <span class="token string">\'same-origin\'</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span> <span class="token keyword">as</span> GqlModuleOptions<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  controllers<span class="token operator">:</span> <span class="token punctuation">[</span>AppController<span class="token punctuation">]</span><span class="token punctuation">,</span>\n  providers<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>services<span class="token punctuation">,</span> <span class="token operator">...</span>resolvers<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 系统中定义的 service 和 resolver</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h3 id="商品模型" tabindex="-1"><a class="header-anchor" href="#商品模型" aria-hidden="true">#</a> 商品模型</h3>\n<h4 id="定义模型" tabindex="-1"><a class="header-anchor" href="#定义模型" aria-hidden="true">#</a> 定义模型</h4>\n<p>在 <code>models</code> 目录下新建一个 <code>goods</code> 目录：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>-- src\n  -- models\n    -- goods\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>定义商品模型，在这个模型中，商品有三个字段：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Field<span class="token punctuation">,</span> ObjectType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">ObjectType</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> description<span class="token operator">:</span> <span class="token string">\'商品信息\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">GoodsData</span> <span class="token punctuation">{</span>\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品 ID\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  goodsId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品名称\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  goodsName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品简介\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  goodsBrief<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>现在我们定义查询商品模型的参数：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Field<span class="token punctuation">,</span> InputType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">InputType</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> description<span class="token operator">:</span> <span class="token string">\'商品详情参数\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">GoodsParam</span> <span class="token punctuation">{</span>\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品 ID\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  goodsId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="定义-service" tabindex="-1"><a class="header-anchor" href="#定义-service" aria-hidden="true">#</a> 定义 Service</h4>\n<p>在 <code>services</code> 目录下新建 <code>goods</code> 目录：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>-- src\n  -- services\n    -- goods\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>创建一个 <code>GoodsService</code> 类：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> HttpService<span class="token punctuation">,</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/common\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> GoodsData<span class="token punctuation">,</span> GoodsParam <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'src/models/goods/model\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">GoodsService</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> http<span class="token operator">:</span> HttpService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n  <span class="token function">getGoods</span><span class="token punctuation">(</span>param<span class="token operator">:</span> GoodsParam<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>GoodsData<span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>http\n      <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>GoodsData<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">\'/goodsservice/rest/goods/detail\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> params<span class="token operator">:</span> param <span class="token punctuation">}</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">toPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span> <span class="token operator">=></span> resp<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote>\n<p>我们假定通过 <code>/goodsservice/rest/goods/detail</code> 可以查询商品详情。 <code>HttpService</code> 是 NestJS 提供的基于 <a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener noreferrer">Axios<OutboundLink/></a> 的封装。</p>\n</blockquote>\n<p>定义好 <code>GoodsService</code> 以后，我们将这个类添加到 <code>src/services/index.ts</code> 中导出。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> GoodsService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./goods\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>GoodsService<span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="定义-resolver" tabindex="-1"><a class="header-anchor" href="#定义-resolver" aria-hidden="true">#</a> 定义 Resolver</h4>\n<p>在 <code>resolvers</code> 目录下新建 <code>goods</code> 目录：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>-- src\n  -- resolvers\n    -- goods\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>创建一个 <code>GoodsResolver</code> 类：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Args<span class="token punctuation">,</span> Query<span class="token punctuation">,</span> Resolver <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> GoodsData<span class="token punctuation">,</span> GoodsParam <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'src/models/goods/model\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> GoodsService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'src/services/goods/goods\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Resolver</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">GoodsResolver</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> goodsService<span class="token operator">:</span> GoodsService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> GoodsData<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">\'goodsData\'</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token function">goods</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Args</span></span><span class="token punctuation">(</span><span class="token string">\'param\'</span><span class="token punctuation">)</span> param<span class="token operator">:</span> GoodsParam<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>GoodsData<span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>goodsService<span class="token punctuation">.</span><span class="token function">getGoods</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span>goodsId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>定义好 <code>GoodsResolver</code> 以后，我们将这个类添加到 <code>src/resolvers/index.ts</code> 中导出。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> GoodsResolver <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./goods\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>GoodsResolver<span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>完成以后，启动进程，我们就可以在 playground 里面看到定义的商品模型了，如下图。</p>\n<p><img src="/solutions/graphql/schema-c.png" alt="GraphQL Schema 图形展示"></p>\n<p>我们在 playground 中做一些查询看看效果。</p>\n<p><img src="/solutions/graphql/playground-c.png" alt="GraphQL playground"></p>\n<h3 id="订单模型" tabindex="-1"><a class="header-anchor" href="#订单模型" aria-hidden="true">#</a> 订单模型</h3>\n<p>与商品模型类似，我们需要做一些定义。</p>\n<h4 id="定义模型-1" tabindex="-1"><a class="header-anchor" href="#定义模型-1" aria-hidden="true">#</a> 定义模型</h4>\n<p>在 <code>models</code> 目录下新建一个 <code>orders</code> 目录：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>-- src\n  -- models\n    -- orders\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>定义订单模型和查询参数，如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Field<span class="token punctuation">,</span> Float<span class="token punctuation">,</span> InputType<span class="token punctuation">,</span> ObjectType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">ObjectType</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> description<span class="token operator">:</span> <span class="token string">\'订单数据\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">OrderData</span> <span class="token punctuation">{</span>\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'订单号\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  orderNo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'商品 ID\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  goodsId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Float<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'金额\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  pay<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'备注信息\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  comment<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">InputType</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> description<span class="token operator">:</span> <span class="token string">\'订单详情参数\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">OrderParam</span> <span class="token punctuation">{</span>\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Field</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> String<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> description<span class="token operator">:</span> <span class="token string">\'订单号\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  orderNo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>需要注意的是，<code>OrderData</code> 中有一个 <code>goodsId</code> 字段与商品建立关系，我们后面在 <code>Resolver</code> 中需要借助于这个字段来查询商品信息。</p>\n<h4 id="定义-service-1" tabindex="-1"><a class="header-anchor" href="#定义-service-1" aria-hidden="true">#</a> 定义 Service</h4>\n<p>在 <code>services</code> 目录下新建 <code>orders</code> 目录：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>-- src\n  -- services\n    -- orders\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>创建一个 <code>OrderService</code> 类：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> HttpService<span class="token punctuation">,</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/common\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> OrderData<span class="token punctuation">,</span> OrderParam <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'src/models/orders/model\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> http<span class="token operator">:</span> HttpService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n  <span class="token function">getOrder</span><span class="token punctuation">(</span>param<span class="token operator">:</span> OrderParam<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>OrderData<span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>http\n      <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>OrderData<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">\'/goodsservice/rest/order/detail\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> params<span class="token operator">:</span> param <span class="token punctuation">}</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">toPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span> <span class="token operator">=></span> resp<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote>\n<p>别忘了在 <code>src/services/index.ts</code> 添加 <code>OrderService</code> 的导出。</p>\n</blockquote>\n<h4 id="定义-resolver-1" tabindex="-1"><a class="header-anchor" href="#定义-resolver-1" aria-hidden="true">#</a> 定义 Resolver</h4>\n<p>在 <code>resolvers</code> 目录下新建 <code>orders</code> 目录：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>-- src\n  -- resolvers\n    -- orders\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>创建一个 <code>OrderResolver</code> 类：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Args<span class="token punctuation">,</span> Query<span class="token punctuation">,</span> Resolver <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> OrderData OrderParam <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'src/models/orders/model\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> OrderService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'src/services/orders/order\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Resolver</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">OrderResolver</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> orderService<span class="token operator">:</span> OrderService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> OrderData<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">\'orderData\'</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token function">order</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Args</span></span><span class="token punctuation">(</span><span class="token string">\'param\'</span><span class="token punctuation">)</span> param<span class="token operator">:</span> OrderParam<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>OrderData<span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>orderService<span class="token punctuation">.</span><span class="token function">getOrder</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote>\n<p>注意，别忘了在 <code>src/resolvers/index.ts</code> 中添加 <code>OrderResolver</code> 的导出。</p>\n</blockquote>\n<p>定义好 <code>OrderResolver</code> 以后，我们就可以查询订单信息。</p>\n<p>这时候，如果我们直接查询订单上的商品信息是查不到，因为还没建立相关的 Resolver。</p>\n<p>我们现在添加一个 <code>OrderPropertyResolver</code> 类：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Args<span class="token punctuation">,</span> Parent<span class="token punctuation">,</span> Query<span class="token punctuation">,</span> ResolveField<span class="token punctuation">,</span> Resolver <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'@nestjs/graphql\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> GoodsData <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'src/models/goods/model\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> OrderData <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'src/models/orders/model\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> GoodsService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'src/services/goods/goods\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Resolver</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> OrderData<span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">OrderPropertyResolver</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">readonly</span> goodsService<span class="token operator">:</span> GoodsService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n  <span class="token decorator"><span class="token at operator">@</span><span class="token function">ResolveField</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> GoodsData<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">\'goodsData\'</span><span class="token punctuation">,</span>\n    nullable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token function">goodsData</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Parent</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> orderData<span class="token operator">:</span> OrderData<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>GoodsData<span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>goodsService<span class="token punctuation">.</span><span class="token function">getGoodsById</span><span class="token punctuation">(</span>orderData<span class="token punctuation">.</span>goodsId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>注意这里 <code>@Resolver(() =&gt; OrderData)</code> 的写法，它告诉 GraphQL，当需要解析 <code>OrderData</code> 上的字段信息时，使用这个 Resolver 类。</p>\n<p>我们通过 <code>@Parent()</code> 装饰器可以拿到 <code>OrderData</code> 上的数据，在这个例子中就是 <code>goodsId</code>。</p>\n<p>这里要额外说一点，通常来说，单个订单直接通过商品详情接口查商品数据没有问题，但是如果是订单列表要查商品数据，依然通过商品详情接口查的话就会产生 N + 1 问题了。</p>\n<p>在前面的文章中我们提到过，可以借助于 <a href="https://npmjs.org/package/dataloader" target="_blank" rel="noopener noreferrer">DataLoader<OutboundLink/></a> 来解决 N + 1 问题。</p>\n<p>我们对 <code>GoodsService</code> 做一些改造，引入 DataLoader。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> DataLoader <span class="token keyword">from</span> <span class="token string">\'dataloader\'</span><span class="token punctuation">;</span>\n\n<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">GoodsService</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 其他代码</span>\n\n  <span class="token keyword">private</span> goodsLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataLoader<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> GoodsData<span class="token operator">></span></span><span class="token punctuation">(</span>\n    <span class="token keyword">async</span> <span class="token punctuation">(</span>goodsIdList<span class="token operator">:</span> <span class="token keyword">readonly</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> goodsList <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">batchGetGoodsByGoodsId</span><span class="token punctuation">(</span>\n        goodsIdList <span class="token keyword">as</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> goodsIdList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>goodsId<span class="token punctuation">)</span> <span class="token operator">=></span>\n        goodsList<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span>goodsData<span class="token punctuation">)</span> <span class="token operator">=></span> goodsData<span class="token punctuation">.</span>goodsId <span class="token operator">===</span> goodsId<span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">private</span> <span class="token function">batchGetGoodsByGoodsId</span><span class="token punctuation">(</span>goodsIdList<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>GoodsData<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>http\n      <span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>GoodsData<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">\'/goodsservice/rest/goods/list-by-id\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        params<span class="token operator">:</span> goodsIdList<span class="token punctuation">,</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">toPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> resp<span class="token punctuation">.</span>data<span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">getGoodsById</span><span class="token punctuation">(</span>goodsId<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>GoodsData<span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>goodsLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>goodsId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">getGoodsByIdList</span><span class="token punctuation">(</span>goodsIdList<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token punctuation">(</span>GoodsData <span class="token operator">|</span> Error<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>goodsLoader<span class="token punctuation">.</span><span class="token function">loadMany</span><span class="token punctuation">(</span>goodsIdList<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><blockquote>\n<p>正如代码中所示，DataLoader 依赖后端提供一个批量接口，即通过 <code>goodsId</code> 批量查询 <code>GoodsData</code> 信息。</p>\n</blockquote>\n<p>完成以后，我们就可以愉快的在查询订单的时候也查询商品信息了。</p>\n<p><img src="/solutions/graphql/order-demo-c.png" alt="查询订单信息"></p>\n<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>我们通过搭建一个简单的订单、商品系统展示了如果开发一个基于 GraphQL 的 BFF 服务。</p>\n<p>结合 NestJS 和 Apollo，我们可以方便的通过 TypeScript 来开发 GraphQL 服务，极大的提升开发效率。</p>\n<p>借助于 GraphQL 的 playground，我们可以方便的对系统进行查询，不依赖前端代码实现。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-07-14",deps:[],hoistedTags:[],links:[],pathInferred:"/solutions/graphql/server.html",pathLocale:"/",permalink:null,slug:"server",filePath:"/Users/bingooo/workspace/everfind/website/docs/solutions/graphql/server.md",filePathRelative:"solutions/graphql/server.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/server.html.vue",componentFilePathRelative:"pages/solutions/graphql/server.html.vue",componentFileChunkName:"v-1c26f2fc",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/solutions/graphql/server.html.js",dataFilePathRelative:"pages/solutions/graphql/server.html.js",dataFileChunkName:"v-1c26f2fc",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/solutions/graphql/server.html",htmlFilePathRelative:"solutions/graphql/server.html"}]}},1682:(n,s,a)=>{a.r(s),a.d(s,{default:()=>o});var e=a(6252);const p=(0,e.Wm)("div",{class:"custom-container tip"},[(0,e.Wm)("p",{class:"custom-container-title"},"TIP"),(0,e.Wm)("p",null,"GraphQL 的实践方案总结")],-1),t=(0,e.uE)('<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',1),o={render:function(n,s){const a=(0,e.up)("ArticleList");return(0,e.wg)(),(0,e.j4)(e.HY,null,[p,(0,e.Wm)(a),t],64)}}}}]);