"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[2667],{4891:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-35eef6b0",path:"/code-reading/dataloader/",title:"服务端批量请求管理神器 -- Dataloader 源码解读",lang:"zh-CN",frontmatter:{title:"服务端批量请求管理神器 -- Dataloader 源码解读",description:"DataLoader 可用作应用程序数据获取层的一部分，通过批处理和缓存为各种远程数据源（例如数据库或 Web 服务）提供简化且一致的 API。",sidebar:!1},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[],filePathRelative:"code-reading/dataloader/README.md",articleList:[{key:"v-6ad29ef2",path:"/code-reading/dataloader/batch.html",title:"Dataloader 批处理能力解读",lang:"zh-CN",frontmatter:{title:"Dataloader 批处理能力解读",description:"批处理是 Dataloader 的首要核心能力，本篇文章会对批处理的功能以及如何实现这些功能做详细地介绍。",keywords:["dataloader","batch","批处理"],date:"2021-08-07T00:00:00.000Z",key:1},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"什么是 Batch",slug:"什么是-batch",children:[]},{level:2,title:"batchLoadFn 批量请求函数",slug:"batchloadfn-批量请求函数",children:[]},{level:2,title:"load 函数",slug:"load-函数",children:[{level:3,title:"getCurrentBatch",slug:"getcurrentbatch",children:[]},{level:3,title:"dispatchBatch",slug:"dispatchbatch",children:[]}]},{level:2,title:"批量调度策略",slug:"批量调度策略",children:[]},{level:2,title:"loadMany 函数",slug:"loadmany-函数",children:[]}],content:"\nDataloader 的批处理能力，可以实现在一个周期内将多次数据请求进行合并，最终只向远程数据源发送一次请求。这个周期不是固定的，Dataloader 的默认实现是 NodeJS 事件循环的一个循环周期，用户也可以自定义周期。\n\n如下是 Dataloader 的构造函数的签名：\n\n```ts\nconstructor(batchLoadFn: DataLoader.BatchLoadFn<K, V>, options?: DataLoader.Options<K, V, C>);\n```\n\n首先是一个批量请求函数 `batchLoadFn`，告诉 Dataloader 如何批量发起请求。其次 `options` 参数中有是三个配置项关于批处理的：\n\n- batch 是否启用批量请求，false 为不启用，每次数据请求都会向远程数据源发起请求。默认为 true\n- maxBatchSize 一次最多可以请求多少个数据，超过这个数字的请求会放到下一批请求中。默认不限制。\n- batchScheduleFn 批量调度函数，告诉 Dataloader 什么时候发起批量请求。\n\nDataloader 提供了两个函数来获取数据：\n\n- `load(key: K): Promise<V>;`\n- `loadMany(keys: ArrayLike<K>): Promise<Array<V | Error>>;`\n\n显而易见，一个是一次获取一个，一个是一次获取多个。\n\n在讲这两个函数的具体实现之前，我们先来了解下 Dataloader 中的基本概念。\n\n## 什么是 Batch\n\n前面说过，Dataloader 会搜集一个周期内的所有数据调用，然后合并成一个数据请求。`Batch` 对象就是这个能力的载体。\n\n```ts\ntype Batch<K, V> = {\n  hasDispatched: boolean;\n  keys: Array<K>;\n  callbacks: Array<{\n    resolve: (value: V) => void;\n    reject: (error: Error) => void;\n  }>;\n  cacheHits?: Array<() => void>;\n};\n```\n\n这是 `Batch` 的类型定义，`hasDispatched` 表示当前批的请求是否已经发出。`keys` 中存放着需要通过请求获取数据的 `key` 列表。`callbacks` 是对应于每一个 `key` 的请求回调，且是一一对应的关系。`cacheHits` 是命中缓存的数据列表。\n\nDataloader 会尽量利用缓存不重复请求相同的数据。也就是说，假如一个周期内有 10 个数据请求，其中有两个会命中缓存，那么 `keys` 的长度就是 8，`cacheHits` 的长度是 2。\n\n举个例子，假如我们需要查询用户的好友的好友。用户 A 有好友 B 和 C。用户 D 有好友 C 和 E。假设我们有一个 `loaderUser` 的接口查询用户信息。那么通常情况下，需要查询 6（3 + 3）次。使用了 Dataloader 的话，只需要请求 5（3 + 2）次，因为 A 和 D 有个共同好友 C，第二次查询用户 C 的时候会命中缓存。\n\nDataloader 会将一个周期内的数据请求都存放在一个 `Batch` 对象内（如果不超过 `maxBatchSize` 的话），之后通过调用构造函数传入的 `batchLoadFn` 一次查询所有的数据。\n\n## batchLoadFn 批量请求函数\n\n先看一个批量函数的 demo。\n\n```ts\nasync function batchFunction(keys) {\n  const results = await db.fetchAllKeys(keys);\n  return keys.map((key) => results[key] || new Error(`No result for ${key}`));\n}\n\nconst loader = new DataLoader(batchFunction);\n```\n\nDataloader 对 `batchLoadFn` 函数有两个约束：\n\n- 函数的返回数组长度必须与 `keys` 数组长度一致。\n- 函数的返回数组内的元素必须与 `keys` 内的元素一一对应。\n\n也就是说，假如请求的 `keys` 列表为 `[2, 9, 6, 1]`，如果数据接口只返回了\n\n```ts\n{ id: 9, name: 'Chicago' }\n{ id: 1, name: 'New York' }\n{ id: 2, name: 'San Francisco' }\n```\n\n那么我们的 `batchLoadFn` 需要返回：\n\n```ts\n[\n  { id: 2, name: 'San Francisco' },\n  { id: 9, name: 'Chicago' },\n  null, // 或者 `new Error()`\n  { id: 1, name: 'New York' },\n];\n```\n\n注意，`batchLoadFn` 需要返回一个 Promise。\n\n## `load` 函数\n\n`load` 函数的签名是 `load(key: K): Promise<V>`，关键代码如下：\n\n```ts\nload(key: K): Promise<V> {\n  var batch = getCurrentBatch(this);\n  var cacheMap = this._cacheMap;\n  var cacheKey = this._cacheKeyFn(key);\n\n  // If caching and there is a cache-hit, return cached Promise.\n  if (cacheMap) {\n    var cachedPromise = cacheMap.get(cacheKey);\n    if (cachedPromise) {\n      var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n      return new Promise(resolve => {\n        cacheHits.push(() => {\n          resolve(cachedPromise);\n        });\n      });\n    }\n  }\n\n  // Otherwise, produce a new Promise for this key, and enqueue it to be\n  // dispatched along with the current batch.\n  batch.keys.push(key);\n  var promise = new Promise((resolve, reject) => {\n    batch.callbacks.push({ resolve, reject });\n  });\n\n  // If caching, cache this promise.\n  if (cacheMap) {\n    cacheMap.set(cacheKey, promise);\n  }\n\n  return promise;\n}\n```\n\n我们可以看到，`load` 函数首先通过 `getCurrentBatch` 获取了当前的 `Batch` 对象。之后检查缓存是否存在，如果缓存存在，并且要请求的这个 `key` 命中缓存，则将已经缓存的 promise 放到 `Batch` 对象的 `cacheHits` 数组中去。`load` 函数本身会返回一个 Promise，在这个 Promise 中返回被缓存的 promise。\n\n如果没有命中缓存，即需要发送请求获取数据，则将 `key` 放入到 `Batch` 对象的 `keys` 数组中去，同时新建一个 Promise，并将它的 `resolve` 和 `reject` 放到 `Batch` 对象的 `callbacks` 中。最后在返回这个 Promise 之前，还需要将 Promise 放入到缓存中，这样后面的相同请求可以命中缓存。\n\n需要注意的是，`cacheHits` 是一组函数，函数中包装了 `load` 函数返回的 Promise 的 `resolve` 和 `reject` 回调。而 `callbacks` 中保存的是一个记录了 `load` 函数返回的 Promise 的 `resolve` 和 `reject` 回调的对象。这样，当批量函数返回的时候，通过调用 `cacheHits` 中的函数或者 `callbacks` 中对象保存的回调，就能改变 `load` 函数返回的 Promise 的状态了。\n\n### `getCurrentBatch`\n\n我们现在来看 `getCurrentBatch` 的实现。\n\n`getCurrentBatch` 函数代码如下：\n\n```ts\nfunction getCurrentBatch<K, V>(loader: DataLoader<K, V, any>): Batch<K, V> {\n  // If there is an existing batch which has not yet dispatched and is within\n  // the limit of the batch size, then return it.\n  var existingBatch = loader._batch;\n  if (\n    existingBatch !== null &&\n    !existingBatch.hasDispatched &&\n    existingBatch.keys.length < loader._maxBatchSize &&\n    (!existingBatch.cacheHits ||\n      existingBatch.cacheHits.length < loader._maxBatchSize)\n  ) {\n    return existingBatch;\n  }\n\n  // Otherwise, create a new batch for this loader.\n  var newBatch = { hasDispatched: false, keys: [], callbacks: [] };\n\n  // Store it on the loader so it may be reused.\n  loader._batch = newBatch;\n\n  // Then schedule a task to dispatch this batch of requests.\n  loader._batchScheduleFn(() => {\n    dispatchBatch(loader, newBatch);\n  });\n\n  return newBatch;\n}\n```\n\n`getCurrentBatch` 首先会判断当前 Dataloader 实例上是否已经有 `Batch` 对象，并且当前 `Batch` 还没有发送请求，同时还要检查当前需要发请求的 `keys` 长度或者命中了缓存的请求数组长度小于 `maxBatchSize`，如果这些条件都成立，则返回已经存在的 `Batch` 对象，否则新建一个。\n\n新建的 `Batch` 对象会存放在当前 Dataloader 实例上以便复用。同时，会使用当前 Dataloader 实例的批处理调度函数 `batchScheduleFn` 来调度新创建的 `Batch` 对象。\n\n现在汇总一下，`load` 函数会构建或获取（已存在的）一个 `Batch` 对象，如果 `key` 命中缓存，就返回缓存的 Promise。如果没有命中，则新建一个 Promise，然后将设置 `Batch` 对象的 `keys` 和 `callbacks`，使得在批处理结束后能正确的改变 Promise 的状态，返回数据。\n\n在 `Batch` 的创建过程中，`Batch` 对象会将其自己交给 Dataloader 实例的 `batchScheduleFn` 来调度，`batchScheduleFn` 会通过 `dispatchBatch` 函数来发送批量请求。\n\n### dispatchBatch\n\n`dispatchBatch` 的实现如下：\n\n```ts\nfunction dispatchBatch<K, V>(\n  loader: DataLoader<K, V, any>,\n  batch: Batch<K, V>\n) {\n  // Mark this batch as having been dispatched.\n  batch.hasDispatched = true;\n\n  // If there's nothing to load, resolve any cache hits and return early.\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  }\n\n  // Call the provided batchLoadFn for this loader with the batch's keys and\n  // with the loader as the `this` context.\n  var batchPromise = loader._batchLoadFn(batch.keys);\n\n  // Await the resolution of the call to batchLoadFn.\n  batchPromise\n    .then((values) => {\n      // Resolve all cache hits in the same micro-task as freshly loaded values.\n      resolveCacheHits(batch);\n\n      // Step through values, resolving or rejecting each Promise in the batch.\n      for (var i = 0; i < batch.callbacks.length; i++) {\n        var value = values[i];\n        if (value instanceof Error) {\n          batch.callbacks[i].reject(value);\n        } else {\n          batch.callbacks[i].resolve(value);\n        }\n      }\n    })\n    .catch((error) => {\n      failedDispatch(loader, batch, error);\n    });\n}\n```\n\n首先 `dispatchBatch` 是否需要发送请求，如果 `keys` 长度为零，即全部命中缓存，则直接调用 `resolveCacheHits` 并返回。`resolveCacheHits` 会直接一次调用 `Batch` 对象中 `cacheHits` 里面的函数，此时 `load` 就拿到了缓存的结果（Promise 到了 resolved 的状态）。\n\n```ts\nfunction resolveCacheHits(batch: Batch<any, any>) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n}\n```\n\n如果有需要请求的，则使用创建 Dataloader 实例的时候传入的 `batchLoadFn` 来批量发起请求。\n\n然后，在 `batchLoadFn` 返回之后，先通过 `resolveCacheHits` 返回命中的缓存，之后，依次根据 `batchLoadFn` 返回的结果，如果出错了则调用 `callbacks` 中对象的 `reject`，如果正确返回则调用 `callbacks` 中对象的 `resolve`。\n\n这样就可以将批量请求的结果正确的传递回 `load` 函数了。\n\n如果批量请求出错了，则会调用 `failedDispatch` 函数。\n\n```ts\nfunction failedDispatch<K, V>(\n  loader: DataLoader<K, V, any>,\n  batch: Batch<K, V>,\n  error: Error\n) {\n  // Cache hits are resolved, even though the batch failed.\n  resolveCacheHits(batch);\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error);\n  }\n}\n```\n\n`failedDispatch` 函数会先返回命中的缓存，之后会为每一个需要请求的 key 返回错误信息，同时会通过 `clear` 函数清理缓存的信息（因为已经发生了错误）。\n\n到这里，我们已经知道在调用 `load` 函数之后发生的所有事情了。但是有一点还没有说清楚，就是批量请求的调度策略。\n\n## 批量调度策略\n\nDataloader 支持自定义调度策略，如果没有指定，则使用默认的，如下。\n\n```ts\nvar enqueuePostPromiseJob =\n  typeof process === 'object' && typeof process.nextTick === 'function'\n    ? function (fn) {\n        if (!resolvedPromise) {\n          resolvedPromise = Promise.resolve();\n        }\n        resolvedPromise.then(() => {\n          process.nextTick(fn);\n        });\n      }\n    : setImmediate || setTimeout;\n\n// Private: cached resolved Promise instance\nvar resolvedPromise;\n```\n\n首先检测环境，如果 `process.nextTick` 不存在的话，就直接使用 `setImmediate` 或者 `setTimeout`。\n\n如果 `process.nextTick` 存在的话，通过 Promise 的方式起一个微任务，在这个微任务中告诉 NodeJS 在下一个时间周期内发送批量请求。\n\n这样的话，Dataloader 就可以在当前时间周期内尽可能多的收集需要请求的 `key` 了。\n\n## loadMany 函数\n\n`load` 函数一次只查询一个，`loadMany` 可以查询多个。下面是 `loadMany` 函数的代码，可以看到，就是对 `load` 函数的封装，这里就不在赘述了。\n\n```ts\nloadMany(keys: $ReadOnlyArray<K>): Promise<Array<V | Error>> {\n    // Support ArrayLike by using only minimal property access\n    const loadPromises = [];\n    for (let i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i]).catch(error => error));\n    }\n    return Promise.all(loadPromises);\n  }\n```\n",contentRendered:'<p>Dataloader 的批处理能力，可以实现在一个周期内将多次数据请求进行合并，最终只向远程数据源发送一次请求。这个周期不是固定的，Dataloader 的默认实现是 NodeJS 事件循环的一个循环周期，用户也可以自定义周期。</p>\n<p>如下是 Dataloader 的构造函数的签名：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token function">constructor</span><span class="token punctuation">(</span>batchLoadFn<span class="token operator">:</span> DataLoader<span class="token punctuation">.</span>BatchLoadFn<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span><span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token operator">:</span> DataLoader<span class="token punctuation">.</span>Options<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>首先是一个批量请求函数 <code>batchLoadFn</code>，告诉 Dataloader 如何批量发起请求。其次 <code>options</code> 参数中有是三个配置项关于批处理的：</p>\n<ul>\n<li>batch 是否启用批量请求，false 为不启用，每次数据请求都会向远程数据源发起请求。默认为 true</li>\n<li>maxBatchSize 一次最多可以请求多少个数据，超过这个数字的请求会放到下一批请求中。默认不限制。</li>\n<li>batchScheduleFn 批量调度函数，告诉 Dataloader 什么时候发起批量请求。</li>\n</ul>\n<p>Dataloader 提供了两个函数来获取数据：</p>\n<ul>\n<li><code>load(key: K): Promise&lt;V&gt;;</code></li>\n<li><code>loadMany(keys: ArrayLike&lt;K&gt;): Promise&lt;Array&lt;V | Error&gt;&gt;;</code></li>\n</ul>\n<p>显而易见，一个是一次获取一个，一个是一次获取多个。</p>\n<p>在讲这两个函数的具体实现之前，我们先来了解下 Dataloader 中的基本概念。</p>\n<h2 id="什么是-batch" tabindex="-1"><a class="header-anchor" href="#什么是-batch" aria-hidden="true">#</a> 什么是 Batch</h2>\n<p>前面说过，Dataloader 会搜集一个周期内的所有数据调用，然后合并成一个数据请求。<code>Batch</code> 对象就是这个能力的载体。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Batch<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  hasDispatched<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>\n  keys<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">K</span><span class="token operator">></span><span class="token punctuation">;</span>\n  callbacks<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token punctuation">{</span>\n    <span class="token function-variable function">resolve</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">V</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n    <span class="token function-variable function">reject</span><span class="token operator">:</span> <span class="token punctuation">(</span>error<span class="token operator">:</span> Error<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>\n  cacheHits<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这是 <code>Batch</code> 的类型定义，<code>hasDispatched</code> 表示当前批的请求是否已经发出。<code>keys</code> 中存放着需要通过请求获取数据的 <code>key</code> 列表。<code>callbacks</code> 是对应于每一个 <code>key</code> 的请求回调，且是一一对应的关系。<code>cacheHits</code> 是命中缓存的数据列表。</p>\n<p>Dataloader 会尽量利用缓存不重复请求相同的数据。也就是说，假如一个周期内有 10 个数据请求，其中有两个会命中缓存，那么 <code>keys</code> 的长度就是 8，<code>cacheHits</code> 的长度是 2。</p>\n<p>举个例子，假如我们需要查询用户的好友的好友。用户 A 有好友 B 和 C。用户 D 有好友 C 和 E。假设我们有一个 <code>loaderUser</code> 的接口查询用户信息。那么通常情况下，需要查询 6（3 + 3）次。使用了 Dataloader 的话，只需要请求 5（3 + 2）次，因为 A 和 D 有个共同好友 C，第二次查询用户 C 的时候会命中缓存。</p>\n<p>Dataloader 会将一个周期内的数据请求都存放在一个 <code>Batch</code> 对象内（如果不超过 <code>maxBatchSize</code> 的话），之后通过调用构造函数传入的 <code>batchLoadFn</code> 一次查询所有的数据。</p>\n<h2 id="batchloadfn-批量请求函数" tabindex="-1"><a class="header-anchor" href="#batchloadfn-批量请求函数" aria-hidden="true">#</a> batchLoadFn 批量请求函数</h2>\n<p>先看一个批量函数的 demo。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">batchFunction</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">fetchAllKeys</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> keys<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">=></span> results<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">No result for </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataLoader</span><span class="token punctuation">(</span>batchFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Dataloader 对 <code>batchLoadFn</code> 函数有两个约束：</p>\n<ul>\n<li>函数的返回数组长度必须与 <code>keys</code> 数组长度一致。</li>\n<li>函数的返回数组内的元素必须与 <code>keys</code> 内的元素一一对应。</li>\n</ul>\n<p>也就是说，假如请求的 <code>keys</code> 列表为 <code>[2, 9, 6, 1]</code>，如果数据接口只返回了</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">\'Chicago\'</span> <span class="token punctuation">}</span>\n<span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">\'New York\'</span> <span class="token punctuation">}</span>\n<span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">\'San Francisco\'</span> <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>那么我们的 <code>batchLoadFn</code> 需要返回：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token punctuation">[</span>\n  <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">\'San Francisco\'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">\'Chicago\'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 或者 `new Error()`</span>\n  <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">\'New York\'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>注意，<code>batchLoadFn</code> 需要返回一个 Promise。</p>\n<h2 id="load-函数" tabindex="-1"><a class="header-anchor" href="#load-函数" aria-hidden="true">#</a> <code>load</code> 函数</h2>\n<p><code>load</code> 函数的签名是 <code>load(key: K): Promise&lt;V&gt;</code>，关键代码如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token function">load</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">></span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> batch <span class="token operator">=</span> <span class="token function">getCurrentBatch</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> cacheMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_cacheMap<span class="token punctuation">;</span>\n  <span class="token keyword">var</span> cacheKey <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_cacheKeyFn</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// If caching and there is a cache-hit, return cached Promise.</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> cachedPromise <span class="token operator">=</span> cacheMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedPromise<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> cacheHits <span class="token operator">=</span> batch<span class="token punctuation">.</span>cacheHits <span class="token operator">||</span> <span class="token punctuation">(</span>batch<span class="token punctuation">.</span>cacheHits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span>resolve <span class="token operator">=></span> <span class="token punctuation">{</span>\n        cacheHits<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          <span class="token function">resolve</span><span class="token punctuation">(</span>cachedPromise<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// Otherwise, produce a new Promise for this key, and enqueue it to be</span>\n  <span class="token comment">// dispatched along with the current batch.</span>\n  batch<span class="token punctuation">.</span>keys<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    batch<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> resolve<span class="token punctuation">,</span> reject <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// If caching, cache this promise.</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    cacheMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> promise<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>我们可以看到，<code>load</code> 函数首先通过 <code>getCurrentBatch</code> 获取了当前的 <code>Batch</code> 对象。之后检查缓存是否存在，如果缓存存在，并且要请求的这个 <code>key</code> 命中缓存，则将已经缓存的 promise 放到 <code>Batch</code> 对象的 <code>cacheHits</code> 数组中去。<code>load</code> 函数本身会返回一个 Promise，在这个 Promise 中返回被缓存的 promise。</p>\n<p>如果没有命中缓存，即需要发送请求获取数据，则将 <code>key</code> 放入到 <code>Batch</code> 对象的 <code>keys</code> 数组中去，同时新建一个 Promise，并将它的 <code>resolve</code> 和 <code>reject</code> 放到 <code>Batch</code> 对象的 <code>callbacks</code> 中。最后在返回这个 Promise 之前，还需要将 Promise 放入到缓存中，这样后面的相同请求可以命中缓存。</p>\n<p>需要注意的是，<code>cacheHits</code> 是一组函数，函数中包装了 <code>load</code> 函数返回的 Promise 的 <code>resolve</code> 和 <code>reject</code> 回调。而 <code>callbacks</code> 中保存的是一个记录了 <code>load</code> 函数返回的 Promise 的 <code>resolve</code> 和 <code>reject</code> 回调的对象。这样，当批量函数返回的时候，通过调用 <code>cacheHits</code> 中的函数或者 <code>callbacks</code> 中对象保存的回调，就能改变 <code>load</code> 函数返回的 Promise 的状态了。</p>\n<h3 id="getcurrentbatch" tabindex="-1"><a class="header-anchor" href="#getcurrentbatch" aria-hidden="true">#</a> <code>getCurrentBatch</code></h3>\n<p>我们现在来看 <code>getCurrentBatch</code> 的实现。</p>\n<p><code>getCurrentBatch</code> 函数代码如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getCurrentBatch</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>loader<span class="token operator">:</span> DataLoader<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> Batch<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span> <span class="token punctuation">{</span>\n  <span class="token comment">// If there is an existing batch which has not yet dispatched and is within</span>\n  <span class="token comment">// the limit of the batch size, then return it.</span>\n  <span class="token keyword">var</span> existingBatch <span class="token operator">=</span> loader<span class="token punctuation">.</span>_batch<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>\n    existingBatch <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>\n    <span class="token operator">!</span>existingBatch<span class="token punctuation">.</span>hasDispatched <span class="token operator">&amp;&amp;</span>\n    existingBatch<span class="token punctuation">.</span>keys<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> loader<span class="token punctuation">.</span>_maxBatchSize <span class="token operator">&amp;&amp;</span>\n    <span class="token punctuation">(</span><span class="token operator">!</span>existingBatch<span class="token punctuation">.</span>cacheHits <span class="token operator">||</span>\n      existingBatch<span class="token punctuation">.</span>cacheHits<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> loader<span class="token punctuation">.</span>_maxBatchSize<span class="token punctuation">)</span>\n  <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> existingBatch<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// Otherwise, create a new batch for this loader.</span>\n  <span class="token keyword">var</span> newBatch <span class="token operator">=</span> <span class="token punctuation">{</span> hasDispatched<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> keys<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> callbacks<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Store it on the loader so it may be reused.</span>\n  loader<span class="token punctuation">.</span>_batch <span class="token operator">=</span> newBatch<span class="token punctuation">;</span>\n\n  <span class="token comment">// Then schedule a task to dispatch this batch of requests.</span>\n  loader<span class="token punctuation">.</span><span class="token function">_batchScheduleFn</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">dispatchBatch</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> newBatch<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> newBatch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><code>getCurrentBatch</code> 首先会判断当前 Dataloader 实例上是否已经有 <code>Batch</code> 对象，并且当前 <code>Batch</code> 还没有发送请求，同时还要检查当前需要发请求的 <code>keys</code> 长度或者命中了缓存的请求数组长度小于 <code>maxBatchSize</code>，如果这些条件都成立，则返回已经存在的 <code>Batch</code> 对象，否则新建一个。</p>\n<p>新建的 <code>Batch</code> 对象会存放在当前 Dataloader 实例上以便复用。同时，会使用当前 Dataloader 实例的批处理调度函数 <code>batchScheduleFn</code> 来调度新创建的 <code>Batch</code> 对象。</p>\n<p>现在汇总一下，<code>load</code> 函数会构建或获取（已存在的）一个 <code>Batch</code> 对象，如果 <code>key</code> 命中缓存，就返回缓存的 Promise。如果没有命中，则新建一个 Promise，然后将设置 <code>Batch</code> 对象的 <code>keys</code> 和 <code>callbacks</code>，使得在批处理结束后能正确的改变 Promise 的状态，返回数据。</p>\n<p>在 <code>Batch</code> 的创建过程中，<code>Batch</code> 对象会将其自己交给 Dataloader 实例的 <code>batchScheduleFn</code> 来调度，<code>batchScheduleFn</code> 会通过 <code>dispatchBatch</code> 函数来发送批量请求。</p>\n<h3 id="dispatchbatch" tabindex="-1"><a class="header-anchor" href="#dispatchbatch" aria-hidden="true">#</a> dispatchBatch</h3>\n<p><code>dispatchBatch</code> 的实现如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">dispatchBatch</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>\n  loader<span class="token operator">:</span> DataLoader<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">,</span>\n  batch<span class="token operator">:</span> Batch<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span>\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Mark this batch as having been dispatched.</span>\n  batch<span class="token punctuation">.</span>hasDispatched <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// If there\'s nothing to load, resolve any cache hits and return early.</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>batch<span class="token punctuation">.</span>keys<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">resolveCacheHits</span><span class="token punctuation">(</span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// Call the provided batchLoadFn for this loader with the batch\'s keys and</span>\n  <span class="token comment">// with the loader as the `this` context.</span>\n  <span class="token keyword">var</span> batchPromise <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">_batchLoadFn</span><span class="token punctuation">(</span>batch<span class="token punctuation">.</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Await the resolution of the call to batchLoadFn.</span>\n  batchPromise\n    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// Resolve all cache hits in the same micro-task as freshly loaded values.</span>\n      <span class="token function">resolveCacheHits</span><span class="token punctuation">(</span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// Step through values, resolving or rejecting each Promise in the batch.</span>\n      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> batch<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">var</span> value <span class="token operator">=</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          batch<span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n          batch<span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">failedDispatch</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> batch<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>首先 <code>dispatchBatch</code> 是否需要发送请求，如果 <code>keys</code> 长度为零，即全部命中缓存，则直接调用 <code>resolveCacheHits</code> 并返回。<code>resolveCacheHits</code> 会直接一次调用 <code>Batch</code> 对象中 <code>cacheHits</code> 里面的函数，此时 <code>load</code> 就拿到了缓存的结果（Promise 到了 resolved 的状态）。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">resolveCacheHits</span><span class="token punctuation">(</span>batch<span class="token operator">:</span> Batch<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>batch<span class="token punctuation">.</span>cacheHits<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> batch<span class="token punctuation">.</span>cacheHits<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      batch<span class="token punctuation">.</span>cacheHits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果有需要请求的，则使用创建 Dataloader 实例的时候传入的 <code>batchLoadFn</code> 来批量发起请求。</p>\n<p>然后，在 <code>batchLoadFn</code> 返回之后，先通过 <code>resolveCacheHits</code> 返回命中的缓存，之后，依次根据 <code>batchLoadFn</code> 返回的结果，如果出错了则调用 <code>callbacks</code> 中对象的 <code>reject</code>，如果正确返回则调用 <code>callbacks</code> 中对象的 <code>resolve</code>。</p>\n<p>这样就可以将批量请求的结果正确的传递回 <code>load</code> 函数了。</p>\n<p>如果批量请求出错了，则会调用 <code>failedDispatch</code> 函数。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">failedDispatch</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>\n  loader<span class="token operator">:</span> DataLoader<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">></span><span class="token punctuation">,</span>\n  batch<span class="token operator">:</span> Batch<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span><span class="token punctuation">,</span>\n  error<span class="token operator">:</span> Error\n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Cache hits are resolved, even though the batch failed.</span>\n  <span class="token function">resolveCacheHits</span><span class="token punctuation">(</span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> batch<span class="token punctuation">.</span>keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    loader<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>batch<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    batch<span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><code>failedDispatch</code> 函数会先返回命中的缓存，之后会为每一个需要请求的 key 返回错误信息，同时会通过 <code>clear</code> 函数清理缓存的信息（因为已经发生了错误）。</p>\n<p>到这里，我们已经知道在调用 <code>load</code> 函数之后发生的所有事情了。但是有一点还没有说清楚，就是批量请求的调度策略。</p>\n<h2 id="批量调度策略" tabindex="-1"><a class="header-anchor" href="#批量调度策略" aria-hidden="true">#</a> 批量调度策略</h2>\n<p>Dataloader 支持自定义调度策略，如果没有指定，则使用默认的，如下。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">var</span> enqueuePostPromiseJob <span class="token operator">=</span>\n  <span class="token keyword">typeof</span> process <span class="token operator">===</span> <span class="token string">\'object\'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> process<span class="token punctuation">.</span>nextTick <span class="token operator">===</span> <span class="token string">\'function\'</span>\n    <span class="token operator">?</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>resolvedPromise<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          resolvedPromise <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        resolvedPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token operator">:</span> setImmediate <span class="token operator">||</span> setTimeout<span class="token punctuation">;</span>\n\n<span class="token comment">// Private: cached resolved Promise instance</span>\n<span class="token keyword">var</span> resolvedPromise<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>首先检测环境，如果 <code>process.nextTick</code> 不存在的话，就直接使用 <code>setImmediate</code> 或者 <code>setTimeout</code>。</p>\n<p>如果 <code>process.nextTick</code> 存在的话，通过 Promise 的方式起一个微任务，在这个微任务中告诉 NodeJS 在下一个时间周期内发送批量请求。</p>\n<p>这样的话，Dataloader 就可以在当前时间周期内尽可能多的收集需要请求的 <code>key</code> 了。</p>\n<h2 id="loadmany-函数" tabindex="-1"><a class="header-anchor" href="#loadmany-函数" aria-hidden="true">#</a> loadMany 函数</h2>\n<p><code>load</code> 函数一次只查询一个，<code>loadMany</code> 可以查询多个。下面是 <code>loadMany</code> 函数的代码，可以看到，就是对 <code>load</code> 函数的封装，这里就不在赘述了。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token function">loadMany</span><span class="token punctuation">(</span>keys<span class="token operator">:</span> $ReadOnlyArray<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">V</span> <span class="token operator">|</span> Error<span class="token operator">>></span> <span class="token punctuation">{</span>\n    <span class="token comment">// Support ArrayLike by using only minimal property access</span>\n    <span class="token keyword">const</span> loadPromises <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      loadPromises<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>error <span class="token operator">=></span> error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>loadPromises<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-07",deps:[],hoistedTags:[],links:[],pathInferred:"/code-reading/dataloader/batch.html",pathLocale:"/",permalink:null,slug:"batch",filePath:"/Users/bingooo/workspace/everfind/website/docs/code-reading/dataloader/batch.md",filePathRelative:"code-reading/dataloader/batch.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/code-reading/dataloader/batch.html.vue",componentFilePathRelative:"pages/code-reading/dataloader/batch.html.vue",componentFileChunkName:"v-6ad29ef2",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/code-reading/dataloader/batch.html.js",dataFilePathRelative:"pages/code-reading/dataloader/batch.html.js",dataFileChunkName:"v-6ad29ef2",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/code-reading/dataloader/batch.html",htmlFilePathRelative:"code-reading/dataloader/batch.html"},{key:"v-47667582",path:"/code-reading/dataloader/cache.html",title:"Dataloader 缓存能力解读",lang:"zh-CN",frontmatter:{title:"Dataloader 缓存能力解读",description:"Dataloader 通过缓存来避免一个周期内重复请求相同的数据。默认缓存是一个 Map 对象，我们也可以自定义。本文介绍 Dataloader 的缓存实现原理和相关操作说明。",keywords:["dataloader","cache","缓存"],date:"2021-08-08T00:00:00.000Z",key:2},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"缓存的实现",slug:"缓存的实现",children:[]},{level:2,title:"使用请求级别的缓存",slug:"使用请求级别的缓存",children:[]},{level:2,title:"命中缓存与批处理",slug:"命中缓存与批处理",children:[]},{level:2,title:"手动缓存数据 prime",slug:"手动缓存数据-prime",children:[]},{level:2,title:"清除缓存",slug:"清除缓存",children:[]}],content:"\n在 Dataloader 的构造函数中，有三个配置项与缓存有关：\n\n- `cache` 是否开启缓存，为 true 表示开启缓存，默认为 true。\n- `cacheKeyFn` 缓存 key 的生成函数，从 `load` 函数的 key 生成缓存 key.\n- `cacheMap` 存储数据的缓存对象，默认为 `new Map()`，也可以是满足要求的任何对象。\n\n## 缓存的实现\n\n我们[上一篇](./batch.md)说过，`load` 函数每次都会先检查一次缓存，如果缓存直接命中，就直接返回缓存的数据。\n\n```ts\n// load 函数的部分实现\nvar cacheMap = this._cacheMap;\n\nif (cacheMap) {\n  var cachedPromise = cacheMap.get(cacheKey);\n  if (cachedPromise) {\n    var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n    return new Promise((resolve) => {\n      cacheHits.push(() => {\n        resolve(cachedPromise);\n      });\n    });\n  }\n}\n```\n\n`this._cacheMap` 是在构造函数中通过 `getValidCacheMap` 获取的。\n\n```ts\nfunction getValidCacheMap<K, V, C>(\n  options: ?Options<K, V, C>\n): CacheMap<C, Promise<V>> | null {\n  var shouldCache = !options || options.cache !== false;\n  if (!shouldCache) {\n    return null;\n  }\n  var cacheMap = options && options.cacheMap;\n  if (cacheMap === undefined) {\n    return new Map();\n  }\n  if (cacheMap !== null) {\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\n    var missingFunctions = cacheFunctions.filter(\n      (fnName) => cacheMap && typeof cacheMap[fnName] !== 'function'\n    );\n    if (missingFunctions.length !== 0) {\n      throw new TypeError(\n        'Custom cacheMap missing methods: ' + missingFunctions.join(', ')\n      );\n    }\n  }\n  return cacheMap;\n}\n```\n\n从 `getValidCacheMap` 的代码可以看到，如果没有指定 `cacheMap`，则默认是返回 `new Map()` 作为缓存对象。\n\n如果指定了 `cacheMap`，则会校验指定的对象是否满足 `get`、`set`、`delete`、`clear` 这四个接口，如果满足则使用，否则报错。也就是说，用户指定的缓存对象必须要有这四个函数才能被 Dataloader 使用。\n\n## 使用请求级别的缓存\n\n从 `load` 函数的代码可以看到，每次调用 `load(key)`，都会先尝试从缓存中读取。不同的用户访问同一个资源可能获取的信息不同，比如权限不同等。如果使用全局缓存的话，会导致各种各样的问题。因此，我们需要确保只缓存单次请求级别。\n\n有两种方式可以实现，一种是确保 Dataloader 是请求级别，及在请求的开始实例化 Dataloader。\n\n下面的代码展示了如何在 express 中使用请求级别的 Dataloader.\n\n```js\nfunction createLoaders(authToken) {\n  return {\n    users: new DataLoader((ids) => genUsers(authToken, ids)),\n  };\n}\n\nconst app = express();\n\napp.get('/', function (req, res) {\n  const authToken = authenticateUser(req);\n  const loaders = createLoaders(authToken);\n  res.send(renderPage(req, loaders));\n});\n\napp.listen();\n```\n\n另一种是借助于 [async_hooks](https://nodejs.org/api/async_hooks.html) 模块，全局缓存来管理请求缓存，即每次请求的缓存单独管理，请求结束释放缓存。因为一些限制，无法使用第一种方式，笔者在项目中使用了这个方法，受篇幅限制这里我们不做详细实现了。\n\n## 命中缓存与批处理\n\n在 `load` 函数的源码解读中我们可以看到，即使命中了缓存，函数的调用结果也不是立即返回的，而是等到与 `batchLoadFn` 的结果一起返回。也就是说命中缓存的调用和需要发起请求的调用会一起返回。为什么这么设计的？这么做是为了 Dataloader 能为后续的数据请求做优化。\n\n举个例子，假如 `User 1` 一开始是被缓存了的（借助于 `prime` 函数，后面说）。但是因为 `User 1` 和 `User 2` 是一个时间周期内调用的，那么他们的结果也会在同一时间返回。这样的话，后续的 `user.bestFriendID` 请求也会在下一个时间周期同时请求。那么，总共会想远端服务发送两个请求（查用户一次，查好友一次）。\n\n```js\nuserLoader.prime(1, { bestFriend: 3 });\n\nasync function getBestFriend(userID) {\n  const user = await userLoader.load(userID);\n  return await userLoader.load(user.bestFriendID);\n}\n\n// In one part of your application\ngetBestFriend(1);\n\n// Elsewhere\ngetBestFriend(2);\n```\n\n如果命中的缓存立即返回的话，那么查 `User 1` 好友的请求可能会提前发出，那么就可能会造成总共需要发送三次数据查询请求了。因为每个 `user.bestFriendID` 的查询时间不一样。\n\n## 手动缓存数据 `prime`\n\n`prime` 函数允许我们手动地向缓存中插入数据。代码如下：\n\n```ts\nprime(key: K, value: V | Error): this {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n\n      // Only add the key if it does not already exist.\n      if (cacheMap.get(cacheKey) === undefined) {\n        // Cache a rejected promise if the value is an Error, in order to match\n        // the behavior of load(key).\n        var promise;\n        if (value instanceof Error) {\n          promise = Promise.reject(value);\n          // Since this is a case where an Error is intentionally being primed\n          // for a given key, we want to disable unhandled promise rejection.\n          promise.catch(() => {});\n        } else {\n          promise = Promise.resolve(value);\n        }\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n    return this;\n  }\n}\n```\n\n我们可以看到，如果要插入缓存的 key 已经存在，则直接忽略，不会更新缓存。否则会向缓存中插入一个 Promise，然后等待 `batchScheduleFn` 调度。\n\n`prime` 函数还支持缓存错误信息，只需要保证缓存的值是 `Error` 类的一个实例就可以了。\n\n## 清除缓存\n\nDataloader 有两个 API 可以清除缓存：`clear` 和 `clearAll`。他们的代码都非常简单，就不做过多说明了。代码如下：\n\n```ts\n// clear 函数实现\nclear(key: K): this {\n  var cacheMap = this._cacheMap;\n  if (cacheMap) {\n    var cacheKey = this._cacheKeyFn(key);\n    cacheMap.delete(cacheKey);\n  }\n  return this;\n}\n\n// clearAll 函数实现\nclearAll(): this {\n  var cacheMap = this._cacheMap;\n  if (cacheMap) {\n    cacheMap.clear();\n  }\n  return this;\n}\n```\n",contentRendered:'<p>在 Dataloader 的构造函数中，有三个配置项与缓存有关：</p>\n<ul>\n<li><code>cache</code> 是否开启缓存，为 true 表示开启缓存，默认为 true。</li>\n<li><code>cacheKeyFn</code> 缓存 key 的生成函数，从 <code>load</code> 函数的 key 生成缓存 key.</li>\n<li><code>cacheMap</code> 存储数据的缓存对象，默认为 <code>new Map()</code>，也可以是满足要求的任何对象。</li>\n</ul>\n<h2 id="缓存的实现" tabindex="-1"><a class="header-anchor" href="#缓存的实现" aria-hidden="true">#</a> 缓存的实现</h2>\n<p>我们<RouterLink to="/code-reading/dataloader/batch.html">上一篇</RouterLink>说过，<code>load</code> 函数每次都会先检查一次缓存，如果缓存直接命中，就直接返回缓存的数据。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token comment">// load 函数的部分实现</span>\n<span class="token keyword">var</span> cacheMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_cacheMap<span class="token punctuation">;</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>cacheMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> cachedPromise <span class="token operator">=</span> cacheMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedPromise<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> cacheHits <span class="token operator">=</span> batch<span class="token punctuation">.</span>cacheHits <span class="token operator">||</span> <span class="token punctuation">(</span>batch<span class="token punctuation">.</span>cacheHits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      cacheHits<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token function">resolve</span><span class="token punctuation">(</span>cachedPromise<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><code>this._cacheMap</code> 是在构造函数中通过 <code>getValidCacheMap</code> 获取的。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">getValidCacheMap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>\n  options<span class="token operator">:</span> <span class="token operator">?</span>Options<span class="token operator">&lt;</span><span class="token constant">K</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token operator">></span>\n<span class="token punctuation">)</span><span class="token operator">:</span> CacheMap<span class="token operator">&lt;</span><span class="token constant">C</span><span class="token punctuation">,</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">>></span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> shouldCache <span class="token operator">=</span> <span class="token operator">!</span>options <span class="token operator">||</span> options<span class="token punctuation">.</span>cache <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldCache<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">var</span> cacheMap <span class="token operator">=</span> options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>cacheMap<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheMap <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheMap <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> cacheFunctions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">\'get\'</span><span class="token punctuation">,</span> <span class="token string">\'set\'</span><span class="token punctuation">,</span> <span class="token string">\'delete\'</span><span class="token punctuation">,</span> <span class="token string">\'clear\'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">var</span> missingFunctions <span class="token operator">=</span> cacheFunctions<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>\n      <span class="token punctuation">(</span>fnName<span class="token punctuation">)</span> <span class="token operator">=></span> cacheMap <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> cacheMap<span class="token punctuation">[</span>fnName<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">\'function\'</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>missingFunctions<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>\n        <span class="token string">\'Custom cacheMap missing methods: \'</span> <span class="token operator">+</span> missingFunctions<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\', \'</span><span class="token punctuation">)</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> cacheMap<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>从 <code>getValidCacheMap</code> 的代码可以看到，如果没有指定 <code>cacheMap</code>，则默认是返回 <code>new Map()</code> 作为缓存对象。</p>\n<p>如果指定了 <code>cacheMap</code>，则会校验指定的对象是否满足 <code>get</code>、<code>set</code>、<code>delete</code>、<code>clear</code> 这四个接口，如果满足则使用，否则报错。也就是说，用户指定的缓存对象必须要有这四个函数才能被 Dataloader 使用。</p>\n<h2 id="使用请求级别的缓存" tabindex="-1"><a class="header-anchor" href="#使用请求级别的缓存" aria-hidden="true">#</a> 使用请求级别的缓存</h2>\n<p>从 <code>load</code> 函数的代码可以看到，每次调用 <code>load(key)</code>，都会先尝试从缓存中读取。不同的用户访问同一个资源可能获取的信息不同，比如权限不同等。如果使用全局缓存的话，会导致各种各样的问题。因此，我们需要确保只缓存单次请求级别。</p>\n<p>有两种方式可以实现，一种是确保 Dataloader 是请求级别，及在请求的开始实例化 Dataloader。</p>\n<p>下面的代码展示了如何在 express 中使用请求级别的 Dataloader.</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createLoaders</span><span class="token punctuation">(</span><span class="token parameter">authToken</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    users<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">DataLoader</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">ids</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">genUsers</span><span class="token punctuation">(</span>authToken<span class="token punctuation">,</span> ids<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\napp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> authToken <span class="token operator">=</span> <span class="token function">authenticateUser</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> loaders <span class="token operator">=</span> <span class="token function">createLoaders</span><span class="token punctuation">(</span>authToken<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">renderPage</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> loaders<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\napp<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>另一种是借助于 <a href="https://nodejs.org/api/async_hooks.html" target="_blank" rel="noopener noreferrer">async_hooks<OutboundLink/></a> 模块，全局缓存来管理请求缓存，即每次请求的缓存单独管理，请求结束释放缓存。因为一些限制，无法使用第一种方式，笔者在项目中使用了这个方法，受篇幅限制这里我们不做详细实现了。</p>\n<h2 id="命中缓存与批处理" tabindex="-1"><a class="header-anchor" href="#命中缓存与批处理" aria-hidden="true">#</a> 命中缓存与批处理</h2>\n<p>在 <code>load</code> 函数的源码解读中我们可以看到，即使命中了缓存，函数的调用结果也不是立即返回的，而是等到与 <code>batchLoadFn</code> 的结果一起返回。也就是说命中缓存的调用和需要发起请求的调用会一起返回。为什么这么设计的？这么做是为了 Dataloader 能为后续的数据请求做优化。</p>\n<p>举个例子，假如 <code>User 1</code> 一开始是被缓存了的（借助于 <code>prime</code> 函数，后面说）。但是因为 <code>User 1</code> 和 <code>User 2</code> 是一个时间周期内调用的，那么他们的结果也会在同一时间返回。这样的话，后续的 <code>user.bestFriendID</code> 请求也会在下一个时间周期同时请求。那么，总共会想远端服务发送两个请求（查用户一次，查好友一次）。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>userLoader<span class="token punctuation">.</span><span class="token function">prime</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> bestFriend<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getBestFriend</span><span class="token punctuation">(</span><span class="token parameter">userID</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> userLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>userID<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">await</span> userLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>bestFriendID<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// In one part of your application</span>\n<span class="token function">getBestFriend</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Elsewhere</span>\n<span class="token function">getBestFriend</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如果命中的缓存立即返回的话，那么查 <code>User 1</code> 好友的请求可能会提前发出，那么就可能会造成总共需要发送三次数据查询请求了。因为每个 <code>user.bestFriendID</code> 的查询时间不一样。</p>\n<h2 id="手动缓存数据-prime" tabindex="-1"><a class="header-anchor" href="#手动缓存数据-prime" aria-hidden="true">#</a> 手动缓存数据 <code>prime</code></h2>\n<p><code>prime</code> 函数允许我们手动地向缓存中插入数据。代码如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token function">prime</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token constant">V</span> <span class="token operator">|</span> Error<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> cacheMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_cacheMap<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">var</span> cacheKey <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_cacheKeyFn</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n      <span class="token comment">// Only add the key if it does not already exist.</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// Cache a rejected promise if the value is an Error, in order to match</span>\n        <span class="token comment">// the behavior of load(key).</span>\n        <span class="token keyword">var</span> promise<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          promise <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token comment">// Since this is a case where an Error is intentionally being primed</span>\n          <span class="token comment">// for a given key, we want to disable unhandled promise rejection.</span>\n          promise<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n          promise <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        cacheMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>我们可以看到，如果要插入缓存的 key 已经存在，则直接忽略，不会更新缓存。否则会向缓存中插入一个 Promise，然后等待 <code>batchScheduleFn</code> 调度。</p>\n<p><code>prime</code> 函数还支持缓存错误信息，只需要保证缓存的值是 <code>Error</code> 类的一个实例就可以了。</p>\n<h2 id="清除缓存" tabindex="-1"><a class="header-anchor" href="#清除缓存" aria-hidden="true">#</a> 清除缓存</h2>\n<p>Dataloader 有两个 API 可以清除缓存：<code>clear</code> 和 <code>clearAll</code>。他们的代码都非常简单，就不做过多说明了。代码如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token comment">// clear 函数实现</span>\n<span class="token function">clear</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> cacheMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_cacheMap<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> cacheKey <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_cacheKeyFn</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    cacheMap<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// clearAll 函数实现</span>\n<span class="token function">clearAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> cacheMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_cacheMap<span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    cacheMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-08",deps:[],hoistedTags:[],links:[{raw:"./batch.md",relative:"code-reading/dataloader/batch.md",absolute:"/code-reading/dataloader/batch.md"}],pathInferred:"/code-reading/dataloader/cache.html",pathLocale:"/",permalink:null,slug:"cache",filePath:"/Users/bingooo/workspace/everfind/website/docs/code-reading/dataloader/cache.md",filePathRelative:"code-reading/dataloader/cache.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/code-reading/dataloader/cache.html.vue",componentFilePathRelative:"pages/code-reading/dataloader/cache.html.vue",componentFileChunkName:"v-47667582",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/code-reading/dataloader/cache.html.js",dataFilePathRelative:"pages/code-reading/dataloader/cache.html.js",dataFileChunkName:"v-47667582",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/code-reading/dataloader/cache.html",htmlFilePathRelative:"code-reading/dataloader/cache.html"}]}},1376:(n,a,s)=>{s.r(a),s.d(a,{default:()=>k});var e=s(6252);const p={href:"https://github.com/graphql/dataloader",target:"_blank",rel:"noopener noreferrer"},t=(0,e.Uk)("Dataloader"),c=(0,e.Uk)(" 最初是为了给服务端在从各种不同的远程数据源（比如数据库、其他服务接口等）获取数据的时候，提供一个简化且一致的 API 而开发。目前广泛应用在 "),o={href:"https://github.com/graphql/graphql-js",target:"_blank",rel:"noopener noreferrer"},l=(0,e.Uk)("GraphQL"),r=(0,e.Uk)(" 服务中。当然，Dataloader 不仅仅可以在 GraphQL 服务中使用，也可以在其他任何服务场景中。"),i=(0,e.Wm)("p",null,"Dataloader 有两大核心特性：批处理和缓存。我们会分别来看这两大核心特性的功能，以及 Dataloader 是如何实现这些特性的。",-1),u=(0,e.uE)('<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',1),k={render:function(n,a){const s=(0,e.up)("OutboundLink"),k=(0,e.up)("ArticleList");return(0,e.wg)(),(0,e.j4)(e.HY,null,[(0,e.Wm)("p",null,[(0,e.Wm)("a",p,[t,(0,e.Wm)(s)]),c,(0,e.Wm)("a",o,[l,(0,e.Wm)(s)]),r]),i,(0,e.Wm)(k,{noTag:!0}),u],64)}}}}]);