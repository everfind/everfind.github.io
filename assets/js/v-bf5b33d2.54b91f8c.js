"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[4798],{7439:(s,n,a)=>{a.r(n),a.d(n,{data:()=>e});const e={key:"v-bf5b33d2",path:"/posts/2022/01/21/esm-in-browser-and-nodejs.html",title:"在浏览器和 NodeJS 中使用 ES Module",lang:"zh-CN",frontmatter:{title:"在浏览器和 NodeJS 中使用 ES Module",description:"ES Module 正在被各大浏览器和 NodeJS 原生支持。本文叙述如何正确地在浏览器和 NodeJS 中使用 ES Module。",keywords:["ES Module"],date:"2022-01-21T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"在浏览器中使用",slug:"在浏览器中使用",children:[]},{level:2,title:"在 NodeJS 中使用",slug:"在-nodejs-中使用",children:[{level:3,title:"exports",slug:"exports",children:[]},{level:3,title:"imports",slug:"imports",children:[]}]},{level:2,title:"小结",slug:"小结",children:[]}],filePathRelative:"posts/esm-in-browser-and-nodejs.md"}},5204:(s,n,a)=>{a.r(n),a.d(n,{default:()=>x});var e=a(6252);const p=(0,e.Uk)("前面我们在"),o=(0,e.Uk)("深入理解 ES Module"),t=(0,e.Uk)(" 中详细介绍过 ES Module 的工作原理。目前，ES Module 已经在逐步得到各大浏览器厂商以及 NodeJS 的原生支持。像 vite 等新一代的构建工具已经逐步使用 ES Module 并有计划的运用到生产环境中。因此，了解如何在浏览器以及 NodeJS 中使用 ES Module 是必要的。"),c=(0,e.uE)('<h2 id="在浏览器中使用" tabindex="-1"><a class="header-anchor" href="#在浏览器中使用" aria-hidden="true">#</a> 在浏览器中使用</h2><p>支持 ES Module 的浏览器通过 script 标签上的 <code>type</code> 字段来识别 ES Module，即 <code>type=module</code> 就是 ES Module。</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">;</span>\n  <span class="token keyword">export</span> <span class="token keyword">default</span> foo<span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/path/to/script<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>浏览器在遇到 <code>type=module</code> 的 script 标签时，会将其作为 ES Module 来解析，如果有依赖模块时，会递归的加载依赖模块。模块加载原理与 Webpack 是类似的。</p><p>现在问题来了，浏览器如何加载模块呢？</p><p>有三种主要方式：</p><ul><li>绝对路径，比如 <code>http://domain.com/path/to/module</code></li><li>相对路径，比如：<code>./path/to/module</code></li><li>包名（裸说明符，bare specifier），比如： <code>lodash-es</code></li></ul><p>绝对路径和相对路径都很好理解，与普通的 script 用法是一样的。直接使用包名浏览器如何处理呢？</p><p>我们在使用 Webpack 等打包器的时候，项目依赖的模块是安装在 node_modules 目录下的。在打包器执行构建的时候，会从 node_modules 中查询依赖的包，找到对应的模块，最终将模块代码合并到最终的构建输出文件中。</p>',9),l=(0,e.Uk)("在浏览器中，其实是一样的，只不过我们要告诉浏览器去哪里找这些包。目前有一个规范（草案阶段）给出了解决方案，那就是 "),r={href:"https://wicg.github.io/import-maps/",target:"_blank",rel:"noopener noreferrer"},u=(0,e.Wm)("code",null,"import-map",-1),i=(0,e.Uk)("。我们简单说明一下。"),d=(0,e.uE)('<div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>importmap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token punctuation">{</span>\n  <span class="token string">&quot;imports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token string">&quot;moment&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/node_modules/moment/src/moment.js&quot;</span><span class="token punctuation">,</span>\n    <span class="token string">&quot;lodash&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/node_modules/lodash-es/lodash.js&quot;</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>通过 <code>type=importmap</code> 的 script 标签，来告诉浏览器可以在哪里找到这些模块。</p><p><img src="/posts/images/esm-in-browser-and-nodejs/import-map-caniuse-c.png" alt="import-map 的浏览器支持情况"></p>',3),k=(0,e.Uk)("从 "),m={href:"https://caniuse.com/?search=import-map",target:"_blank",rel:"noopener noreferrer"},b=(0,e.Uk)("caniuse"),g=(0,e.Uk)(" 上看，目前主流浏览器对 "),q=(0,e.Wm)("code",null,"import-map",-1),h=(0,e.Uk)(" 的支持不一，因此，我们还不能在浏览器中直接使用。"),v=(0,e.uE)('<p>现在常规的做法还是经一道打包器的处理，将依赖的模块都打到最终的构建输出中（代码依然是 ES Module）。</p><h2 id="在-nodejs-中使用" tabindex="-1"><a class="header-anchor" href="#在-nodejs-中使用" aria-hidden="true">#</a> 在 NodeJS 中使用</h2><p>NodeJS 有三种方式来识别 ES Module，分别是：</p><ul><li>以 <code>.mjs</code> 后缀结尾的文件。</li><li>以 <code>.js</code> 后缀结尾的文件，但是所在包 <code>package.json</code> 中设置了 <code>type</code> 字段并且值为 <code>module</code>。</li><li>命令行中指定了 <code>--input-type=module</code> 参数</li></ul><p>除了命令行以外，NodeJS 在处理 ES Module 的时候，都与 <code>package.json</code> 中的字段有关，这里详细说明下。</p><p><code>package.json</code> 中与模块处理的字段主要有如下几个。</p><ul><li><code>name</code> 包的名称，可以与 <code>imports</code> 和 <code>exports</code> 配合使用</li><li><code>main</code> 包的默认导出模块</li><li><code>type</code> 用于在加载 <code>.js</code> 文件时确定模块类型</li><li><code>exports</code> 指定包导出了哪些模块</li><li><code>imports</code> 包导入了哪些模块，只供包内部使用</li></ul><p><code>main</code> 字段指定包的默认导出模块，在所有 NodeJS 版本中都适用。同时，<code>exports</code> 字段也可以定义包的入口点，而且除了 <code>exports</code> 定义的入口点以外，包内的其他模块将对外不可见，即 <code>exports</code> 同时还提供了一定的封装特性。</p><p>当 <code>main</code> 和 <code>exports</code> 同时定义的时候，<code>exports</code> 的优先级比 <code>main</code> 更高，即 NodeJS 会忽略 <code>main</code> 中的定义。</p><h3 id="exports" tabindex="-1"><a class="header-anchor" href="#exports" aria-hidden="true">#</a> exports</h3><p><code>exports</code> 字段定义了包导出的模块，有这么几种定义方式，我们分别说明。</p><h4 id="导出" tabindex="-1"><a class="header-anchor" href="#导出" aria-hidden="true">#</a> <code>.</code> 导出</h4><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;.&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./lib/index.js&quot;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>.</code> 导出定义了包的默认导出模块，即 <code>import xxx from &#39;package&#39;</code> 的导出模块。</p><p>如果 <code>.</code> 不与其他导出一同使用的话（就像上面的样例一样），可以简写为：</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./lib/index.js&quot;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="子路径导出" tabindex="-1"><a class="header-anchor" href="#子路径导出" aria-hidden="true">#</a> 子路径导出</h4><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;./lib&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./lib/index.js&quot;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面的例子定义了 <code>import xxx from &#39;package/lib&#39;</code> 导出的模块。当然，如果我们想将 <code>./lib</code> 目录下的所有的模块不受限制的导出的话，可以这么设置：</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;./lib/*&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./lib/*.js&quot;</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>路径中的 <code>*</code> 只做字符串替换，即 <code>import xxx from &#39;package/lib/a/b/c.js&#39;</code> 将会最终被定位到 <code>./node_modules/package/lib/a/b/c.js</code>。</p><blockquote><p><code>exports</code> 中的 <code>./lib</code> 等都是相对于包的根目录而言，且子路径导出都需要以 <code>./</code> 开头。</p></blockquote><p>如果我们想禁止 <code>./lib</code> 目录下的某些模块被外部使用，同时又想通过 <code>*</code> 的方式导出模块，我们可以显式的将某一个目录导出设置为 <code>null</code>，如下。</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n     <span class="token property">&quot;./lib/*&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./lib/*.js&quot;</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;./lib/private-internal/*&quot;</span><span class="token operator">:</span> <span class="token null keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="条件导出" tabindex="-1"><a class="header-anchor" href="#条件导出" aria-hidden="true">#</a> 条件导出</h4><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./main-require.cjs&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;import&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./main-module.js&quot;</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;require&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./main-require.cjs&quot;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;module&quot;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>条件导出支持的条件如下：</p><ul><li><code>node</code> NodeJS 环境下适用，既可以是 ES Module 文件，也可以是 CommonJS 文件，通常不需要显式指定。</li><li><code>node-addons</code> 与 <code>node</code> 类似，用于 NodeJS 插件。</li><li><code>import</code> 当通过 <code>import</code> 或者 <code>import()</code> 方式加载模块时使用，与 <code>require</code> 互斥。</li><li><code>require</code> 当通过 <code>require()</code> 方式加载模块时使用，与 <code>import</code> 互斥。</li><li><code>default</code> 兜底方案，目标文件可以为 CommonJS 文件也可以为 ES Module 文件，通常排在最后。</li></ul><blockquote><p><code>exports</code> 字段中 key 的顺序至关重要，排在前面的优先级更高。因此，排在前面的通常是条件要求最严格的，排在后面的通常是要求最宽泛的。</p></blockquote><blockquote><p>除了上面官方支持的几个条件以外，社区还定义了 <code>types</code>、<code>deno</code>、<code>browser</code>、<code>development</code>、<code>production</code> 等条件。</p></blockquote><p>子路径导出也支持设置条件，如下：</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./main.js&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;.&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./main.js&quot;</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;./feature&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">&quot;node&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./feature-node.js&quot;</span><span class="token punctuation">,</span>\n      <span class="token property">&quot;default&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./feature.js&quot;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>同时，条件导出还支持嵌套，如下，在 <code>node</code> 条件下，又区分了 <code>import</code> 和 <code>require</code> 条件。</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./main.js&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;node&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">&quot;import&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./feature-node.mjs&quot;</span><span class="token punctuation">,</span>\n      <span class="token property">&quot;require&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./feature-node.cjs&quot;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;default&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./feature.mjs&quot;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们可以通过如下方式指定条件：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>node --conditions<span class="token operator">=</span>development main.js\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>上面介绍了几种模块导出方式，这里需要强调的一点是，<code>exports</code> 显示定义了包导出的模块，未在 <code>exports</code> 导出的模块，外界不可访问。<code>exports</code> 给了包的开发者定义对外 API 的能力。</strong></p><h3 id="imports" tabindex="-1"><a class="header-anchor" href="#imports" aria-hidden="true">#</a> imports</h3><p>我们可以通过 <code>imports</code> 定义导入包内模块的快捷方式。<code>imports</code> 字段中所有的 key 都需要以 <code>#</code> 开头。</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;imports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;#dep&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">&quot;node&quot;</span><span class="token operator">:</span> <span class="token string">&quot;dep-node-native&quot;</span><span class="token punctuation">,</span>\n      <span class="token property">&quot;default&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./dep-polyfill.js&quot;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;dependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;dep-node-native&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^1.0.0&quot;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>与 <code>exports</code> 不同的是，<code>imports</code> 允许导入包外模块。上面的样例中，在 <code>node</code> 条件下，<code>import &#39;#dep&#39;</code> 会导入 <code>dep-node-native</code>，在其他环境中，会导入 <code>./dep-polyfill.js</code>。</p><p><code>imports</code> 也支持子路径导入，与 <code>exports</code> 类似，如下：</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;imports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;#internal/*&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./src/internal/*.js&quot;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>效果如下：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">import</span> internalZ <span class="token keyword">from</span> <span class="token string">&#39;#internal/z&#39;</span><span class="token punctuation">;</span>\n<span class="token comment">// Loads ./node_modules/es-module-package/src/internal/z.js</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本文介绍了如何在浏览器和 NodeJS 中使用 ES Module 的方法。</p><p>如果你只是单纯的做页面开发，借助于成熟的构建工具，可能不太需要注意这些细节。但是掌握了基本原理，可以更好的帮助我们排查问题。</p><p>如果你是包开发者，那么如果想要使用 ES Module 并且想让包的使用者也能享受到 ES Module 的优点的话，就需要对模块的导入导出非常熟悉了。</p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',50),x={render:function(s,n){const a=(0,e.up)("RouterLink"),x=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[(0,e.Wm)("p",null,[p,(0,e.Wm)(a,{to:"/posts/deep-dive-into-es-module.html"},{default:(0,e.w5)((()=>[o])),_:1}),t]),c,(0,e.Wm)("p",null,[l,(0,e.Wm)("a",r,[u,(0,e.Wm)(x)]),i]),d,(0,e.Wm)("p",null,[k,(0,e.Wm)("a",m,[b,(0,e.Wm)(x)]),g,q,h]),v],64)}}}}]);