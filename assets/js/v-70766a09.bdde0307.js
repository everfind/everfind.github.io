"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[6370],{3556:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-70766a09",path:"/solutions/micro-frontend/microfrontend.html",title:"理解微前端技术原理",lang:"zh-CN",frontmatter:{title:"理解微前端技术原理",description:"从概念、技术原理、实践经验等层面，对目前主流的微前端架构方案进行分析。",keywords:["micro frontend","微前端","qiankun","single spa"],date:"2021-11-21T00:00:00.000Z",key:1,tags:["概念"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"什么是微前端",slug:"什么是微前端",children:[]},{level:2,title:"技术分析",slug:"技术分析",children:[{level:3,title:"路由与子应用加载",slug:"路由与子应用加载",children:[]},{level:3,title:"隔离",slug:"隔离",children:[]}]},{level:2,title:"需要注意的问题",slug:"需要注意的问题",children:[]}],filePathRelative:"solutions/micro-frontend/microfrontend.md"}},7398:(n,s,a)=>{a.r(s),a.d(s,{default:()=>F});var e=a(6252);const p=(0,e.uE)('<p>我最早是在 2016 年接触到微前端的，当时社区里以介绍概念居多，在实践方案，尤其是在业务落地方面应用的比较少。后来，随着方案逐渐成熟，社区里关于微前端的讨论越来越多。</p><p>今天，我们先从概念、关键技术原理层面来对微前端进行详细说明。后续会有专门的文章来介绍微前端的实践经验。</p><h2 id="什么是微前端" tabindex="-1"><a class="header-anchor" href="#什么是微前端" aria-hidden="true">#</a> 什么是微前端</h2><p>微前端的概念来源于微服务，其整体的架构思路是将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，之后将这些应用组成整体，在用户看来仍然是内聚的单个产品，用户体验是一致的。</p><p>从概念上看，微前端架构由主应用和子应用两个部分组成，子应用负责具体的业务实现，主应用负责子应用的加载和卸载，即生命周期管理。</p><p>从概念延伸开来，我们不难发现，使用微前端，可以获得如下收益：</p><ul><li>子应用独立开发、部署，技术栈无关 拆分以后，子应用拥有独立的代码仓库、独立的开发部署流程，甚至可以自由的使用任何技术栈进行开发。由此，我们可以在组织架构层面形成不同的团队来负责不同的业务模块，各个团队之间相对独立自主，互不干扰。</li><li>增量升级，多技术体系共存 对于很多大型的组织，他们的产品通常都经历了长期的迭代，功能复杂，同时技术栈通常也比较老旧。使用微前端以后，借助于独立的子应用，可以获得增量升级的能力。既可以实现新功能使用新的技术栈，同时与老技术栈共存。又可以对老功能进行逐步迭代升级，小步快跑。</li><li>产品层面的自由组合 借助于微前端，我们可以对各个子应用自由的进行上下线。换句话说，我们可以根据产品需要，自由的将不同的子应用组合成新的产品。</li></ul><h2 id="技术分析" tabindex="-1"><a class="header-anchor" href="#技术分析" aria-hidden="true">#</a> 技术分析</h2><p>在微前端架构下，有主应用和子应用两个基本角色。子应用负责具体的业务逻辑，主应用负责调度子应用。考虑到主应用的特殊性功能，为了保证整个框架的可用性，通常主应用不负责任何业务逻辑。</p><h3 id="路由与子应用加载" tabindex="-1"><a class="header-anchor" href="#路由与子应用加载" aria-hidden="true">#</a> 路由与子应用加载</h3><p>由于主应用负责调度子应用，因此主应用需要具备路由管理和资源加载能力。所谓路由管理，就是主应用中需要维护一个路由表，当页面路由发生变化的时候，主应用可以知道当前需要启动哪个子应用。这个路由表可以是动态的，也可以是静态的。</p><p>知道启动哪个子应用之后，主应用就需要加载子应用的资源。通常有两种资源加载方式：</p>',12),t=(0,e.Uk)("JS Entry。 通常将子应用的所有资源打包成一个入口文件，在 "),o={href:"https://single-spa.js.org/docs/examples",target:"_blank",rel:"noopener noreferrer"},c=(0,e.Uk)("single-spa"),l=(0,e.Uk)(" 的很多样例中就使用了这种方式。"),r=(0,e.Wm)("li",null,"HTML Entry。 子应用构建输出的是一个 HTML 文件，主应用通过加载这个 HTML 文件完成子应用的加载。",-1),i=(0,e.uE)('<p>相比较而言，JS Entry 的方案限制更多一些，比如要求将图片、样式等所有资源打包成一个 JS Bundle，构建的包太大，也无法利用浏览器的并行加载能力。同时，子应用还需要与主应用约定好要挂载的节点，主应用要提前初始化好，或者子应用自行创建，避免挂载失败或者冲突。</p><p>HTML Entry 很好的避免了 JS Entry 的问题。本质上，HTML 文件充当的是应用静态资源表的角色。主应用加载了 HTML 以后，浏览器会自行下载子应用的各种资源。同时，由于构建产物是 HTML，子应用具备与独立应用开发时一致的开发体验。当然，HTML Entry 也存在缺点，比如要多一次请求，先加载了 HTML 才能知道加载哪些资源。</p><p>在加载完子应用的资源以后，主应用就可以启动子应用，完成页面渲染了。那么该如何启动子应用呢？主应用需要与子应用之前制定一个接口规范，比如在 single-spa 中就指定了 <code>bootstrap</code>、<code>mount</code>、<code>unmount</code> 和 <code>unload</code> 四个方法。子应用暴露这四个方法给主应用，主应用通过这四个方法来管理子应用的声明周期。</p><h3 id="隔离" tabindex="-1"><a class="header-anchor" href="#隔离" aria-hidden="true">#</a> 隔离</h3><p>解决了路由和子应用加载的问题，理论上说我们已经实现了微前端的核心能力。但是，在实际的工程实践中，我们还需要解决很多的细节问题。其中最大的一部分就是如何做好子应用间的隔离。比如如何避免子应用间的样式冲突。</p>',5),u=(0,e.Uk)("抛开现有的微前端方案，假如让我们从头开始实现一套微前端架构，将独立开发部署的各个子应用组合起来。相信大多数同学都会首先想到 "),k={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe",target:"_blank",rel:"noopener noreferrer"},d=(0,e.Uk)("iframe"),m=(0,e.Uk)("。其实我们就可以通过 iframe 来理解微前端架构中的种种技术细节。"),b=(0,e.uE)('<p>iframe 自带的样式、环境隔离机制使得它具备天然的沙箱能力，但是 iframe 也有很多天然的缺陷，比如事件无法冒泡到顶层，路由跳转无法与主应用同步，与主应用通信复杂繁琐等。</p><p>我们可以参考 iframe 的设计思想，来设计如何对子应用进行隔离。一个传统的 iframe 具备四层能力：文档的加载能力、HTML 的渲染能力、独立执行 JavaScript 的能力、隔离样式的能力。</p><p>文档的加载能力和 HTML 的渲染能力在前面主应用加载子应用资源的时候，我们已经做了说明。</p><p>我们现在来说说如何实现独立的 JavaScript 运行环境和样式隔离。</p><h4 id="沙箱-sandbox" tabindex="-1"><a class="header-anchor" href="#沙箱-sandbox" aria-hidden="true">#</a> 沙箱（sandbox）</h4><p>通常，子应用在运行期间会有一些污染性的副作用产生，比如全局变量、全局事件、定时器、网络请求、localStorage、全局 Style 样式、全局 DOM 元素等。为了保证应用能够稳定的运行且互不影响，需要提供安全的运行环境，能够有效地隔离、收集、清除应用在运行期间所产生的副作用，也就是沙箱的设计目标。</p><p>有两种沙箱的设计思路。一种是快照模式，另一种是虚拟机（virtual machine）模式。</p><h5 id="快照模式" tabindex="-1"><a class="header-anchor" href="#快照模式" aria-hidden="true">#</a> 快照模式</h5><p>所谓快照模式，就是将启动子应用之前，对当前环境打一个快照，子应用退出之后，再重新加载这个快照来恢复环境。</p><p>在实现层面，我们可以针对每一种副作用设计一个 <code>save</code> 方法保存当前状态，在设计一个 <code>load</code> 方法来加载保存的状态。</p><p>框照模式的缺陷是对操作的顺序要求非常严格，当页面有多个子应用的时候，快照沙箱就会有多个实例存在，此时不同顺序的 <code>save</code> 和 <code>load</code> 会产生问题。</p><h5 id="vm-虚拟机-模式" tabindex="-1"><a class="header-anchor" href="#vm-虚拟机-模式" aria-hidden="true">#</a> VM（虚拟机）模式</h5><p>虚拟机想必大家都听说过，是一种计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。使用虚拟机就跟使用真实的计算机一样。</p>',13),h=(0,e.Uk)("NodeJS 中也提供了 "),g={href:"https://nodejs.org/api/vm.html",target:"_blank",rel:"noopener noreferrer"},f=(0,e.Uk)("VM 模块"),x=(0,e.Uk)("，不过不同于传统的 VM，它并不具备虚拟机那么强的隔离性，并没有模拟完整的硬件系统，仅仅将指定代码放置了特定的上下文中编译并执行，无法用来执行不可信来源的代码。"),w=(0,e.uE)('<p>下面的代码展示了 NodeJS 的 VM 模块的基本用法：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;vm&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\nvm<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 context 对象上下文化</span>\n\n<span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token string">&#39;x += 40; var y = 17;&#39;</span><span class="token punctuation">;</span>\n<span class="token comment">// `x` and `y` 在上下文中是全局变量</span>\n<span class="token comment">// 初始状态下, x 的值为 2，因为 context.x 得值是 2</span>\nvm<span class="token punctuation">.</span><span class="token function">runInContext</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 17</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1; y 为未定义</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>参考 NodeJS 中 VM 模块的设计，以及 JavaScript 词法作用域的特性，可以设计出 VM 沙箱，不过与传统的 VM 差异也同样存在，它并不能执行不可信的代码，因为它的隔离能力仅限于将其运行在一个指定的上下文环境中。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(function(document, window){ /* 代码逻辑 */ })</span><span class="token template-punctuation string">`</span></span>\n\n<span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&#39;document&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;window&#39;</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">(</span>fakeDocument<span class="token punctuation">,</span> fakeWindow<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>针对前面提到的子应用运行产生的全局变量、全局事件等种种副作用，我们可以针对性的做处理，提供新的执行上下文。比如，用新的 window 对象用来隔离全局变量，用新的 document 来收集创建的 dom 对象，style 样式，script 标签等。全局事件、localStorage 等都可以一一进行处理。</p><p>下面借助于 <code>Proxy</code>，我们可以轻松的对当前的执行上下文进行劫持，创建新的执行上下文。下面的代码展示了如何劫持 window 对象。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> varBox <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> fakeWindow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> varBox<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> window<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    varBox<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(function(window) {\n  window.a = &#39;111&#39;;\n  console.log(window.a);\n})</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&#39;window&#39;</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">fn</span><span class="token punctuation">(</span>fakeWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div>',7),y=(0,e.Uk)("VM 模式的沙箱，可以有效的解决子应用之间、主子应用之间各种副作用的有效隔离问题。"),v={href:"https://qiankun.umijs.org/zh",target:"_blank",rel:"noopener noreferrer"},W=(0,e.Uk)("qiankun"),M=(0,e.Uk)(" 的沙箱模式就是 VM 模式。"),U=(0,e.Wm)("h5",{id:"样式隔离",tabindex:"-1"},[(0,e.Wm)("a",{class:"header-anchor",href:"#样式隔离","aria-hidden":"true"},"#"),(0,e.Uk)(" 样式隔离")],-1),j=(0,e.Wm)("p",null,"虽然说，VM 模式的沙箱可以收集子应用运行过程中产生的样式，然后在子应用卸载的时候去除样式，但是考虑到子应用的 dom 结构最终还是要并入到主应用的 dom 树中去，VM 沙箱无法避免主应用的样式干扰到子应用的样式的问题。",-1),S=(0,e.Uk)("这时候，我们就需要借助于一些其他手段，比如在主子应用中都使用 "),H={href:"https://github.com/css-modules/css-modules",target:"_blank",rel:"noopener noreferrer"},L=(0,e.Uk)("css modules"),T=(0,e.Uk)(" 来减少样式冲突。"),E=(0,e.Wm)("h4",{id:"shadow-dom",tabindex:"-1"},[(0,e.Wm)("a",{class:"header-anchor",href:"#shadow-dom","aria-hidden":"true"},"#"),(0,e.Uk)(" Shadow Dom")],-1),_=(0,e.Uk)("如果不考虑兼容性，"),V={href:"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM",target:"_blank",rel:"noopener noreferrer"},D=(0,e.Uk)("Shadow Dom"),J=(0,e.Uk)(" 是子应用样式隔离的一个绝佳选择。"),q=(0,e.Wm)("p",null,"我们把子应用放到 Shadow Dom 中，可以原生实现子应用间的样式隔离。但是 Shadow Dom 本身也有诸多限制，很多依赖库还不支持 Shadow Dom。比如埋点检测，事件处理等。",-1),C=(0,e.Wm)("p",null,"我们这里仅是将 Shadow Dom 作为补充技术方案来进行说明。",-1),z=(0,e.Uk)("qiankun 官方也将在"),N={href:"https://github.com/umijs/qiankun/discussions/1378#discussioncomment-598734",target:"_blank",rel:"noopener noreferrer"},B=(0,e.Uk)("未来的版本"),O=(0,e.Uk)("中逐步弃用 Shadow Dom。"),P=(0,e.uE)('<h2 id="需要注意的问题" tabindex="-1"><a class="header-anchor" href="#需要注意的问题" aria-hidden="true">#</a> 需要注意的问题</h2><p>技术领域有句话叫“没有永远的银弹”。本文开头我们介绍了使用微前端可以获得的很多收益，现在我们来讲讲微前端带来的问题。</p><ul><li><p>整个产品的复杂度从代码转移到了基础设施 我们需要有一套应用注册、管理的系统，并要和现有的应用发布流程对接。同时还要围绕微前端方案构建一整套的基础工具，比如开发调试工具，埋点监控系统等。</p></li><li><p>增加了学习和理解成本 子应用或多或少要了解一些微前端方案的技术原理，才能带来更好的开发和产品体验。</p></li></ul><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',4),F={render:function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[p,(0,e.Wm)("ul",null,[(0,e.Wm)("li",null,[t,(0,e.Wm)("a",o,[c,(0,e.Wm)(a)]),l]),r]),i,(0,e.Wm)("p",null,[u,(0,e.Wm)("a",k,[d,(0,e.Wm)(a)]),m]),b,(0,e.Wm)("p",null,[h,(0,e.Wm)("a",g,[f,(0,e.Wm)(a)]),x]),w,(0,e.Wm)("p",null,[y,(0,e.Wm)("a",v,[W,(0,e.Wm)(a)]),M]),U,j,(0,e.Wm)("p",null,[S,(0,e.Wm)("a",H,[L,(0,e.Wm)(a)]),T]),E,(0,e.Wm)("p",null,[_,(0,e.Wm)("a",V,[D,(0,e.Wm)(a)]),J]),q,C,(0,e.Wm)("blockquote",null,[(0,e.Wm)("p",null,[z,(0,e.Wm)("a",N,[B,(0,e.Wm)(a)]),O])]),P],64)}}}}]);