"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[6151],{4173:(e,t,n)=>{n.r(t),n.d(t,{data:()=>a});const a={key:"v-1143ac30",path:"/courses/architecture-of-react-app/",title:"React 应用架构指南",lang:"zh-CN",frontmatter:{title:"React 应用架构指南",description:"React 非常灵活，生态也非常丰富，我们可以找到各种各样的解决方案。但是灵活性与多样性也给开发者带来了很多困扰，本笔记尝试用 React 生态系统中最好的工具来创建 React 应用，同时对如何让项目有良好的结构和可扩展性等做一些说明。",sidebar:!1,date:"2021-08-09T00:00:00.000Z"},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[],filePathRelative:"courses/architecture-of-react-app/README.md",articleList:[{key:"v-47ef58ee",path:"/courses/architecture-of-react-app/api-mock-server.html",title:"API mock 服务",lang:"zh-CN",frontmatter:{title:"API mock 服务",description:"在约定好接口后，前后端会分头开发。此时，对定义好的接口进行 mock 就显得非常重要。",keywords:["React","架构","mock"],date:"2021-08-11T00:00:00.000Z",key:8},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[],content:"\n可以使用 [mswjs](https://mswjs.io/) 来对接口进行 mock。mswjs 通过 service worker 来实现 mock 能力。通过拦截所有的 HTTP 请求，根据定义好的 API 处理方式返回 mock 数据。\n\n在开发过程中，当后端接口还在开发中，前端需要使用这个接口时，这个工具就非常有用。通过这个工具，我们不需要真正的后端服务，却可以像直接调用接口一样发起数据请求。\n\nmswjs 需要为每一个 API 定义处理函数，这里是[如何定义处理函数的样例](https://github.com/everfind/bulletproof-react/blob/master/src/test/server/handlers/auth.ts)。\n\n同时，mswjs 也需要定义接口的数据模型，这里是[如何定义数据模型的样例](https://github.com/everfind/bulletproof-react/blob/master/src/test/server/db.ts)。\n\nmswjs 可以实现像直接调用后端接口一样调用 API，也就是说它实现了数据的连续性。在写自动化测试时，这一点也非常有用，我们不需要为每一个接口 mock 数据了，我们直接向 mswjs 发数据请求就可以。\n",contentRendered:'<p>可以使用 <a href="https://mswjs.io/" target="_blank" rel="noopener noreferrer">mswjs<OutboundLink/></a> 来对接口进行 mock。mswjs 通过 service worker 来实现 mock 能力。通过拦截所有的 HTTP 请求，根据定义好的 API 处理方式返回 mock 数据。</p>\n<p>在开发过程中，当后端接口还在开发中，前端需要使用这个接口时，这个工具就非常有用。通过这个工具，我们不需要真正的后端服务，却可以像直接调用接口一样发起数据请求。</p>\n<p>mswjs 需要为每一个 API 定义处理函数，这里是<a href="https://github.com/everfind/bulletproof-react/blob/master/src/test/server/handlers/auth.ts" target="_blank" rel="noopener noreferrer">如何定义处理函数的样例<OutboundLink/></a>。</p>\n<p>同时，mswjs 也需要定义接口的数据模型，这里是<a href="https://github.com/everfind/bulletproof-react/blob/master/src/test/server/db.ts" target="_blank" rel="noopener noreferrer">如何定义数据模型的样例<OutboundLink/></a>。</p>\n<p>mswjs 可以实现像直接调用后端接口一样调用 API，也就是说它实现了数据的连续性。在写自动化测试时，这一点也非常有用，我们不需要为每一个接口 mock 数据了，我们直接向 mswjs 发数据请求就可以。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-11",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/api-mock-server.html",pathLocale:"/",permalink:null,slug:"api-mock-server",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/api-mock-server.md",filePathRelative:"courses/architecture-of-react-app/api-mock-server.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/api-mock-server.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/api-mock-server.html.vue",componentFileChunkName:"v-47ef58ee",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/api-mock-server.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/api-mock-server.html.js",dataFileChunkName:"v-47ef58ee",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/api-mock-server.html",htmlFilePathRelative:"courses/architecture-of-react-app/api-mock-server.html"},{key:"v-441bc8e7",path:"/courses/architecture-of-react-app/api.html",title:"API 层最佳实践",lang:"zh-CN",frontmatter:{title:"API 层最佳实践",description:"任何页面都需要调用 API 接口，本篇介绍一些 API 层的实践经验。",keywords:["React","架构","API"],date:"2021-08-11T00:00:00.000Z",key:5},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"使用单例模式",slug:"使用单例模式",children:[]},{level:2,title:"独立定义接口调用",slug:"独立定义接口调用",children:[]}],content:"\n## 使用单例模式\n\n只使用全局一个实例。不管是调用 RESTful 风格还是 GraphQL 的 API 接口，在整个应用层面，我们都应该只使用一个客户端实例。也就是说，只使用一个配置好的 API 客户端（[axios](https://github.com/axios/axios)/[graphql-request](https://github.com/prisma-labs/graphql-request)/[apollo-client](https://www.apollographql.com/docs/react/)）实例。\n\n[这里有一个 API 客户端配置样例](https://github.com/everfind/bulletproof-react/blob/master/src/lib/axios.ts)\n\n## 独立定义接口调用\n\n我们应该将对 API 接口的调用和类型声明从业务代码中抽取出来，放到独立的文件或模块中。\n\n如果调用的 API 是一个 RESTful 风格的，那么抽取出来的定义应该是一个调用函数，这个函数里调用具体的 API。如果调用的 API 是一个 GraphQL API，那么抽取出来的定义应该是包含了 `Query` 或者 `Mutation`的描述，从而可以被 [`react-query`](https://react-query.tanstack.com/)、[`apollo-client`](https://www.apollographql.com/docs/react/)、[`urql`](https://formidable.com/open-source/urql/) 之类的库使用。\n\n这么做的好处是可以方便的追踪到应用中调用哪些 API。同时我们还可以给这些接口调用定义入参和出参的类型，来更好的辅助开发。\n\n[这里是一个 API 接口调用的样例](https://github.com/everfind/bulletproof-react/blob/master/src/features/discussions/api/index.ts)\n",contentRendered:'<h2 id="使用单例模式" tabindex="-1"><a class="header-anchor" href="#使用单例模式" aria-hidden="true">#</a> 使用单例模式</h2>\n<p>只使用全局一个实例。不管是调用 RESTful 风格还是 GraphQL 的 API 接口，在整个应用层面，我们都应该只使用一个客户端实例。也就是说，只使用一个配置好的 API 客户端（<a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer">axios<OutboundLink/></a>/<a href="https://github.com/prisma-labs/graphql-request" target="_blank" rel="noopener noreferrer">graphql-request<OutboundLink/></a>/<a href="https://www.apollographql.com/docs/react/" target="_blank" rel="noopener noreferrer">apollo-client<OutboundLink/></a>）实例。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/lib/axios.ts" target="_blank" rel="noopener noreferrer">这里有一个 API 客户端配置样例<OutboundLink/></a></p>\n<h2 id="独立定义接口调用" tabindex="-1"><a class="header-anchor" href="#独立定义接口调用" aria-hidden="true">#</a> 独立定义接口调用</h2>\n<p>我们应该将对 API 接口的调用和类型声明从业务代码中抽取出来，放到独立的文件或模块中。</p>\n<p>如果调用的 API 是一个 RESTful 风格的，那么抽取出来的定义应该是一个调用函数，这个函数里调用具体的 API。如果调用的 API 是一个 GraphQL API，那么抽取出来的定义应该是包含了 <code>Query</code> 或者 <code>Mutation</code>的描述，从而可以被 <a href="https://react-query.tanstack.com/" target="_blank" rel="noopener noreferrer"><code>react-query</code><OutboundLink/></a>、<a href="https://www.apollographql.com/docs/react/" target="_blank" rel="noopener noreferrer"><code>apollo-client</code><OutboundLink/></a>、<a href="https://formidable.com/open-source/urql/" target="_blank" rel="noopener noreferrer"><code>urql</code><OutboundLink/></a> 之类的库使用。</p>\n<p>这么做的好处是可以方便的追踪到应用中调用哪些 API。同时我们还可以给这些接口调用定义入参和出参的类型，来更好的辅助开发。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/features/discussions/api/index.ts" target="_blank" rel="noopener noreferrer">这里是一个 API 接口调用的样例<OutboundLink/></a></p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-11",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/api.html",pathLocale:"/",permalink:null,slug:"api",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/api.md",filePathRelative:"courses/architecture-of-react-app/api.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/api.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/api.html.vue",componentFileChunkName:"v-441bc8e7",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/api.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/api.html.js",dataFileChunkName:"v-441bc8e7",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/api.html",htmlFilePathRelative:"courses/architecture-of-react-app/api.html"},{key:"v-272bb16e",path:"/courses/architecture-of-react-app/auth.html",title:"认证",lang:"zh-CN",frontmatter:{title:"认证",description:"权限管理是应用中非常重要的一环。本文介绍前端应用中如何实现验证与授权。",keywords:["React","架构","认证"],date:"2021-08-11T00:00:00.000Z",key:7},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"验证（Authentication）",slug:"验证-authentication",children:[{level:3,title:"localStorage 还是 cookie",slug:"localstorage-还是-cookie",children:[]},{level:3,title:"处理用户数据",slug:"处理用户数据",children:[]}]},{level:2,title:"授权（Authorization）",slug:"授权-authorization",children:[{level:3,title:"基于角色的访问控制",slug:"基于角色的访问控制",children:[]},{level:3,title:"基于权限的访问控制",slug:"基于权限的访问控制",children:[]}]}],content:"\n注意，在客户端做了认证不代表不需要在服务端做了。恰恰相反，我们更需要在服务端做认证，来保证资源被正确的使用。\n\n认证可以分为两块进行讨论。\n\n## 验证（Authentication）\n\n验证旨在识别出谁是谁。\n\n常见的验证手段是通过 [JWT](https://jwt.io/)。在用户登录之后，我们将用户的 token 保存在应用中，之后每次请求都将这个 token 放到请求头或者 cookie 中。\n\n最安全的存储 token 的方法是放到应用状态中。但是一旦用户刷新页面，应用状态被重置，token 就丢失了。因此，我们需要借助于一些客户端存储技术。\n\n### `localStorage` 还是 cookie\n\n将 token 保存在 `localStorage` 中有一定的安全风险，如果处理不当，攻击者可以通过 [XSS](https://owasp.org/www-community/attacks/xss/) 等方式获取用户的 token。\n\n将 token 保存在 cookie 中，并设置 `HttpOnly` 属性，会比 `localStorage` 更加安全。但是这种方法需要与后端团队达成一致，同时 cookie 中的信息增多也会增加网络传输的负担。\n\n`localStorage` 简单，cookie 更安全。为了保证应用安全，与其争论使用哪种方式存储，不容给我们的应用增加更多的安全防护，以抵御 XSS 等安全攻击。也就是说，我们需要对 HTML 文本内容做净化处理。\n\n[这里是一个对 HTML 做净化处理的样例](https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/MDPreview/MDPreview.tsx)\n\n### 处理用户数据\n\n已经获取到的用户数据应该作为一个全局状态存储，整个应用都可以访问到这个数据。\n\n如果使用 `react-query` 的话，我们可以使用 [react-query-auth](https://github.com/alan2207/react-query-auth) 这个库来保存用户数据。如果没有，那么可以借助于 context + hooks 或者什么其他第三方状态管理库。\n\n[这里是保存用户信息的样例](https://github.com/everfind/bulletproof-react/blob/master/src/lib/auth.tsx)\n\n如果应用可以读取到用户信息，那么就认为用户已经被验证过，是合法的。\n\n[这里是使用用户信息的样例](https://github.com/everfind/bulletproof-react/blob/master/src/routes/index.tsx)\n\n## 授权（Authorization）\n\n授权是决定用户是否有权限访问资源的过程。\n\n### 基于角色的访问控制\n\n基于角色的访问控制，简称RBAC（Role based access control）。\n\n通常我们会先定义一些角色，不同的角色拥有不同的资源访问权限。之后，通过检查用户是否有某一个角色来判断是否有权限访问资源。\n\n[这里是一个角色定义的样例](https://github.com/everfind/bulletproof-react/blob/master/src/lib/authorization.tsx)\n\n[这里是基于角色判断权限的样例](https://github.com/everfind/bulletproof-react/blob/master/src/features/discussions/components/CreateDiscussion.tsx)\n\n### 基于权限的访问控制\n\n基于权限的访问控制，简称 PBAC（Permission based access control）。\n\nRBAC 并不适用于所有场景。有时候有些操作只能是资源所有者才能执行。比如评论信息，只能是用户自己才能删除或者修改。通过使用 PBAC，我们可以更灵活的实现这类访问控制。\n\n我们可以灵活的同时使用这两种访问控制方案。通常情况下我们只需要基于角色的权限控制，特殊情况下我们再使用指定权限。\n\n[这里是混合使用两种访问控制方法的样例](https://github.com/everfind/bulletproof-react/blob/master/src/features/comments/components/CommentsList.tsx)\n",contentRendered:'<p>注意，在客户端做了认证不代表不需要在服务端做了。恰恰相反，我们更需要在服务端做认证，来保证资源被正确的使用。</p>\n<p>认证可以分为两块进行讨论。</p>\n<h2 id="验证-authentication" tabindex="-1"><a class="header-anchor" href="#验证-authentication" aria-hidden="true">#</a> 验证（Authentication）</h2>\n<p>验证旨在识别出谁是谁。</p>\n<p>常见的验证手段是通过 <a href="https://jwt.io/" target="_blank" rel="noopener noreferrer">JWT<OutboundLink/></a>。在用户登录之后，我们将用户的 token 保存在应用中，之后每次请求都将这个 token 放到请求头或者 cookie 中。</p>\n<p>最安全的存储 token 的方法是放到应用状态中。但是一旦用户刷新页面，应用状态被重置，token 就丢失了。因此，我们需要借助于一些客户端存储技术。</p>\n<h3 id="localstorage-还是-cookie" tabindex="-1"><a class="header-anchor" href="#localstorage-还是-cookie" aria-hidden="true">#</a> <code>localStorage</code> 还是 cookie</h3>\n<p>将 token 保存在 <code>localStorage</code> 中有一定的安全风险，如果处理不当，攻击者可以通过 <a href="https://owasp.org/www-community/attacks/xss/" target="_blank" rel="noopener noreferrer">XSS<OutboundLink/></a> 等方式获取用户的 token。</p>\n<p>将 token 保存在 cookie 中，并设置 <code>HttpOnly</code> 属性，会比 <code>localStorage</code> 更加安全。但是这种方法需要与后端团队达成一致，同时 cookie 中的信息增多也会增加网络传输的负担。</p>\n<p><code>localStorage</code> 简单，cookie 更安全。为了保证应用安全，与其争论使用哪种方式存储，不容给我们的应用增加更多的安全防护，以抵御 XSS 等安全攻击。也就是说，我们需要对 HTML 文本内容做净化处理。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/MDPreview/MDPreview.tsx" target="_blank" rel="noopener noreferrer">这里是一个对 HTML 做净化处理的样例<OutboundLink/></a></p>\n<h3 id="处理用户数据" tabindex="-1"><a class="header-anchor" href="#处理用户数据" aria-hidden="true">#</a> 处理用户数据</h3>\n<p>已经获取到的用户数据应该作为一个全局状态存储，整个应用都可以访问到这个数据。</p>\n<p>如果使用 <code>react-query</code> 的话，我们可以使用 <a href="https://github.com/alan2207/react-query-auth" target="_blank" rel="noopener noreferrer">react-query-auth<OutboundLink/></a> 这个库来保存用户数据。如果没有，那么可以借助于 context + hooks 或者什么其他第三方状态管理库。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/lib/auth.tsx" target="_blank" rel="noopener noreferrer">这里是保存用户信息的样例<OutboundLink/></a></p>\n<p>如果应用可以读取到用户信息，那么就认为用户已经被验证过，是合法的。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/routes/index.tsx" target="_blank" rel="noopener noreferrer">这里是使用用户信息的样例<OutboundLink/></a></p>\n<h2 id="授权-authorization" tabindex="-1"><a class="header-anchor" href="#授权-authorization" aria-hidden="true">#</a> 授权（Authorization）</h2>\n<p>授权是决定用户是否有权限访问资源的过程。</p>\n<h3 id="基于角色的访问控制" tabindex="-1"><a class="header-anchor" href="#基于角色的访问控制" aria-hidden="true">#</a> 基于角色的访问控制</h3>\n<p>基于角色的访问控制，简称RBAC（Role based access control）。</p>\n<p>通常我们会先定义一些角色，不同的角色拥有不同的资源访问权限。之后，通过检查用户是否有某一个角色来判断是否有权限访问资源。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/lib/authorization.tsx" target="_blank" rel="noopener noreferrer">这里是一个角色定义的样例<OutboundLink/></a></p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/features/discussions/components/CreateDiscussion.tsx" target="_blank" rel="noopener noreferrer">这里是基于角色判断权限的样例<OutboundLink/></a></p>\n<h3 id="基于权限的访问控制" tabindex="-1"><a class="header-anchor" href="#基于权限的访问控制" aria-hidden="true">#</a> 基于权限的访问控制</h3>\n<p>基于权限的访问控制，简称 PBAC（Permission based access control）。</p>\n<p>RBAC 并不适用于所有场景。有时候有些操作只能是资源所有者才能执行。比如评论信息，只能是用户自己才能删除或者修改。通过使用 PBAC，我们可以更灵活的实现这类访问控制。</p>\n<p>我们可以灵活的同时使用这两种访问控制方案。通常情况下我们只需要基于角色的权限控制，特殊情况下我们再使用指定权限。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/features/comments/components/CommentsList.tsx" target="_blank" rel="noopener noreferrer">这里是混合使用两种访问控制方法的样例<OutboundLink/></a></p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-11",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/auth.html",pathLocale:"/",permalink:null,slug:"auth",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/auth.md",filePathRelative:"courses/architecture-of-react-app/auth.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/auth.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/auth.html.vue",componentFileChunkName:"v-272bb16e",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/auth.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/auth.html.js",dataFileChunkName:"v-272bb16e",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/auth.html",htmlFilePathRelative:"courses/architecture-of-react-app/auth.html"},{key:"v-1e729ae0",path:"/courses/architecture-of-react-app/components-and-styling.html",title:"组件和样式",lang:"zh-CN",frontmatter:{title:"组件和样式",description:"应用中组件开发的最佳实践，以及优秀的组件库，样式解决方案介绍。",keywords:["React","架构","组件","样式"],date:"2021-08-10T00:00:00.000Z",key:3},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"组件开发最佳实践",slug:"组件开发最佳实践",children:[{level:3,title:"把代码都收敛在使用它的地方",slug:"把代码都收敛在使用它的地方",children:[]},{level:3,title:"避免嵌套的渲染函数",slug:"避免嵌套的渲染函数",children:[]},{level:3,title:"保持风格统一",slug:"保持风格统一",children:[]},{level:3,title:"限制组件的 props 数量",slug:"限制组件的-props-数量",children:[]},{level:3,title:"对公共组件进行一定程度的抽象",slug:"对公共组件进行一定程度的抽象",children:[]}]},{level:2,title:"组件库",slug:"组件库",children:[{level:3,title:"功能齐全的组件库",slug:"功能齐全的组件库",children:[]},{level:3,title:"无头组件库",slug:"无头组件库",children:[]}]},{level:2,title:"样式库",slug:"样式库",children:[]},{level:2,title:"样式与组件的组合",slug:"样式与组件的组合",children:[]},{level:2,title:"使用 Storybook 开发组件",slug:"使用-storybook-开发组件",children:[]}],content:"\n今天我们来聊聊项目中开发组件的一些优秀实践，同时也介绍一些优秀的组件库和样式库。\n\n## 组件开发最佳实践\n\n### 把代码都收敛在使用它的地方\n\n将组件、函数、样式、状态等都尽可能的收敛在使用这些代码的地方。不要放到其他地方引起混乱。\n\n比如组件的样式代码应该与组件代码放到一个目录下，而不是放到一个其他的样式目录中去。\n\n### 避免嵌套的渲染函数\n\n```tsx\n// 当组件功能越来越复杂的时候，这种方式会让组件越来越难以维护\nfunction Component() {\n  function renderItems() {\n    return <ul>...</ul>;\n  }\n  return <div>{renderItems()}</div>;\n}\n\n// 可以将其抽成独立组件\nimport { Items } from 'components/Items';\n\nfunction Component() {\n  return (\n    <div>\n      <Items />\n    </div>\n  );\n}\n```\n\n### 保持风格统一\n\n保持编码风格统一。比如组件的命名是驼峰式，则其他地方也是用驼峰式命名。如果是用箭头函数来创建组件，则其他地方也保持一致。\n\n### 限制组件的 props 数量\n\n如果组件需要接收的 props 太多，我们应该考虑将其拆分成多个组件，或者是用 `children` 或者插槽等方式来组合功能。\n\n[这里是一个如何使用组合的代码样例](https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/ConfirmationDialog/ConfirmationDialog.tsx)\n\n### 对公共组件进行一定程度的抽象\n\n对于大项目来说，对公共组件进行抽象是一个必要的组件开发方式。经过抽象后的组件可以让应用代码更利于维护。不过，在对组件进行抽象之前，需要明确哪些代码是重复的，以避免错误的抽象。\n\n[这里是一个对组件进行抽象的代码样例](https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/Button/Button.tsx)\n\n除了抽象组件以外，我们也要对一些依赖的第三方库进行必要的包装，让其能更好的适配应用的需要。比如对 `axios` 库进行一些包装，来让应用使用 `axios` 时更加简便。这么做也能保障后续对三方库进行修改或者替换三方库的时候对应用影响最小。\n\n[这里是一个封装第三方库的代码样例](https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/Link/Link.tsx)\n\n## 组件库\n\n通常我们在开发应用的时候都需要一些组件库来辅助开发。这里有一些社区里久经考验的组件库可以参考。\n\n### 功能齐全的组件库\n\n* [Chakra UI](https://chakra-ui.com/) 非常灵活，可以帮助快速开发产品原型，同时具有良好的可访问特性。\n* [AntD](https://ant.design/) 组件非常丰富，非常适合用来开发后台管理系统。\n* [Material UI](https://material-ui.com/) 也是一款适合用来开发后台管理系统的组件库，组件丰富。\n\n### 无头组件库\n\n有时候我们需要自由的定制组件样式，同时也要完备的组件功能，那么可以试试无头组件库。所谓无头组件就是只有交互功能，没有样式的组件。样式需要开发者自己开发。\n\n* [Reakit](https://reakit.io/)\n* [Headless UI](https://headlessui.dev/)\n* [Radix UI](https://www.radix-ui.com/)\n* [react-aria](https://react-spectrum.adobe.com/react-aria/)\n\n## 样式库\n\n我们有很多种方案来给组件添加样式，下面这几个是比较优秀的社区方案：\n\n* [tailwind](https://tailwindcss.com/)\n* [styled-components](https://styled-components.com/)\n* [emotion](https://emotion.sh/docs/introduction)\n* [stitches](https://stitches.dev/)\n* [vanilla-extract](https://github.com/seek-oss/vanilla-extract)\n* [CSS modules](https://github.com/css-modules/css-modules)\n* [linaria](https://github.com/callstack/linaria)\n\n## 样式与组件的组合\n\n下面这几个组合是经过社区实践后证明的比较好的组合方案。\n\n* [Chakra UI](https://chakra-ui.com/) + [emotion](https://emotion.sh/docs/introduction)\n* [Headless UI](https://headlessui.dev/) + [tailwind](https://tailwindcss.com/)\n* [Radix UI](https://www.radix-ui.com/) + [stitches](https://stitches.dev/)\n\n## 使用 Storybook 开发组件\n\n[Storybook](https://storybook.js.org/) 是一款非常优秀的组件开发工具。我们可以将其当做应用内组件的目录，当应用规模比较大的时候，使用 Storybook 可以非常方面的查看组件信息。\n\n[这里是使用 Storybook 的代码样例](https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/Button/Button.stories.tsx)\n",contentRendered:'<p>今天我们来聊聊项目中开发组件的一些优秀实践，同时也介绍一些优秀的组件库和样式库。</p>\n<h2 id="组件开发最佳实践" tabindex="-1"><a class="header-anchor" href="#组件开发最佳实践" aria-hidden="true">#</a> 组件开发最佳实践</h2>\n<h3 id="把代码都收敛在使用它的地方" tabindex="-1"><a class="header-anchor" href="#把代码都收敛在使用它的地方" aria-hidden="true">#</a> 把代码都收敛在使用它的地方</h3>\n<p>将组件、函数、样式、状态等都尽可能的收敛在使用这些代码的地方。不要放到其他地方引起混乱。</p>\n<p>比如组件的样式代码应该与组件代码放到一个目录下，而不是放到一个其他的样式目录中去。</p>\n<h3 id="避免嵌套的渲染函数" tabindex="-1"><a class="header-anchor" href="#避免嵌套的渲染函数" aria-hidden="true">#</a> 避免嵌套的渲染函数</h3>\n<div class="language-tsx ext-tsx line-numbers-mode"><pre v-pre class="language-tsx"><code><span class="token comment">// 当组件功能越来越复杂的时候，这种方式会让组件越来越难以维护</span>\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">renderItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token function">renderItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 可以将其抽成独立组件</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> Items <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'components/Items\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Items</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="保持风格统一" tabindex="-1"><a class="header-anchor" href="#保持风格统一" aria-hidden="true">#</a> 保持风格统一</h3>\n<p>保持编码风格统一。比如组件的命名是驼峰式，则其他地方也是用驼峰式命名。如果是用箭头函数来创建组件，则其他地方也保持一致。</p>\n<h3 id="限制组件的-props-数量" tabindex="-1"><a class="header-anchor" href="#限制组件的-props-数量" aria-hidden="true">#</a> 限制组件的 props 数量</h3>\n<p>如果组件需要接收的 props 太多，我们应该考虑将其拆分成多个组件，或者是用 <code>children</code> 或者插槽等方式来组合功能。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/ConfirmationDialog/ConfirmationDialog.tsx" target="_blank" rel="noopener noreferrer">这里是一个如何使用组合的代码样例<OutboundLink/></a></p>\n<h3 id="对公共组件进行一定程度的抽象" tabindex="-1"><a class="header-anchor" href="#对公共组件进行一定程度的抽象" aria-hidden="true">#</a> 对公共组件进行一定程度的抽象</h3>\n<p>对于大项目来说，对公共组件进行抽象是一个必要的组件开发方式。经过抽象后的组件可以让应用代码更利于维护。不过，在对组件进行抽象之前，需要明确哪些代码是重复的，以避免错误的抽象。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/Button/Button.tsx" target="_blank" rel="noopener noreferrer">这里是一个对组件进行抽象的代码样例<OutboundLink/></a></p>\n<p>除了抽象组件以外，我们也要对一些依赖的第三方库进行必要的包装，让其能更好的适配应用的需要。比如对 <code>axios</code> 库进行一些包装，来让应用使用 <code>axios</code> 时更加简便。这么做也能保障后续对三方库进行修改或者替换三方库的时候对应用影响最小。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/Link/Link.tsx" target="_blank" rel="noopener noreferrer">这里是一个封装第三方库的代码样例<OutboundLink/></a></p>\n<h2 id="组件库" tabindex="-1"><a class="header-anchor" href="#组件库" aria-hidden="true">#</a> 组件库</h2>\n<p>通常我们在开发应用的时候都需要一些组件库来辅助开发。这里有一些社区里久经考验的组件库可以参考。</p>\n<h3 id="功能齐全的组件库" tabindex="-1"><a class="header-anchor" href="#功能齐全的组件库" aria-hidden="true">#</a> 功能齐全的组件库</h3>\n<ul>\n<li><a href="https://chakra-ui.com/" target="_blank" rel="noopener noreferrer">Chakra UI<OutboundLink/></a> 非常灵活，可以帮助快速开发产品原型，同时具有良好的可访问特性。</li>\n<li><a href="https://ant.design/" target="_blank" rel="noopener noreferrer">AntD<OutboundLink/></a> 组件非常丰富，非常适合用来开发后台管理系统。</li>\n<li><a href="https://material-ui.com/" target="_blank" rel="noopener noreferrer">Material UI<OutboundLink/></a> 也是一款适合用来开发后台管理系统的组件库，组件丰富。</li>\n</ul>\n<h3 id="无头组件库" tabindex="-1"><a class="header-anchor" href="#无头组件库" aria-hidden="true">#</a> 无头组件库</h3>\n<p>有时候我们需要自由的定制组件样式，同时也要完备的组件功能，那么可以试试无头组件库。所谓无头组件就是只有交互功能，没有样式的组件。样式需要开发者自己开发。</p>\n<ul>\n<li><a href="https://reakit.io/" target="_blank" rel="noopener noreferrer">Reakit<OutboundLink/></a></li>\n<li><a href="https://headlessui.dev/" target="_blank" rel="noopener noreferrer">Headless UI<OutboundLink/></a></li>\n<li><a href="https://www.radix-ui.com/" target="_blank" rel="noopener noreferrer">Radix UI<OutboundLink/></a></li>\n<li><a href="https://react-spectrum.adobe.com/react-aria/" target="_blank" rel="noopener noreferrer">react-aria<OutboundLink/></a></li>\n</ul>\n<h2 id="样式库" tabindex="-1"><a class="header-anchor" href="#样式库" aria-hidden="true">#</a> 样式库</h2>\n<p>我们有很多种方案来给组件添加样式，下面这几个是比较优秀的社区方案：</p>\n<ul>\n<li><a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer">tailwind<OutboundLink/></a></li>\n<li><a href="https://styled-components.com/" target="_blank" rel="noopener noreferrer">styled-components<OutboundLink/></a></li>\n<li><a href="https://emotion.sh/docs/introduction" target="_blank" rel="noopener noreferrer">emotion<OutboundLink/></a></li>\n<li><a href="https://stitches.dev/" target="_blank" rel="noopener noreferrer">stitches<OutboundLink/></a></li>\n<li><a href="https://github.com/seek-oss/vanilla-extract" target="_blank" rel="noopener noreferrer">vanilla-extract<OutboundLink/></a></li>\n<li><a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener noreferrer">CSS modules<OutboundLink/></a></li>\n<li><a href="https://github.com/callstack/linaria" target="_blank" rel="noopener noreferrer">linaria<OutboundLink/></a></li>\n</ul>\n<h2 id="样式与组件的组合" tabindex="-1"><a class="header-anchor" href="#样式与组件的组合" aria-hidden="true">#</a> 样式与组件的组合</h2>\n<p>下面这几个组合是经过社区实践后证明的比较好的组合方案。</p>\n<ul>\n<li><a href="https://chakra-ui.com/" target="_blank" rel="noopener noreferrer">Chakra UI<OutboundLink/></a> + <a href="https://emotion.sh/docs/introduction" target="_blank" rel="noopener noreferrer">emotion<OutboundLink/></a></li>\n<li><a href="https://headlessui.dev/" target="_blank" rel="noopener noreferrer">Headless UI<OutboundLink/></a> + <a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer">tailwind<OutboundLink/></a></li>\n<li><a href="https://www.radix-ui.com/" target="_blank" rel="noopener noreferrer">Radix UI<OutboundLink/></a> + <a href="https://stitches.dev/" target="_blank" rel="noopener noreferrer">stitches<OutboundLink/></a></li>\n</ul>\n<h2 id="使用-storybook-开发组件" tabindex="-1"><a class="header-anchor" href="#使用-storybook-开发组件" aria-hidden="true">#</a> 使用 Storybook 开发组件</h2>\n<p><a href="https://storybook.js.org/" target="_blank" rel="noopener noreferrer">Storybook<OutboundLink/></a> 是一款非常优秀的组件开发工具。我们可以将其当做应用内组件的目录，当应用规模比较大的时候，使用 Storybook 可以非常方面的查看组件信息。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/Button/Button.stories.tsx" target="_blank" rel="noopener noreferrer">这里是使用 Storybook 的代码样例<OutboundLink/></a></p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-10",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/components-and-styling.html",pathLocale:"/",permalink:null,slug:"components-and-styling",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/components-and-styling.md",filePathRelative:"courses/architecture-of-react-app/components-and-styling.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/components-and-styling.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/components-and-styling.html.vue",componentFileChunkName:"v-1e729ae0",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/components-and-styling.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/components-and-styling.html.js",dataFileChunkName:"v-1e729ae0",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/components-and-styling.html",htmlFilePathRelative:"courses/architecture-of-react-app/components-and-styling.html"},{key:"v-157614ea",path:"/courses/architecture-of-react-app/configuration.html",title:"项目初始化配置",lang:"zh-CN",frontmatter:{title:"项目初始化配置",description:"对项目中需要使用的静态检查、代码格式化等工具进行说明，并给出样例。",keywords:["React","架构","配置"],date:"2021-08-09T00:00:00.000Z",key:1},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"ESLint",slug:"eslint",children:[]},{level:2,title:"Prettier",slug:"prettier",children:[]},{level:2,title:"TypeScript",slug:"typescript",children:[]},{level:2,title:"Husky",slug:"husky",children:[]},{level:2,title:"绝对路径导入",slug:"绝对路径导入",children:[]}],content:'\n通常我们都是通过 [Create React App(CRA)](https://github.com/facebook/create-react-app) 来初始化项目，初始化后的项目已经包含了静态检查、格式化等工具的配置。我们今天不讲如何使用 CRA，我们来讲讲这些工具都是干什么的，同时给出通用的配置样例。\n\n## ESLint\n\n[ESLint](https://eslint.org/) 是一款面向 JavaScript 的代码静态检查工具。通过 ESLint 我们可以避免编码过程中的一些低级错误，同时也能尽量保证代码的风格统一。ESLint 的配置通常保存在 `.eslintrc.js` 文件中。\n\n[这是一份 ESLint 的配置样例](https://github.com/everfind/bulletproof-react/blob/master/.eslintrc.js)\n\n## Prettier\n\n[Prettier](https://prettier.io/) 是一款代码格式化工具。通过 Prettier，我们可以保证整个代码库的编码风格是一致的。借助于编辑器的 "format on save" 功能，我们可以轻松的实现代码自动格式化。Prettier 的配置通常保存在 `.prettierrc` 文件中。\n\n[这是一份 Prettier 的配置样例](https://github.com/everfind/bulletproof-react/blob/master/.prettierrc)\n\n## TypeScript\n\nESLint 是静态检查工具，而 JavaScript 是一门动态语言，很多错误只有在运行时才能发现，比如类型不匹配等。在大项目中，这种问题尤其突出。\n\n[TypeScript](https://www.typescriptlang.org/) 作为一门静态类型语言，可以很大程度上帮助我们解决这方面的问题。特别是在重构代码的时候，当我们改变一个类型的声明时，TypeScript 会帮助我们找出所有使用这个类型的地方，并给出错误提示，我们可以逐一进行修改。\n\n## Husky\n\n[Husky](https://typicode.github.io/husky/#/) 是一个辅助执行 git 钩子的工具。在执行 `git commit` 之前，通过 Husky 执行静态检查、代码格式化等任务，可以保证提交的代码都是符合规范的。可以在[这里](https://typicode.github.io/husky/#/?id=usage)了解如何使用 Husky。\n\n## 绝对路径导入\n\n我们应该在项目中使用绝对路径导入，这样当我们需要移动文件的时候会非常方便，同时也可以避免迷惑的 `../../../Component` 导入路径。\n\n在 JavaScript 项目中我们可以这么配置：\n\n```json\n// jsconfig.json\n"compilerOptions": {\n  "baseUrl": ".",\n  "paths": {\n    "@/*": ["./src/*"]\n  }\n}\n```\n\n在 TypeScript 项目中可以这么配置：\n\n```json\n// tsconfig.json\n"compilerOptions": {\n  "baseUrl": ".",\n  "paths": {\n    "@/*": ["./src/*"]\n  }\n}\n```\n\n我们可以定义多个路径映射，但是通常 `@/*` 就已经够用了。`src/components/MyComponent` 可以这样导入 `@/components/MyComponent`。\n',contentRendered:'<p>通常我们都是通过 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener noreferrer">Create React App(CRA)<OutboundLink/></a> 来初始化项目，初始化后的项目已经包含了静态检查、格式化等工具的配置。我们今天不讲如何使用 CRA，我们来讲讲这些工具都是干什么的，同时给出通用的配置样例。</p>\n<h2 id="eslint" tabindex="-1"><a class="header-anchor" href="#eslint" aria-hidden="true">#</a> ESLint</h2>\n<p><a href="https://eslint.org/" target="_blank" rel="noopener noreferrer">ESLint<OutboundLink/></a> 是一款面向 JavaScript 的代码静态检查工具。通过 ESLint 我们可以避免编码过程中的一些低级错误，同时也能尽量保证代码的风格统一。ESLint 的配置通常保存在 <code>.eslintrc.js</code> 文件中。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/.eslintrc.js" target="_blank" rel="noopener noreferrer">这是一份 ESLint 的配置样例<OutboundLink/></a></p>\n<h2 id="prettier" tabindex="-1"><a class="header-anchor" href="#prettier" aria-hidden="true">#</a> Prettier</h2>\n<p><a href="https://prettier.io/" target="_blank" rel="noopener noreferrer">Prettier<OutboundLink/></a> 是一款代码格式化工具。通过 Prettier，我们可以保证整个代码库的编码风格是一致的。借助于编辑器的 &quot;format on save&quot; 功能，我们可以轻松的实现代码自动格式化。Prettier 的配置通常保存在 <code>.prettierrc</code> 文件中。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/.prettierrc" target="_blank" rel="noopener noreferrer">这是一份 Prettier 的配置样例<OutboundLink/></a></p>\n<h2 id="typescript" tabindex="-1"><a class="header-anchor" href="#typescript" aria-hidden="true">#</a> TypeScript</h2>\n<p>ESLint 是静态检查工具，而 JavaScript 是一门动态语言，很多错误只有在运行时才能发现，比如类型不匹配等。在大项目中，这种问题尤其突出。</p>\n<p><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener noreferrer">TypeScript<OutboundLink/></a> 作为一门静态类型语言，可以很大程度上帮助我们解决这方面的问题。特别是在重构代码的时候，当我们改变一个类型的声明时，TypeScript 会帮助我们找出所有使用这个类型的地方，并给出错误提示，我们可以逐一进行修改。</p>\n<h2 id="husky" tabindex="-1"><a class="header-anchor" href="#husky" aria-hidden="true">#</a> Husky</h2>\n<p><a href="https://typicode.github.io/husky/#/" target="_blank" rel="noopener noreferrer">Husky<OutboundLink/></a> 是一个辅助执行 git 钩子的工具。在执行 <code>git commit</code> 之前，通过 Husky 执行静态检查、代码格式化等任务，可以保证提交的代码都是符合规范的。可以在<a href="https://typicode.github.io/husky/#/?id=usage" target="_blank" rel="noopener noreferrer">这里<OutboundLink/></a>了解如何使用 Husky。</p>\n<h2 id="绝对路径导入" tabindex="-1"><a class="header-anchor" href="#绝对路径导入" aria-hidden="true">#</a> 绝对路径导入</h2>\n<p>我们应该在项目中使用绝对路径导入，这样当我们需要移动文件的时候会非常方便，同时也可以避免迷惑的 <code>../../../Component</code> 导入路径。</p>\n<p>在 JavaScript 项目中我们可以这么配置：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token comment">// jsconfig.json</span>\n<span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token property">"baseUrl"</span><span class="token operator">:</span> <span class="token string">"."</span><span class="token punctuation">,</span>\n  <span class="token property">"paths"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"@/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./src/*"</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在 TypeScript 项目中可以这么配置：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token comment">// tsconfig.json</span>\n<span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token property">"baseUrl"</span><span class="token operator">:</span> <span class="token string">"."</span><span class="token punctuation">,</span>\n  <span class="token property">"paths"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"@/*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./src/*"</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>我们可以定义多个路径映射，但是通常 <code>@/*</code> 就已经够用了。<code>src/components/MyComponent</code> 可以这样导入 <code>@/components/MyComponent</code>。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-09",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/configuration.html",pathLocale:"/",permalink:null,slug:"configuration",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/configuration.md",filePathRelative:"courses/architecture-of-react-app/configuration.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/configuration.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/configuration.html.vue",componentFileChunkName:"v-157614ea",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/configuration.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/configuration.html.js",dataFileChunkName:"v-157614ea",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/configuration.html",htmlFilePathRelative:"courses/architecture-of-react-app/configuration.html"},{key:"v-20c9f927",path:"/courses/architecture-of-react-app/error-handling.html",title:"错误处理",lang:"zh-CN",frontmatter:{title:"错误处理",description:"应用在运行过程中难免会遇到错误。好的错误处理机制即可以帮助我们优化在应用出错时的用户体验，又可以帮助我们跟踪解决错误。",keywords:["React","架构","错误处理"],date:"2021-08-12T00:00:00.000Z",key:10},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"API 错误",slug:"api-错误",children:[]},{level:2,title:"应用运行错误",slug:"应用运行错误",children:[]},{level:2,title:"错误跟踪",slug:"错误跟踪",children:[]}],content:"\n## API 错误\n\n在应用运行过程中，经常会遇到 API 报错。因此，我们需要在请求 API 中的时候启用一个拦截器来处理错误，然后提示用户是什么导致了错误。\n\n[这里是使用拦截器并提示用户的样例](https://github.com/everfind/bulletproof-react/blob/master/src/lib/axios.ts)\n\n## 应用运行错误\n\n在 React 的组件树中，我们要使用 [Error Boundaries](https://reactjs.org/docs/error-boundaries.html#gatsby-focus-wrapper) 来处理错误。\n\n常规的做法是在全局加一个 Error Boundary，当应用出错的时候可以处理。但是这么做有一个问题，就是即使一个很细节的地方出错了，整个应用都不能使用了。因此，我们建议对应用的各个部分分别使用 Error Boundary，这样可以保证一个地方出错了，其他功能还可以正常使用。\n\n[这里是 Error Boundary 的样例](https://github.com/everfind/bulletproof-react/blob/master/src/context/index.tsx)\n\n## 错误跟踪\n\n我们需要跟踪应用中出现的任何错误。这方面可以使用 [Sentry](https://sentry.io/) 这款工具。它可以上报应用运行过程中的任何错误，同时还将浏览器、操作系统信息等也一起上传。如果我们在 Sentry 控制台上传了源代码的 Source Map，我们可以定位到错误发生在源代码的哪一行。\n",contentRendered:'<h2 id="api-错误" tabindex="-1"><a class="header-anchor" href="#api-错误" aria-hidden="true">#</a> API 错误</h2>\n<p>在应用运行过程中，经常会遇到 API 报错。因此，我们需要在请求 API 中的时候启用一个拦截器来处理错误，然后提示用户是什么导致了错误。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/lib/axios.ts" target="_blank" rel="noopener noreferrer">这里是使用拦截器并提示用户的样例<OutboundLink/></a></p>\n<h2 id="应用运行错误" tabindex="-1"><a class="header-anchor" href="#应用运行错误" aria-hidden="true">#</a> 应用运行错误</h2>\n<p>在 React 的组件树中，我们要使用 <a href="https://reactjs.org/docs/error-boundaries.html#gatsby-focus-wrapper" target="_blank" rel="noopener noreferrer">Error Boundaries<OutboundLink/></a> 来处理错误。</p>\n<p>常规的做法是在全局加一个 Error Boundary，当应用出错的时候可以处理。但是这么做有一个问题，就是即使一个很细节的地方出错了，整个应用都不能使用了。因此，我们建议对应用的各个部分分别使用 Error Boundary，这样可以保证一个地方出错了，其他功能还可以正常使用。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/context/index.tsx" target="_blank" rel="noopener noreferrer">这里是 Error Boundary 的样例<OutboundLink/></a></p>\n<h2 id="错误跟踪" tabindex="-1"><a class="header-anchor" href="#错误跟踪" aria-hidden="true">#</a> 错误跟踪</h2>\n<p>我们需要跟踪应用中出现的任何错误。这方面可以使用 <a href="https://sentry.io/" target="_blank" rel="noopener noreferrer">Sentry<OutboundLink/></a> 这款工具。它可以上报应用运行过程中的任何错误，同时还将浏览器、操作系统信息等也一起上传。如果我们在 Sentry 控制台上传了源代码的 Source Map，我们可以定位到错误发生在源代码的哪一行。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-12",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/error-handling.html",pathLocale:"/",permalink:null,slug:"error-handling",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/error-handling.md",filePathRelative:"courses/architecture-of-react-app/error-handling.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/error-handling.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/error-handling.html.vue",componentFileChunkName:"v-20c9f927",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/error-handling.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/error-handling.html.js",dataFileChunkName:"v-20c9f927",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/error-handling.html",htmlFilePathRelative:"courses/architecture-of-react-app/error-handling.html"},{key:"v-d0183c1c",path:"/courses/architecture-of-react-app/forms.html",title:"表单系统",lang:"zh-CN",frontmatter:{title:"表单系统",description:"表单是前端开发的重要组成部分，本篇介绍社区里几个优秀的表单方案。",keywords:["React","架构","表单"],date:"2021-08-10T00:00:00.000Z",key:4},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"表单系统",slug:"表单系统",children:[]},{level:2,title:"表单校验",slug:"表单校验",children:[]}],content:"\n不管是什么样的前端应用，表单都是重要的一个组件。\n\n根据需求场景不同，表单有时候会非常复杂，元素很多，同时元素又有不同的校验规则。\n\n## 表单系统\n\n在 React 中，表单有[受控](https://reactjs.org/docs/forms.html#controlled-components)和[非受控](https://reactjs.org/docs/uncontrolled-components.html)两种。\n\n尽管我们可以使用 React 直接构建表单系统，但是要想有一个完善的表单紫铜，开发量很大。好在社区里已经有了几个比较优秀的解决方案。\n\n- [React Hook Form](http://react-hook-form.com/) 基于非受控组件思路实现的表单系统，性能卓著\n- [Formik](https://formik.org/) 基于受控组件思路实现的表单系统，功能强大\n- [React Final Form](https://github.com/final-form/react-final-form) [redux-form](https://redux-form.com/) 开发者开发的表单系统，解决了很多 redux-form 中没有解决的问题\n\n通常我们会对表单和表单组件进行必要的封装，使得这些组件能更好的满足应用的需求。下面是封装的样例。\n\n[表单封装样例](https://github.com/everfind/bulletproof-react/blob/master/src/components/Form/Form.tsx)\n\n[组件封装样例](https://github.com/everfind/bulletproof-react/blob/master/src/components/Form/InputField.tsx)\n\n## 表单校验\n\n表单校验是一件复杂且繁琐的工作。我们可以使用下面的几个社区方案来帮助我们减轻工作负担。\n\n- [zod](https://github.com/colinhacks/zod) 一款基于 TypeScript 的 schema 声明和校验库\n- [yup](https://github.com/jquense/yup) 一款负责解析值和验证值得 JavaScript schema 验证器。\n\n[这里有一份表单校验配置样例](https://github.com/everfind/bulletproof-react/blob/master/src/features/auth/components/RegisterForm.tsx)\n",contentRendered:'<p>不管是什么样的前端应用，表单都是重要的一个组件。</p>\n<p>根据需求场景不同，表单有时候会非常复杂，元素很多，同时元素又有不同的校验规则。</p>\n<h2 id="表单系统" tabindex="-1"><a class="header-anchor" href="#表单系统" aria-hidden="true">#</a> 表单系统</h2>\n<p>在 React 中，表单有<a href="https://reactjs.org/docs/forms.html#controlled-components" target="_blank" rel="noopener noreferrer">受控<OutboundLink/></a>和<a href="https://reactjs.org/docs/uncontrolled-components.html" target="_blank" rel="noopener noreferrer">非受控<OutboundLink/></a>两种。</p>\n<p>尽管我们可以使用 React 直接构建表单系统，但是要想有一个完善的表单紫铜，开发量很大。好在社区里已经有了几个比较优秀的解决方案。</p>\n<ul>\n<li><a href="http://react-hook-form.com/" target="_blank" rel="noopener noreferrer">React Hook Form<OutboundLink/></a> 基于非受控组件思路实现的表单系统，性能卓著</li>\n<li><a href="https://formik.org/" target="_blank" rel="noopener noreferrer">Formik<OutboundLink/></a> 基于受控组件思路实现的表单系统，功能强大</li>\n<li><a href="https://github.com/final-form/react-final-form" target="_blank" rel="noopener noreferrer">React Final Form<OutboundLink/></a> <a href="https://redux-form.com/" target="_blank" rel="noopener noreferrer">redux-form<OutboundLink/></a> 开发者开发的表单系统，解决了很多 redux-form 中没有解决的问题</li>\n</ul>\n<p>通常我们会对表单和表单组件进行必要的封装，使得这些组件能更好的满足应用的需求。下面是封装的样例。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/components/Form/Form.tsx" target="_blank" rel="noopener noreferrer">表单封装样例<OutboundLink/></a></p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/components/Form/InputField.tsx" target="_blank" rel="noopener noreferrer">组件封装样例<OutboundLink/></a></p>\n<h2 id="表单校验" tabindex="-1"><a class="header-anchor" href="#表单校验" aria-hidden="true">#</a> 表单校验</h2>\n<p>表单校验是一件复杂且繁琐的工作。我们可以使用下面的几个社区方案来帮助我们减轻工作负担。</p>\n<ul>\n<li><a href="https://github.com/colinhacks/zod" target="_blank" rel="noopener noreferrer">zod<OutboundLink/></a> 一款基于 TypeScript 的 schema 声明和校验库</li>\n<li><a href="https://github.com/jquense/yup" target="_blank" rel="noopener noreferrer">yup<OutboundLink/></a> 一款负责解析值和验证值得 JavaScript schema 验证器。</li>\n</ul>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/features/auth/components/RegisterForm.tsx" target="_blank" rel="noopener noreferrer">这里有一份表单校验配置样例<OutboundLink/></a></p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-10",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/forms.html",pathLocale:"/",permalink:null,slug:"forms",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/forms.md",filePathRelative:"courses/architecture-of-react-app/forms.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/forms.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/forms.html.vue",componentFileChunkName:"v-d0183c1c",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/forms.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/forms.html.js",dataFileChunkName:"v-d0183c1c",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/forms.html",htmlFilePathRelative:"courses/architecture-of-react-app/forms.html"},{key:"v-26262891",path:"/courses/architecture-of-react-app/performance.html",title:"性能",lang:"zh-CN",frontmatter:{title:"性能",description:"应用要有好的用户体验，性能是首先需要考虑的问题。本篇介绍几个优化性能的方法。",keywords:["React","架构","性能"],date:"2021-08-12T00:00:00.000Z",key:11},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"分割代码",slug:"分割代码",children:[]},{level:2,title:"组件和状态优化",slug:"组件和状态优化",children:[]},{level:2,title:"图片优化",slug:"图片优化",children:[]},{level:2,title:"Web vitals",slug:"web-vitals",children:[]},{level:2,title:"部署",slug:"部署",children:[]}],content:"\n## 分割代码\n\n我们将应用代码分割成多个部分，应用在运行的时候按需加载使用到的代码。这样可以减少用户打开页面时资源加载的时间。\n\n通常情况下，我们都是按照页面路由来分割代码。\n\n[这里是分割代码的样例](https://github.com/everfind/bulletproof-react/blob/master/src/routes/index.tsx)\n\n## 组件和状态优化\n\n* 不要将所有状态都放到一个 [Context](https://reactjs.org/docs/context.html#gatsby-focus-wrapper) 中，这样会导致不必要的重新渲染。我们应该将状态进行分割，然后放到多个状态中去。\n* 保持状态与使用状态的组件越近越好。这样可以避免未使用状态的组件的重新渲染。\n* 如果一个初始状态需要通过复杂的计算来过的，那么应用使用状态初始化函数。\n\n```js\n// 每次组件重新渲染的时候都会计算\nconst [state, setState] = React.useState(myExpensiveFn());\n\n// 只会计算一次\nconst [state, setState] = React.useState(() => myExpensiveFn());\n```\n\n* 如果状态会被很多组件使用，我们应该使用状态管理库，比如 [recoil](https://recoiljs.org/) 和 [jotai](https://jotai.pmnd.rs/)\n\n* 如果碰到组件渲染的性能问题，可以考虑将 [Chakra UI](https://chakra-ui.com/)、[emotion](https://emotion.sh/docs/introduction)、[styled-components](https://styled-components.com/) 等运行时样式方案改成 [tailwind](https://tailwindcss.com/)、[linaria](https://github.com/callstack/linaria)、[vanilla-extract](https://github.com/seek-oss/vanilla-extract) 或 [CSS modules](https://github.com/css-modules/css-modules) 等编译时样式方案。\n\n## 图片优化\n\n不在当前窗口可视范围内的图片都应该通过懒加载的方式加载。\n\n同时，应该劲量使用更现代的图片格式（比如 WEBP）来让图片加载更快。\n\n## Web vitals\n\n自从 Google 在收录网页的时候会考虑 Web vitals，我们应该留心我们的页面在 [Lighthouse](https://web.dev/measure/) 和 [Pagespeed Insights](https://developers.google.com/speed/pagespeed/insights/) 中  Web vitals 分数。\n\n## 部署\n\n将静态资源都部署到 CDN 上去。\n\n常见的 CDN 有：\n\n* [Aliyun](https://help.aliyun.com/product/27099.html)\n* [AWS](https://aws.amazon.com/cloudfront/)\n* [CloudFlare](https://www.cloudflare.com/en-gb/cdn/)\n* [Qiniu CDN](https://www.qiniu.com/products/qcdn)\n",contentRendered:'<h2 id="分割代码" tabindex="-1"><a class="header-anchor" href="#分割代码" aria-hidden="true">#</a> 分割代码</h2>\n<p>我们将应用代码分割成多个部分，应用在运行的时候按需加载使用到的代码。这样可以减少用户打开页面时资源加载的时间。</p>\n<p>通常情况下，我们都是按照页面路由来分割代码。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/routes/index.tsx" target="_blank" rel="noopener noreferrer">这里是分割代码的样例<OutboundLink/></a></p>\n<h2 id="组件和状态优化" tabindex="-1"><a class="header-anchor" href="#组件和状态优化" aria-hidden="true">#</a> 组件和状态优化</h2>\n<ul>\n<li>不要将所有状态都放到一个 <a href="https://reactjs.org/docs/context.html#gatsby-focus-wrapper" target="_blank" rel="noopener noreferrer">Context<OutboundLink/></a> 中，这样会导致不必要的重新渲染。我们应该将状态进行分割，然后放到多个状态中去。</li>\n<li>保持状态与使用状态的组件越近越好。这样可以避免未使用状态的组件的重新渲染。</li>\n<li>如果一个初始状态需要通过复杂的计算来过的，那么应用使用状态初始化函数。</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 每次组件重新渲染的时候都会计算</span>\n<span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token function">myExpensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 只会计算一次</span>\n<span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">myExpensiveFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul>\n<li>\n<p>如果状态会被很多组件使用，我们应该使用状态管理库，比如 <a href="https://recoiljs.org/" target="_blank" rel="noopener noreferrer">recoil<OutboundLink/></a> 和 <a href="https://jotai.pmnd.rs/" target="_blank" rel="noopener noreferrer">jotai<OutboundLink/></a></p>\n</li>\n<li>\n<p>如果碰到组件渲染的性能问题，可以考虑将 <a href="https://chakra-ui.com/" target="_blank" rel="noopener noreferrer">Chakra UI<OutboundLink/></a>、<a href="https://emotion.sh/docs/introduction" target="_blank" rel="noopener noreferrer">emotion<OutboundLink/></a>、<a href="https://styled-components.com/" target="_blank" rel="noopener noreferrer">styled-components<OutboundLink/></a> 等运行时样式方案改成 <a href="https://tailwindcss.com/" target="_blank" rel="noopener noreferrer">tailwind<OutboundLink/></a>、<a href="https://github.com/callstack/linaria" target="_blank" rel="noopener noreferrer">linaria<OutboundLink/></a>、<a href="https://github.com/seek-oss/vanilla-extract" target="_blank" rel="noopener noreferrer">vanilla-extract<OutboundLink/></a> 或 <a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener noreferrer">CSS modules<OutboundLink/></a> 等编译时样式方案。</p>\n</li>\n</ul>\n<h2 id="图片优化" tabindex="-1"><a class="header-anchor" href="#图片优化" aria-hidden="true">#</a> 图片优化</h2>\n<p>不在当前窗口可视范围内的图片都应该通过懒加载的方式加载。</p>\n<p>同时，应该劲量使用更现代的图片格式（比如 WEBP）来让图片加载更快。</p>\n<h2 id="web-vitals" tabindex="-1"><a class="header-anchor" href="#web-vitals" aria-hidden="true">#</a> Web vitals</h2>\n<p>自从 Google 在收录网页的时候会考虑 Web vitals，我们应该留心我们的页面在 <a href="https://web.dev/measure/" target="_blank" rel="noopener noreferrer">Lighthouse<OutboundLink/></a> 和 <a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener noreferrer">Pagespeed Insights<OutboundLink/></a> 中  Web vitals 分数。</p>\n<h2 id="部署" tabindex="-1"><a class="header-anchor" href="#部署" aria-hidden="true">#</a> 部署</h2>\n<p>将静态资源都部署到 CDN 上去。</p>\n<p>常见的 CDN 有：</p>\n<ul>\n<li><a href="https://help.aliyun.com/product/27099.html" target="_blank" rel="noopener noreferrer">Aliyun<OutboundLink/></a></li>\n<li><a href="https://aws.amazon.com/cloudfront/" target="_blank" rel="noopener noreferrer">AWS<OutboundLink/></a></li>\n<li><a href="https://www.cloudflare.com/en-gb/cdn/" target="_blank" rel="noopener noreferrer">CloudFlare<OutboundLink/></a></li>\n<li><a href="https://www.qiniu.com/products/qcdn" target="_blank" rel="noopener noreferrer">Qiniu CDN<OutboundLink/></a></li>\n</ul>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-12",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/performance.html",pathLocale:"/",permalink:null,slug:"performance",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/performance.md",filePathRelative:"courses/architecture-of-react-app/performance.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/performance.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/performance.html.vue",componentFileChunkName:"v-26262891",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/performance.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/performance.html.js",dataFileChunkName:"v-26262891",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/performance.html",htmlFilePathRelative:"courses/architecture-of-react-app/performance.html"},{key:"v-597896d0",path:"/courses/architecture-of-react-app/state.html",title:"状态管理",lang:"zh-CN",frontmatter:{title:"状态管理",description:"状态管理可以分几个层面来讨论，本篇来逐一进行说明，并介绍社区里的优秀实践方案",keywords:["React","架构","状态管理"],date:"2021-08-11T00:00:00.000Z",key:6},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"UI 状态",slug:"ui-状态",children:[]},{level:2,title:"服务器缓存状态",slug:"服务器缓存状态",children:[]},{level:2,title:"URL 状态",slug:"url-状态",children:[]}],content:"\n状态管理可以分成多个层面来讨论。\n\n## UI 状态\n\nUI 状态通常被用来控制页面的交互，比如打开弹框、通知消息、修改颜色等。出于性能和可维护性考虑，我们建议让状态与使用状态的组件离的越近越好。不要把所有状态都放到全局状态上去。\n\n下面是一些比较好的 UI 状态库：\n\n* [Context](https://reactjs.org/docs/context.html) + [hooks](https://reactjs.org/docs/hooks-intro.html)\n* [zustand](https://github.com/pmndrs/zustand)\n* [constate](https://github.com/diegohaz/constate)\n* [redux](https://redux.js.org/)\n* [mobx](https://mobx.js.org/)\n* [jotai](https://github.com/pmndrs/jotai)\n* [recoil](https://recoiljs.org/)\n\n[这里有一个 UI 状态管理的样例](https://github.com/everfind/bulletproof-react/blob/master/src/hooks/useNotificationStore.ts)\n\n## 服务器缓存状态\n\n这种类型的状态，通常都需要从服务端获取数据，然后缓存在客户端，方便后续时候。\n\n虽然我们可以通过一些状态管理库比如 redux 来实现数据缓存，但是社区里有更好的解决方案。\n\n这里有几个比较好的服务器缓存状态库：\n\n* [react-query](https://react-query.tanstack.com/) 支持 REST 和 GraphQL\n* [swr](https://github.com/everfind/bulletproof-react/blob/master/docs) 支持 REST 和 GraphQL\n* [Apollo Client](https://github.com/everfind/bulletproof-react/blob/master/docs) 仅支持 GraphQL\n* [urql](https://github.com/everfind/bulletproof-react/blob/master/docs) 仅支持 GraphQL\n\n[这里有一个服务器缓存状态的样例](https://github.com/everfind/bulletproof-react/blob/master/src/features/discussions/hooks/useDiscussions.ts)\n\n## URL 状态\n\n在有些场景下，我们会将一些数据状态放到浏览器的地址栏中，来保存页面状态。比如在一个分页列表，我们可以在页面刷新的时候保证当前选中的页码不变。\n",contentRendered:'<p>状态管理可以分成多个层面来讨论。</p>\n<h2 id="ui-状态" tabindex="-1"><a class="header-anchor" href="#ui-状态" aria-hidden="true">#</a> UI 状态</h2>\n<p>UI 状态通常被用来控制页面的交互，比如打开弹框、通知消息、修改颜色等。出于性能和可维护性考虑，我们建议让状态与使用状态的组件离的越近越好。不要把所有状态都放到全局状态上去。</p>\n<p>下面是一些比较好的 UI 状态库：</p>\n<ul>\n<li><a href="https://reactjs.org/docs/context.html" target="_blank" rel="noopener noreferrer">Context<OutboundLink/></a> + <a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener noreferrer">hooks<OutboundLink/></a></li>\n<li><a href="https://github.com/pmndrs/zustand" target="_blank" rel="noopener noreferrer">zustand<OutboundLink/></a></li>\n<li><a href="https://github.com/diegohaz/constate" target="_blank" rel="noopener noreferrer">constate<OutboundLink/></a></li>\n<li><a href="https://redux.js.org/" target="_blank" rel="noopener noreferrer">redux<OutboundLink/></a></li>\n<li><a href="https://mobx.js.org/" target="_blank" rel="noopener noreferrer">mobx<OutboundLink/></a></li>\n<li><a href="https://github.com/pmndrs/jotai" target="_blank" rel="noopener noreferrer">jotai<OutboundLink/></a></li>\n<li><a href="https://recoiljs.org/" target="_blank" rel="noopener noreferrer">recoil<OutboundLink/></a></li>\n</ul>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/hooks/useNotificationStore.ts" target="_blank" rel="noopener noreferrer">这里有一个 UI 状态管理的样例<OutboundLink/></a></p>\n<h2 id="服务器缓存状态" tabindex="-1"><a class="header-anchor" href="#服务器缓存状态" aria-hidden="true">#</a> 服务器缓存状态</h2>\n<p>这种类型的状态，通常都需要从服务端获取数据，然后缓存在客户端，方便后续时候。</p>\n<p>虽然我们可以通过一些状态管理库比如 redux 来实现数据缓存，但是社区里有更好的解决方案。</p>\n<p>这里有几个比较好的服务器缓存状态库：</p>\n<ul>\n<li><a href="https://react-query.tanstack.com/" target="_blank" rel="noopener noreferrer">react-query<OutboundLink/></a> 支持 REST 和 GraphQL</li>\n<li><a href="https://github.com/everfind/bulletproof-react/blob/master/docs" target="_blank" rel="noopener noreferrer">swr<OutboundLink/></a> 支持 REST 和 GraphQL</li>\n<li><a href="https://github.com/everfind/bulletproof-react/blob/master/docs" target="_blank" rel="noopener noreferrer">Apollo Client<OutboundLink/></a> 仅支持 GraphQL</li>\n<li><a href="https://github.com/everfind/bulletproof-react/blob/master/docs" target="_blank" rel="noopener noreferrer">urql<OutboundLink/></a> 仅支持 GraphQL</li>\n</ul>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/features/discussions/hooks/useDiscussions.ts" target="_blank" rel="noopener noreferrer">这里有一个服务器缓存状态的样例<OutboundLink/></a></p>\n<h2 id="url-状态" tabindex="-1"><a class="header-anchor" href="#url-状态" aria-hidden="true">#</a> URL 状态</h2>\n<p>在有些场景下，我们会将一些数据状态放到浏览器的地址栏中，来保存页面状态。比如在一个分页列表，我们可以在页面刷新的时候保证当前选中的页码不变。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-11",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/state.html",pathLocale:"/",permalink:null,slug:"state",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/state.md",filePathRelative:"courses/architecture-of-react-app/state.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/state.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/state.html.vue",componentFileChunkName:"v-597896d0",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/state.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/state.html.js",dataFileChunkName:"v-597896d0",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/state.html",htmlFilePathRelative:"courses/architecture-of-react-app/state.html"},{key:"v-9f6f91a4",path:"/courses/architecture-of-react-app/structure.html",title:"项目结构设计",lang:"zh-CN",frontmatter:{title:"项目结构设计",description:"良好的目录结构设计可以在保证代码功能模块清晰的同时提供很好的扩展性，给项目带来长久的生命力。",keywords:["React","架构","目录结构"],date:"2021-08-10T00:00:00.000Z",key:2},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"项目目录结构",slug:"项目目录结构",children:[]},{level:2,title:"功能模块目录结构",slug:"功能模块目录结构",children:[]}],content:"\n良好的目录结构设计可以在保证代码功能模块清晰的同时提供很好的扩展性，给项目带来长久的生命力。\n\n## 项目目录结构\n通常来说，整个项目的代码都在 `src` 目录下。我们建议 `src` 目录组织如下：\n\n```\nsrc\n|\n+-- assets          # 图片字体等静态资源\n|\n+-- components      # 全应用共享的公共组件\n|\n+-- config          # 全局配置、环境变量等。在这里导出，应用中其他代码通过导入获取。\n|\n+-- context         # 所有的全局 context\n|\n+-- features        # 功能模块目录，也可以叫 pages\n|\n+-- hooks           # 全应用共享的公共 hooks\n|\n+-- lib             # 导出预处理过的公共库，比如添加了 interceptor 的 axios 实例。\n|\n+-- routes          # 路由配置\n|\n+-- test            # 测试代码\n|\n+-- types           # 整个应用共用的 typescript 类型定义\n|\n+-- utils           # 整个应用共享的 utils 函数\n```\n\n## 功能模块目录结构\n\n为了保证能以最简单、最具可维护性的方式扩展应用，我们应该尽可能将代码约束在 `features` 目录中。每个 `feature` 目录中应该仅仅包含这个功能特有的代码，避免功能特有的代码与其他公共代码混合在一起。维护一个功能模块的代码比维护一个偏平的大目录更加简单。\n\n一个 `feature` 目录的结构如下：\n\n```\nsrc/features/awesome-feature\n|\n+-- api         # 导出与这个功能相关的所有 API 请求\n|\n+-- components  # 这个功能内的公共组件，其他地方不能使用\n|\n+-- hooks       # 这个功能内使用的 hooks，其他地方不能使用\n|\n+-- routes      # 功能内的路由配置\n|\n+-- types       # 功能内的 typescript 类型定义\n|\n+-- utils       # 功能内使用的 utils 函数\n|\n+-- index.ts    # 功能入口点，同时也可以在这里导出任何可以被其他地方使用的代码\n```\n\n`feature` 目录下的 `index.ts` 应该导出所有这个功能模块可以对外提供的 API。\n\n比如我们可以在其他模块这样导入 `awesome-feature` 内的 `AwesomeComponent`，\n\n```ts\nimport {AwesomeComponent} from \"@/features/awesome-feature\"\n```\n\n但是不能像下面这样导入 `AwesomeComponent`。\n\n```ts\nimport {AwesomeComponent} from \"@/features/awesome-feature/components/AwesomeComponent\"\n```\n\nESLint 提供了一个配置可以帮助我们禁止上面这种直接导入方式。配置如下：\n\n```js\n{\n    rules: {\n        'no-restricted-imports': [\n            'error',\n            {\n            patterns: ['@/features/*/*'],\n            },\n        ],\n\n    ...rest of the configuration\n}\n```\n",contentRendered:'<p>良好的目录结构设计可以在保证代码功能模块清晰的同时提供很好的扩展性，给项目带来长久的生命力。</p>\n<h2 id="项目目录结构" tabindex="-1"><a class="header-anchor" href="#项目目录结构" aria-hidden="true">#</a> 项目目录结构</h2>\n<p>通常来说，整个项目的代码都在 <code>src</code> 目录下。我们建议 <code>src</code> 目录组织如下：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>src\n|\n+-- assets          # 图片字体等静态资源\n|\n+-- components      # 全应用共享的公共组件\n|\n+-- config          # 全局配置、环境变量等。在这里导出，应用中其他代码通过导入获取。\n|\n+-- context         # 所有的全局 context\n|\n+-- features        # 功能模块目录，也可以叫 pages\n|\n+-- hooks           # 全应用共享的公共 hooks\n|\n+-- lib             # 导出预处理过的公共库，比如添加了 interceptor 的 axios 实例。\n|\n+-- routes          # 路由配置\n|\n+-- test            # 测试代码\n|\n+-- types           # 整个应用共用的 typescript 类型定义\n|\n+-- utils           # 整个应用共享的 utils 函数\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="功能模块目录结构" tabindex="-1"><a class="header-anchor" href="#功能模块目录结构" aria-hidden="true">#</a> 功能模块目录结构</h2>\n<p>为了保证能以最简单、最具可维护性的方式扩展应用，我们应该尽可能将代码约束在 <code>features</code> 目录中。每个 <code>feature</code> 目录中应该仅仅包含这个功能特有的代码，避免功能特有的代码与其他公共代码混合在一起。维护一个功能模块的代码比维护一个偏平的大目录更加简单。</p>\n<p>一个 <code>feature</code> 目录的结构如下：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>src/features/awesome-feature\n|\n+-- api         # 导出与这个功能相关的所有 API 请求\n|\n+-- components  # 这个功能内的公共组件，其他地方不能使用\n|\n+-- hooks       # 这个功能内使用的 hooks，其他地方不能使用\n|\n+-- routes      # 功能内的路由配置\n|\n+-- types       # 功能内的 typescript 类型定义\n|\n+-- utils       # 功能内使用的 utils 函数\n|\n+-- index.ts    # 功能入口点，同时也可以在这里导出任何可以被其他地方使用的代码\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><code>feature</code> 目录下的 <code>index.ts</code> 应该导出所有这个功能模块可以对外提供的 API。</p>\n<p>比如我们可以在其他模块这样导入 <code>awesome-feature</code> 内的 <code>AwesomeComponent</code>，</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>AwesomeComponent<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"@/features/awesome-feature"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>但是不能像下面这样导入 <code>AwesomeComponent</code>。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>AwesomeComponent<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"@/features/awesome-feature/components/AwesomeComponent"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>ESLint 提供了一个配置可以帮助我们禁止上面这种直接导入方式。配置如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">{</span>\n    rules<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token string">\'no-restricted-imports\'</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n            <span class="token string">\'error\'</span><span class="token punctuation">,</span>\n            <span class="token punctuation">{</span>\n            patterns<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'@/features/*/*\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n            <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token punctuation">]</span><span class="token punctuation">,</span>\n\n    <span class="token operator">...</span>rest <span class="token keyword">of</span> the configuration\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-10",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/structure.html",pathLocale:"/",permalink:null,slug:"structure",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/structure.md",filePathRelative:"courses/architecture-of-react-app/structure.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/structure.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/structure.html.vue",componentFileChunkName:"v-9f6f91a4",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/structure.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/structure.html.js",dataFileChunkName:"v-9f6f91a4",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/structure.html",htmlFilePathRelative:"courses/architecture-of-react-app/structure.html"},{key:"v-2ca566b1",path:"/courses/architecture-of-react-app/testing.html",title:"测试",lang:"zh-CN",frontmatter:{title:"测试",description:"好的测试可以给项目质量带来质的提升。不同的测试方法侧重点不同，本篇介绍常见的测试方法，以及一些可用的测试工具。",keywords:["React","架构","测试"],date:"2021-08-12T00:00:00.000Z",key:9},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"测试方法",slug:"测试方法",children:[{level:3,title:"单元测试（Unit Test）",slug:"单元测试-unit-test",children:[]},{level:3,title:"集成测试（Integration Test）",slug:"集成测试-integration-test",children:[]},{level:3,title:"端到端测试（E2E Test）",slug:"端到端测试-e2e-test",children:[]}]},{level:2,title:"测试工具",slug:"测试工具",children:[{level:3,title:"Jest",slug:"jest",children:[]},{level:3,title:"Testing Library",slug:"testing-library",children:[]},{level:3,title:"Cypress",slug:"cypress",children:[]}]}],content:"\n## 测试方法\n\n通常有如下几种测试方法：\n\n### 单元测试（Unit Test）\n\n单元测试，顾名思义，就是对应用中的某一个功能单元进行测试，这个功能单元可以是一个组件，也可以是一个函数。通常我们会对应用中全局通用的组件和函数进行单元测试。一是因为这些组件和函数相对来说比较独立，二是有时候在集成测试的时候，不容易创建测试场景。\n\n[这里是单元测试的样例](https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/ConfirmationDialog/__tests__/ConfirmationDialog.test.tsx)\n\n### 集成测试（Integration Test）\n\n集成测试，是将应用中多个模块集成在一起进行测试。在我们的测试代码中，大部分测试用例应该都是集成测试。因此只有集成测试才能保证多个模块集成在一起之后的功能是符合预期的。单元测试虽然能保证单个功能单元的表现符合预期，但是不能保证多个单元集成在一起之后的功能是否符合预期。\n\n[这里是集成测试的样例](https://github.com/everfind/bulletproof-react/blob/master/src/features/auth/components/__tests__/RegisterForm.test.tsx)\n\n### 端到端测试（E2E Test）\n\n端到端（End-to-End）测试是对整个应用整体进行测试。端到端测试会将前端和后端放在一起进行测试，来保证整个系统是正常工作的。端到端测试其实就在模拟用户是如何使用系统的。\n\n[这里是端到端测试的样例](https://github.com/everfind/bulletproof-react/blob/master/cypress/integration/smoke.ts)\n\n## 测试工具\n\n### Jest\n\n[Jest](https://jestjs.io/) 是一款全功能测试框架，并且在逐步成为测试 JavaScript 应用程序的事实上的标准。\n\nJest 非常灵活，且提供了丰富的配置项。Jest 既支持对前端应用进行测试，也支持对后端服务进行测试。\n\n### Testing Library\n\n[Testing Library](https://testing-library.com/) 是一个测试工具和库的集合。Test Library 旨在让我们能像现实用户使用系统一样测试我们的应用，而不是局限在测试应用的实现细节。\n\n举个例子，我们不应该测试当前组件的状态值是多少，而是应该测试当前组件展示在屏幕中的样子。这样的话，如果我们重构了代码，修改了组件的状态管理代码，但是我们的测试用例依然是有效的，因为组件展示的样子没有变。\n\n### Cypress\n\n[Cypress](https://www.cypress.io/) 是一款自动实行端到端测试的自动化工具。\n\n我们定义一个真实用户会对应用进行怎样的操作，然后 Cypress 工具负责执行这些操作。\n\nCypress 有两种模式：\n\n* 浏览器模式 -- 会启动一个浏览器来执行测试用例。在用例执行过程中，我们可以使用很多工具来可视化的观察应用的状态变化。我们通常在本地开发的时候会使用浏览器模式。\n* 无头模式 -- 会启动一个无头浏览器来执行测试用例。非常适合在 CI/CD 中使用。\n\nCypress 支持配置各种插件和命令，我们甚至可以将其与 Testing Library 进行集成。Cypress 也支持自定义命令，通过自定义命令，我们可以对一些通用任务进行抽象，然后集成到测试中去。\n\n[这里是自定义 Cypress 命令的样例](https://github.com/everfind/bulletproof-react/blob/master/cypress/support/commands.ts)\n",contentRendered:'<h2 id="测试方法" tabindex="-1"><a class="header-anchor" href="#测试方法" aria-hidden="true">#</a> 测试方法</h2>\n<p>通常有如下几种测试方法：</p>\n<h3 id="单元测试-unit-test" tabindex="-1"><a class="header-anchor" href="#单元测试-unit-test" aria-hidden="true">#</a> 单元测试（Unit Test）</h3>\n<p>单元测试，顾名思义，就是对应用中的某一个功能单元进行测试，这个功能单元可以是一个组件，也可以是一个函数。通常我们会对应用中全局通用的组件和函数进行单元测试。一是因为这些组件和函数相对来说比较独立，二是有时候在集成测试的时候，不容易创建测试场景。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/components/Elements/ConfirmationDialog/__tests__/ConfirmationDialog.test.tsx" target="_blank" rel="noopener noreferrer">这里是单元测试的样例<OutboundLink/></a></p>\n<h3 id="集成测试-integration-test" tabindex="-1"><a class="header-anchor" href="#集成测试-integration-test" aria-hidden="true">#</a> 集成测试（Integration Test）</h3>\n<p>集成测试，是将应用中多个模块集成在一起进行测试。在我们的测试代码中，大部分测试用例应该都是集成测试。因此只有集成测试才能保证多个模块集成在一起之后的功能是符合预期的。单元测试虽然能保证单个功能单元的表现符合预期，但是不能保证多个单元集成在一起之后的功能是否符合预期。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/src/features/auth/components/__tests__/RegisterForm.test.tsx" target="_blank" rel="noopener noreferrer">这里是集成测试的样例<OutboundLink/></a></p>\n<h3 id="端到端测试-e2e-test" tabindex="-1"><a class="header-anchor" href="#端到端测试-e2e-test" aria-hidden="true">#</a> 端到端测试（E2E Test）</h3>\n<p>端到端（End-to-End）测试是对整个应用整体进行测试。端到端测试会将前端和后端放在一起进行测试，来保证整个系统是正常工作的。端到端测试其实就在模拟用户是如何使用系统的。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/cypress/integration/smoke.ts" target="_blank" rel="noopener noreferrer">这里是端到端测试的样例<OutboundLink/></a></p>\n<h2 id="测试工具" tabindex="-1"><a class="header-anchor" href="#测试工具" aria-hidden="true">#</a> 测试工具</h2>\n<h3 id="jest" tabindex="-1"><a class="header-anchor" href="#jest" aria-hidden="true">#</a> Jest</h3>\n<p><a href="https://jestjs.io/" target="_blank" rel="noopener noreferrer">Jest<OutboundLink/></a> 是一款全功能测试框架，并且在逐步成为测试 JavaScript 应用程序的事实上的标准。</p>\n<p>Jest 非常灵活，且提供了丰富的配置项。Jest 既支持对前端应用进行测试，也支持对后端服务进行测试。</p>\n<h3 id="testing-library" tabindex="-1"><a class="header-anchor" href="#testing-library" aria-hidden="true">#</a> Testing Library</h3>\n<p><a href="https://testing-library.com/" target="_blank" rel="noopener noreferrer">Testing Library<OutboundLink/></a> 是一个测试工具和库的集合。Test Library 旨在让我们能像现实用户使用系统一样测试我们的应用，而不是局限在测试应用的实现细节。</p>\n<p>举个例子，我们不应该测试当前组件的状态值是多少，而是应该测试当前组件展示在屏幕中的样子。这样的话，如果我们重构了代码，修改了组件的状态管理代码，但是我们的测试用例依然是有效的，因为组件展示的样子没有变。</p>\n<h3 id="cypress" tabindex="-1"><a class="header-anchor" href="#cypress" aria-hidden="true">#</a> Cypress</h3>\n<p><a href="https://www.cypress.io/" target="_blank" rel="noopener noreferrer">Cypress<OutboundLink/></a> 是一款自动实行端到端测试的自动化工具。</p>\n<p>我们定义一个真实用户会对应用进行怎样的操作，然后 Cypress 工具负责执行这些操作。</p>\n<p>Cypress 有两种模式：</p>\n<ul>\n<li>浏览器模式 -- 会启动一个浏览器来执行测试用例。在用例执行过程中，我们可以使用很多工具来可视化的观察应用的状态变化。我们通常在本地开发的时候会使用浏览器模式。</li>\n<li>无头模式 -- 会启动一个无头浏览器来执行测试用例。非常适合在 CI/CD 中使用。</li>\n</ul>\n<p>Cypress 支持配置各种插件和命令，我们甚至可以将其与 Testing Library 进行集成。Cypress 也支持自定义命令，通过自定义命令，我们可以对一些通用任务进行抽象，然后集成到测试中去。</p>\n<p><a href="https://github.com/everfind/bulletproof-react/blob/master/cypress/support/commands.ts" target="_blank" rel="noopener noreferrer">这里是自定义 Cypress 命令的样例<OutboundLink/></a></p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-12",deps:[],hoistedTags:[],links:[],pathInferred:"/courses/architecture-of-react-app/testing.html",pathLocale:"/",permalink:null,slug:"testing",filePath:"/Users/bingooo/workspace/everfind/website/docs/courses/architecture-of-react-app/testing.md",filePathRelative:"courses/architecture-of-react-app/testing.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/testing.html.vue",componentFilePathRelative:"pages/courses/architecture-of-react-app/testing.html.vue",componentFileChunkName:"v-2ca566b1",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/courses/architecture-of-react-app/testing.html.js",dataFilePathRelative:"pages/courses/architecture-of-react-app/testing.html.js",dataFileChunkName:"v-2ca566b1",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/courses/architecture-of-react-app/testing.html",htmlFilePathRelative:"courses/architecture-of-react-app/testing.html"}]}},8236:(e,t,n)=>{n.r(t),n.d(t,{default:()=>c});var a=n(6252);const r=(0,a.Wm)("div",{class:"custom-container tip"},[(0,a.Wm)("p",{class:"custom-container-title"},"TIP"),(0,a.Wm)("p",null,"React 应用架构指南")],-1),s=(0,a.Wm)("p",null,"React 是目前主流的前端框架之一，生态非常丰富，我们平时开发过程中遇到的问题，几乎都可以在 React 的生态系统中找到满足需求的库。",-1),o=(0,a.Wm)("p",null,"但是硬币都有两个面，丰富的生态有时候也会给开发人员带来困扰，比如如何在两个库之前做选择。同时，React 本身非常灵活，我们可以使用任何喜欢的方式编写 React 应用。因为没有开发人员可以遵循的规范或者预定义框架，随着时间的推移，代码库会变得混乱、不一致或过于复杂。",-1),p=(0,a.Wm)("p",null,"这个系列尝试用 React 生态系统中最好的工具来创建 React 应用，同时对如何让项目有良好的结构和可扩展性等做一些说明。",-1),i=(0,a.uE)('<blockquote><p>参考链接：https://github.com/alan2207/bulletproof-react</p></blockquote><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',2),c={render:function(e,t){const n=(0,a.up)("ArticleList");return(0,a.wg)(),(0,a.j4)(a.HY,null,[r,s,o,p,(0,a.Wm)(n,{noTag:!0}),i],64)}}}}]);