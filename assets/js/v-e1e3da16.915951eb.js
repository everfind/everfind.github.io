"use strict";(self.webpackChunkeverfind_website=self.webpackChunkeverfind_website||[]).push([[8248],{576:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-e1e3da16",path:"/posts/",title:"基础知识",lang:"zh-CN",frontmatter:{title:"基础知识",sidebar:!1},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[],filePathRelative:"posts/README.md",articleList:[{key:"v-4438e816",path:"/posts/2021/07/30/browser-event-loop.html",title:"浏览器中的事件循环与异步代码执行",lang:"zh-CN",frontmatter:{title:"浏览器中的事件循环与异步代码执行",description:"什么是事件循环？事件循环是如何工作的？宏任务、微任务分别是什么？",keywords:["事件循环","任务队列","宏任务","微任务"],date:"2021-07-30T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"事件循环（Event Loop）",slug:"事件循环-event-loop",children:[{level:3,title:"执行过程",slug:"执行过程",children:[]}]},{level:2,title:"任务与微任务",slug:"任务与微任务",children:[]},{level:2,title:"执行异步代码",slug:"执行异步代码",children:[{level:3,title:"回调函数",slug:"回调函数",children:[]},{level:3,title:"setTimeout 和 setInterval",slug:"settimeout-和-setinterval",children:[]},{level:3,title:"requestAnimationFrame",slug:"requestanimationframe",children:[]},{level:3,title:"Promise 和 Async/await",slug:"promise-和-async-await",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",children:[]}],content:"\n在浏览器中，JavaScript 的执行是单线程的。如何在单线程中实现异步操作呢？答案就是事件循环。\n\n## 事件循环（Event Loop）\n\n浏览器通过事件循环来处理事件、用户交互、JS 代码执行、渲染、网络请求等。通常又两种事件循环，一种是 Window 事件循环，一种是 Worker 事件循环。由于它们核心的工作原理相同，本文我们仅仅讨论 Window 事件循环。\n\n事件循环，首先是一个循环，每个循环周期会执行一些代码，一个循环周期被称为 `tick`。\n\n```js\nwhile (eventLoop.waitForTask()) {\n  eventLoop.processNextTask()\n}\n```\n\n一个事件循环有一到多个任务队列。每个任务队列就是一个有序的任务列表。可以理解为一段要执行的代码，或者浏览器要执行的一个动作，比如发送事件、解析 HTML 等。\n\n网页和浏览器本身的用户界面程序运行在相同的线程中，共享相同的事件循环。 该线程就是[主线程](https://developer.mozilla.org/zh-CN/docs/Glossary/Main_thread)，它除了运行网页本身的代码之外，还负责收集和派发用户和其它事件，以及渲染和绘制网页内容等。然后，事件循环会驱动发生在浏览器中与用户交互有关的一切。\n\n### 执行过程\n\n简略的说，事件循环在每一个循环周期都会顺序执行下面的步骤：\n\n1. 选择一个任务队列，从队列中取出最靠前（最老的）的任务。如果已经没有任务了，则跳到第 3 步。\n2. 执行取出的任务。\n3. 从微任务（Micro Task）队列中取出微任务执行，知道清空微任务队列。\n4. 更新渲染（resize、scroll、动画等）\n5. 返回第 1 步。\n\n每一个时间循环都有一个微任务队列。微任务队列与任务队列很像，不同的地方在于，每次循环周期只会执行任务队列中的一个任务，在这期间产生的任何任务都只能在下一个循环周期中才能得以执行。在执行前任务后，事件循环会一次执行微任务队列中的每一个微任务，直到微任务队列为空。也就是说，在微任务执行过程中新产生的微任务，也会在当前循环周期内得到执行。\n\n不同的任务队列可能有不同的优先级。比如浏览器可能会将用户鼠标和键盘输入（用户交互）的任务都放在一个任务队列中，其他任务放到另外一个队列中。在每个循环周期中优先从用户交互队列中取出任务执行，来保证及时响应用户操作。\n\n下图展示了一个事件循环周期的执行过程。\n\n![事件循环](/posts/images/browser-event-loop/event-loop.svg)\n\n## 任务与微任务\n\n一个任务可以简单的理解为一段要执行的 JavaScript 代码。比如当执行 `<script>` 标签中的代码时，一个任务会被添加到任务队列中。事件的回调函数、`setTimeout`、`setInterval` 的回调函数都会作为任务放到任务队列中。\n\n每个事件循环周期，事件循环会从任务队列中取出一个最老的任务执行，其他任务要等到下一个事件循环周期才会执行。\n\n微任务与任务没有本质的区别，只是因为被放入的微任务任务队列。事件循环在每个循环周期都会清空微任务队列中的任务。\n\n> 在浏览器的实现中，`setTimeout` 和 `setInterval` 被放在了任务队列中，`Promise` 和 [Mutation Observer API](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) 被放在的微任务队列中。我们也可以借助于 [queueMicrotask()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask) 函数向微任务队列中添加任务。\n\n## 执行异步代码\n\n我们有很多种方式来执行异步代码。\n\n### 回调函数\n\n我们可以给一些事件添加监听，设置回调函数，从而在触发事件的时候执行函数。\n\n```js\nbuttonEl.addEventListener('click', () => { /* 点击响应 */ });\n```\n\n回调函数会被放到任务队列中执行。\n\n### setTimeout 和 setInterval\n\n这两个函数大家都非常熟悉，`setTimeout` 会在指定的时间之后执行回调函数，`setInterval` 会每个一定的时间执行一次回调函数。这些回调函数都是以任务的形式被添加到任务队列中。\n\n```js\nsetTimeout(() => {\n  /* 1s 后执行 */\n}, 1000);\n\nsetInterval(() => {\n  /* 每 500 ms 执行一次 */\n}, 500);\n```\n\n> 注意，这两个函数都接收一个时间参数。但是实际运行的时候，事件循环并不会保证一定按照这个时间执行。\n\n### requestAnimationFrame\n\n`requestAnimationFrame` 是一个特殊的工具函数，浏览器会在重绘页面之前调用这个函数设置的回调，允许我们在页面重绘之前更新页面。\n\n通过这个函数，我们可以很好的在代码执行和运行设备的显示帧率（display frame rate）之间取得一个平衡。\n\n假如，我们通过 `setInterval` 来控制动画，由于每个事件循环周期执行的时间不可控，而显示器的刷新频率是固定的（通常是 60Hz），因此如果我们的动画执行过快，会出现掉帧，执行过慢又会有卡顿现象。\n\n`requestAnimationFrame` 会综合考虑显示器的刷新频率和代码的执行，以达到动画能够顺滑执行。\n\n```js\nrequestAnimationFrame(() => {\n  /* 执行一次 */\n})\n\n// 每个事件循环都会考虑执行\nfunction alwaysRun() {\n  /* 函数逻辑 */\n  requestAnimationFrame(alwaysRun);\n}\nalwaysRun();\n```\n\n### Promise 和 Async/await\n\nPromise 和 Async/await 最终都会以 `promise` 的形式在代码中执行。\n\nPromise 可以帮助我们管理有依赖关系的任务，同时可以一定程度的避免回调函数的回调地狱问题。\n\n```js\nnew Promise((resolve, reject) => {\n  /* 函数逻辑 */\n})\n.then()\n.then() // 链式调用\n```\n\nAsync/await 是 Promise 的语法糖，可以帮助我们实现以同步的形式编写异步代码，解决了回调地狱问题。\n\n```js\nasync function task() {\n  await someFunc();\n  await someOtherFunc();\n}\n```\n\nPromise 和 Async/await 的任务都是微任务，会被放到微任务队列中。\n\n## 参考资料\n\n* [HTML5 规范中的事件循环](https://www.w3.org/TR/html51/webappapis.html#event-loops)\n* [深入：微任务与Javascript运行时环境](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth)\n* [Using microtasks in JavaScript with queueMicrotask()](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide)\n* [Choosing the right approach](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Choosing_the_right_approach)\n",contentRendered:'<p>在浏览器中，JavaScript 的执行是单线程的。如何在单线程中实现异步操作呢？答案就是事件循环。</p>\n<h2 id="事件循环-event-loop" tabindex="-1"><a class="header-anchor" href="#事件循环-event-loop" aria-hidden="true">#</a> 事件循环（Event Loop）</h2>\n<p>浏览器通过事件循环来处理事件、用户交互、JS 代码执行、渲染、网络请求等。通常又两种事件循环，一种是 Window 事件循环，一种是 Worker 事件循环。由于它们核心的工作原理相同，本文我们仅仅讨论 Window 事件循环。</p>\n<p>事件循环，首先是一个循环，每个循环周期会执行一些代码，一个循环周期被称为 <code>tick</code>。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>eventLoop<span class="token punctuation">.</span><span class="token function">waitForTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  eventLoop<span class="token punctuation">.</span><span class="token function">processNextTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>一个事件循环有一到多个任务队列。每个任务队列就是一个有序的任务列表。可以理解为一段要执行的代码，或者浏览器要执行的一个动作，比如发送事件、解析 HTML 等。</p>\n<p>网页和浏览器本身的用户界面程序运行在相同的线程中，共享相同的事件循环。 该线程就是<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Main_thread" target="_blank" rel="noopener noreferrer">主线程<OutboundLink/></a>，它除了运行网页本身的代码之外，还负责收集和派发用户和其它事件，以及渲染和绘制网页内容等。然后，事件循环会驱动发生在浏览器中与用户交互有关的一切。</p>\n<h3 id="执行过程" tabindex="-1"><a class="header-anchor" href="#执行过程" aria-hidden="true">#</a> 执行过程</h3>\n<p>简略的说，事件循环在每一个循环周期都会顺序执行下面的步骤：</p>\n<ol>\n<li>选择一个任务队列，从队列中取出最靠前（最老的）的任务。如果已经没有任务了，则跳到第 3 步。</li>\n<li>执行取出的任务。</li>\n<li>从微任务（Micro Task）队列中取出微任务执行，知道清空微任务队列。</li>\n<li>更新渲染（resize、scroll、动画等）</li>\n<li>返回第 1 步。</li>\n</ol>\n<p>每一个时间循环都有一个微任务队列。微任务队列与任务队列很像，不同的地方在于，每次循环周期只会执行任务队列中的一个任务，在这期间产生的任何任务都只能在下一个循环周期中才能得以执行。在执行前任务后，事件循环会一次执行微任务队列中的每一个微任务，直到微任务队列为空。也就是说，在微任务执行过程中新产生的微任务，也会在当前循环周期内得到执行。</p>\n<p>不同的任务队列可能有不同的优先级。比如浏览器可能会将用户鼠标和键盘输入（用户交互）的任务都放在一个任务队列中，其他任务放到另外一个队列中。在每个循环周期中优先从用户交互队列中取出任务执行，来保证及时响应用户操作。</p>\n<p>下图展示了一个事件循环周期的执行过程。</p>\n<p><img src="/posts/images/browser-event-loop/event-loop.svg" alt="事件循环"></p>\n<h2 id="任务与微任务" tabindex="-1"><a class="header-anchor" href="#任务与微任务" aria-hidden="true">#</a> 任务与微任务</h2>\n<p>一个任务可以简单的理解为一段要执行的 JavaScript 代码。比如当执行 <code>&lt;script&gt;</code> 标签中的代码时，一个任务会被添加到任务队列中。事件的回调函数、<code>setTimeout</code>、<code>setInterval</code> 的回调函数都会作为任务放到任务队列中。</p>\n<p>每个事件循环周期，事件循环会从任务队列中取出一个最老的任务执行，其他任务要等到下一个事件循环周期才会执行。</p>\n<p>微任务与任务没有本质的区别，只是因为被放入的微任务任务队列。事件循环在每个循环周期都会清空微任务队列中的任务。</p>\n<blockquote>\n<p>在浏览器的实现中，<code>setTimeout</code> 和 <code>setInterval</code> 被放在了任务队列中，<code>Promise</code> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener noreferrer">Mutation Observer API<OutboundLink/></a> 被放在的微任务队列中。我们也可以借助于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask" target="_blank" rel="noopener noreferrer">queueMicrotask()<OutboundLink/></a> 函数向微任务队列中添加任务。</p>\n</blockquote>\n<h2 id="执行异步代码" tabindex="-1"><a class="header-anchor" href="#执行异步代码" aria-hidden="true">#</a> 执行异步代码</h2>\n<p>我们有很多种方式来执行异步代码。</p>\n<h3 id="回调函数" tabindex="-1"><a class="header-anchor" href="#回调函数" aria-hidden="true">#</a> 回调函数</h3>\n<p>我们可以给一些事件添加监听，设置回调函数，从而在触发事件的时候执行函数。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>buttonEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">/* 点击响应 */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>回调函数会被放到任务队列中执行。</p>\n<h3 id="settimeout-和-setinterval" tabindex="-1"><a class="header-anchor" href="#settimeout-和-setinterval" aria-hidden="true">#</a> setTimeout 和 setInterval</h3>\n<p>这两个函数大家都非常熟悉，<code>setTimeout</code> 会在指定的时间之后执行回调函数，<code>setInterval</code> 会每个一定的时间执行一次回调函数。这些回调函数都是以任务的形式被添加到任务队列中。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 1s 后执行 */</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 每 500 ms 执行一次 */</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote>\n<p>注意，这两个函数都接收一个时间参数。但是实际运行的时候，事件循环并不会保证一定按照这个时间执行。</p>\n</blockquote>\n<h3 id="requestanimationframe" tabindex="-1"><a class="header-anchor" href="#requestanimationframe" aria-hidden="true">#</a> requestAnimationFrame</h3>\n<p><code>requestAnimationFrame</code> 是一个特殊的工具函数，浏览器会在重绘页面之前调用这个函数设置的回调，允许我们在页面重绘之前更新页面。</p>\n<p>通过这个函数，我们可以很好的在代码执行和运行设备的显示帧率（display frame rate）之间取得一个平衡。</p>\n<p>假如，我们通过 <code>setInterval</code> 来控制动画，由于每个事件循环周期执行的时间不可控，而显示器的刷新频率是固定的（通常是 60Hz），因此如果我们的动画执行过快，会出现掉帧，执行过慢又会有卡顿现象。</p>\n<p><code>requestAnimationFrame</code> 会综合考虑显示器的刷新频率和代码的执行，以达到动画能够顺滑执行。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 执行一次 */</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 每个事件循环都会考虑执行</span>\n<span class="token keyword">function</span> <span class="token function">alwaysRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 函数逻辑 */</span>\n  <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>alwaysRun<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">alwaysRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="promise-和-async-await" tabindex="-1"><a class="header-anchor" href="#promise-和-async-await" aria-hidden="true">#</a> Promise 和 Async/await</h3>\n<p>Promise 和 Async/await 最终都会以 <code>promise</code> 的形式在代码中执行。</p>\n<p>Promise 可以帮助我们管理有依赖关系的任务，同时可以一定程度的避免回调函数的回调地狱问题。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">/* 函数逻辑 */</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 链式调用</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Async/await 是 Promise 的语法糖，可以帮助我们实现以同步的形式编写异步代码，解决了回调地狱问题。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">await</span> <span class="token function">someFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">await</span> <span class="token function">someOtherFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Promise 和 Async/await 的任务都是微任务，会被放到微任务队列中。</p>\n<h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>\n<ul>\n<li><a href="https://www.w3.org/TR/html51/webappapis.html#event-loops" target="_blank" rel="noopener noreferrer">HTML5 规范中的事件循环<OutboundLink/></a></li>\n<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth" target="_blank" rel="noopener noreferrer">深入：微任务与Javascript运行时环境<OutboundLink/></a></li>\n<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" target="_blank" rel="noopener noreferrer">Using microtasks in JavaScript with queueMicrotask()<OutboundLink/></a></li>\n<li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Choosing_the_right_approach" target="_blank" rel="noopener noreferrer">Choosing the right approach<OutboundLink/></a></li>\n</ul>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-07-30",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/browser-event-loop.html",pathLocale:"/",permalink:"/posts/2021/07/30/browser-event-loop.html",slug:"browser-event-loop",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/browser-event-loop.md",filePathRelative:"posts/browser-event-loop.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/30/browser-event-loop.html.vue",componentFilePathRelative:"pages/posts/2021/07/30/browser-event-loop.html.vue",componentFileChunkName:"v-4438e816",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/30/browser-event-loop.html.js",dataFilePathRelative:"pages/posts/2021/07/30/browser-event-loop.html.js",dataFileChunkName:"v-4438e816",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/07/30/browser-event-loop.html",htmlFilePathRelative:"posts/2021/07/30/browser-event-loop.html"},{key:"v-7c282419",path:"/posts/2021/07/03/component-dev-principles.html",title:"前端组件开发原则",lang:"zh-CN",frontmatter:{title:"前端组件开发原则",description:"介绍前端组件开发的一些原则，提高效率和可维护性。",keywords:["组件开发","原则","principle"],date:"2021-07-03T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["经验总结"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"清晰的组件结构",slug:"清晰的组件结构",children:[]},{level:2,title:"单一数据源",slug:"单一数据源",children:[]},{level:2,title:"松耦合，及时模块化",slug:"松耦合-及时模块化",children:[]},{level:2,title:"辅助代码分离",slug:"辅助代码分离",children:[]},{level:2,title:"SOLID 原则",slug:"solid-原则",children:[]}],content:"\n本文主要探讨在应用开发过程中，页面组件的开发原则。这里说的页面组件，是一个泛指，不仅仅表示一般的组件含义，也可以理解为页面的区块等。\n\n## 清晰的组件结构\n\n清晰的组件结构这条原则，更像是一种开发方法。\n\n在页面开发之初，我们就应该先将页面的结构确定，类似于[线框图](https://baike.baidu.com/item/%E7%BA%BF%E6%A1%86%E5%9B%BE)，并通过代码的方式确定下来。\n\n![IMAGE](/posts/images/component-dev-principles/wireframe-c.jpeg)\n\n上面是一个简单的商品列表页的线框图，顶部是一个过滤表单，下面是表格。那我们就需要在确定两个大的组件，表格和过滤表单。\n\n划分好页面区块以后，我们使用同样的方法，在区块内划分小的区块，直至最终的组件。\n\n比如上面的例子，确定好区块以后的代码结构应该是这样的：\n\n```\n-- list-page\n  -- index.tsx\n  -- filter-form.tsx\n  -- goods-list.tsx\n```\n\n> 在 `index.tsx` 中将页面区块组装成页面。\n\n通过这种方法，我们可以快速的理清组件之间的关系，为页面状态数据设计提供一些帮助。同时，组件设计落到代码目录结构中以后，我们可以通过代码目录反推页面结构，清晰明了。\n\n通常，我们一般习惯将所有组件都一股脑儿放到一个 `components` 目录中。这种做法太过粗放，组件多了以后，非常混乱，无法知道每个组件的具体用途，也不知道组件在哪个地方使用。\n\n通过上面的方法，我们把组件放到页面代码目录中，只将通用的，没有业务含义的组件放到顶层 `components` 目录中。模块目录内，我们同样按照功能和用途划分目录。这样的话，顶层的 `components` 更具有公共组件的含义，同时，每个模块的代码是内聚的，我们可以方便的了解这个模块的全部功能。\n\n## 单一数据源\n\n单一数据源，更具体一点的说法是，凡是可以由某一个数据推导出来的数据，都应该通过推导的方式来获取，不应该另行存储。数据应该是成链路的，而且只能有一个源头。\n\n在 React 技术栈中，单一数据源已经是基本常识了，但是很多同学受 Redux 的影响，仅仅将其理解为将应用所有数据状态都放在顶层的 state 中，通过 action 来触发状态更新。\n\n其实不然，单一数据源有着更广泛的含义。对于组件的外部数据，组件内不应再进行存储，而是始终使用外部传递进来的数据。对于组件自身数据，如果数据之间有依赖关系，那么依赖方就尽量由被依赖方推导出来。比如数据 B 依赖数据 A，那么数据 B 应该由数据 A 推导出来，而不是更新完数据 A 后再更新数据 B。\n\n为什么要坚持单一数据源呢？\n\n使用过 Angular 的同学应该都有这样的体验，当项目规模越来越大，应用数据之间依赖关系越来越复杂。一个数据更新会触发其他数据更新，反方向的数据更新也同样存在。这样的话，当出现问题的时候，就很难快速的找到问题出在什么地方，往往有一种按下葫芦起了瓢的感觉。比如下面的状态图，很难第一时间定位到哪个数据更新导致了 data1 的更新。\n\n```plantuml\n[*] --\x3e data1\ndata1 --\x3e data2\ndata2 --\x3e data1\ndata2 --\x3e data3\ndata3 --\x3e data4\ndata4 --\x3e data2\n```\n\n如果是单一数据源，那么状态变化就非常清晰。\n\n```plantuml\n[*] --\x3e data1\ndata1 --\x3e data2\ndata2 --\x3e data3\ndata3 --\x3e data4\ndata5 --\x3e data4\n```\n\n## 松耦合，及时模块化\n\n组件之间的交互方式应该是清晰明确的，应该避免你中有我，我中有你的情况。\n\n举个例子加以说明。假如我们有如下交互：\n![商品加购](/posts/images/component-dev-principles/low-coupling-c.png)\n\n左侧是商品加购表单信息，表单中间是商品列表。点击添加商品按钮，弹出右侧商品信息选择框，点击确定将商品信息添加到表单中。\n\n在这个交互中，我们的商品信息表单其实是左边表单的子表单。但是，我们不建议在商品信息表单中直接操作左边表单的数据。因为商品信息表单是一个相对独立的模块，它不依赖左侧表单的任何信息。因此，我们只需要给商品信息表单约定一个 `value` 和 `onChange` 的接口与左侧表单实现交互即可。商品信息表单内的任何信息变化，都不会直接触发左侧表单信息的变化，而是通过用户点击确定按钮来触发。\n\n## 辅助代码分离\n\n在组件中，我们通常会有一些计算或者数据转换逻辑。这虽然是组件功能的必要组成部分，但是这样的代码通常会比较长，放在组件逻辑里会打断整体代码的思路。因此，我们需要将这些辅助代码抽取出来，放到相关的 `utils` 中去。保证主体代码的思路是连贯的。\n\n## SOLID 原则\n\n[SOLID 原则](./solid.md) 是面向对象设计的基本原则，由单一职责原则、开闭原则、里氏替换原则、接口分离原则和依赖倒置原则组成。\n\n在组件开发过程中，我们也应该要借鉴这些原则，来进行组件设计。\n",contentRendered:'<p>本文主要探讨在应用开发过程中，页面组件的开发原则。这里说的页面组件，是一个泛指，不仅仅表示一般的组件含义，也可以理解为页面的区块等。</p>\n<h2 id="清晰的组件结构" tabindex="-1"><a class="header-anchor" href="#清晰的组件结构" aria-hidden="true">#</a> 清晰的组件结构</h2>\n<p>清晰的组件结构这条原则，更像是一种开发方法。</p>\n<p>在页面开发之初，我们就应该先将页面的结构确定，类似于<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%A1%86%E5%9B%BE" target="_blank" rel="noopener noreferrer">线框图<OutboundLink/></a>，并通过代码的方式确定下来。</p>\n<p><img src="/posts/images/component-dev-principles/wireframe-c.jpeg" alt="IMAGE"></p>\n<p>上面是一个简单的商品列表页的线框图，顶部是一个过滤表单，下面是表格。那我们就需要在确定两个大的组件，表格和过滤表单。</p>\n<p>划分好页面区块以后，我们使用同样的方法，在区块内划分小的区块，直至最终的组件。</p>\n<p>比如上面的例子，确定好区块以后的代码结构应该是这样的：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>-- list-page\n  -- index.tsx\n  -- filter-form.tsx\n  -- goods-list.tsx\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote>\n<p>在 <code>index.tsx</code> 中将页面区块组装成页面。</p>\n</blockquote>\n<p>通过这种方法，我们可以快速的理清组件之间的关系，为页面状态数据设计提供一些帮助。同时，组件设计落到代码目录结构中以后，我们可以通过代码目录反推页面结构，清晰明了。</p>\n<p>通常，我们一般习惯将所有组件都一股脑儿放到一个 <code>components</code> 目录中。这种做法太过粗放，组件多了以后，非常混乱，无法知道每个组件的具体用途，也不知道组件在哪个地方使用。</p>\n<p>通过上面的方法，我们把组件放到页面代码目录中，只将通用的，没有业务含义的组件放到顶层 <code>components</code> 目录中。模块目录内，我们同样按照功能和用途划分目录。这样的话，顶层的 <code>components</code> 更具有公共组件的含义，同时，每个模块的代码是内聚的，我们可以方便的了解这个模块的全部功能。</p>\n<h2 id="单一数据源" tabindex="-1"><a class="header-anchor" href="#单一数据源" aria-hidden="true">#</a> 单一数据源</h2>\n<p>单一数据源，更具体一点的说法是，凡是可以由某一个数据推导出来的数据，都应该通过推导的方式来获取，不应该另行存储。数据应该是成链路的，而且只能有一个源头。</p>\n<p>在 React 技术栈中，单一数据源已经是基本常识了，但是很多同学受 Redux 的影响，仅仅将其理解为将应用所有数据状态都放在顶层的 state 中，通过 action 来触发状态更新。</p>\n<p>其实不然，单一数据源有着更广泛的含义。对于组件的外部数据，组件内不应再进行存储，而是始终使用外部传递进来的数据。对于组件自身数据，如果数据之间有依赖关系，那么依赖方就尽量由被依赖方推导出来。比如数据 B 依赖数据 A，那么数据 B 应该由数据 A 推导出来，而不是更新完数据 A 后再更新数据 B。</p>\n<p>为什么要坚持单一数据源呢？</p>\n<p>使用过 Angular 的同学应该都有这样的体验，当项目规模越来越大，应用数据之间依赖关系越来越复杂。一个数据更新会触发其他数据更新，反方向的数据更新也同样存在。这样的话，当出现问题的时候，就很难快速的找到问题出在什么地方，往往有一种按下葫芦起了瓢的感觉。比如下面的状态图，很难第一时间定位到哪个数据更新导致了 data1 的更新。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuOhMYbNGrRLJI4aiIJJa0fDmlX6ORuGcZ-0RW_d6SBu9c6-2fDyXDIy5Q0i0" alt="uml diagram">\n<p>如果是单一数据源，那么状态变化就非常清晰。</p>\n<img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuOhMYbNGrRLJI4aiIJJa0fDmlX6ORmJd6uFvnd2-2PXlYiHtICrB0PeA0000" alt="uml diagram">\n<h2 id="松耦合-及时模块化" tabindex="-1"><a class="header-anchor" href="#松耦合-及时模块化" aria-hidden="true">#</a> 松耦合，及时模块化</h2>\n<p>组件之间的交互方式应该是清晰明确的，应该避免你中有我，我中有你的情况。</p>\n<p>举个例子加以说明。假如我们有如下交互：\n<img src="/posts/images/component-dev-principles/low-coupling-c.png" alt="商品加购"></p>\n<p>左侧是商品加购表单信息，表单中间是商品列表。点击添加商品按钮，弹出右侧商品信息选择框，点击确定将商品信息添加到表单中。</p>\n<p>在这个交互中，我们的商品信息表单其实是左边表单的子表单。但是，我们不建议在商品信息表单中直接操作左边表单的数据。因为商品信息表单是一个相对独立的模块，它不依赖左侧表单的任何信息。因此，我们只需要给商品信息表单约定一个 <code>value</code> 和 <code>onChange</code> 的接口与左侧表单实现交互即可。商品信息表单内的任何信息变化，都不会直接触发左侧表单信息的变化，而是通过用户点击确定按钮来触发。</p>\n<h2 id="辅助代码分离" tabindex="-1"><a class="header-anchor" href="#辅助代码分离" aria-hidden="true">#</a> 辅助代码分离</h2>\n<p>在组件中，我们通常会有一些计算或者数据转换逻辑。这虽然是组件功能的必要组成部分，但是这样的代码通常会比较长，放在组件逻辑里会打断整体代码的思路。因此，我们需要将这些辅助代码抽取出来，放到相关的 <code>utils</code> 中去。保证主体代码的思路是连贯的。</p>\n<h2 id="solid-原则" tabindex="-1"><a class="header-anchor" href="#solid-原则" aria-hidden="true">#</a> SOLID 原则</h2>\n<p><RouterLink to="/posts/solid.html">SOLID 原则</RouterLink> 是面向对象设计的基本原则，由单一职责原则、开闭原则、里氏替换原则、接口分离原则和依赖倒置原则组成。</p>\n<p>在组件开发过程中，我们也应该要借鉴这些原则，来进行组件设计。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-07-03",deps:[],hoistedTags:[],links:[{raw:"./solid.md",relative:"posts/solid.md",absolute:"/posts/solid.md"}],pathInferred:"/posts/component-dev-principles.html",pathLocale:"/",permalink:"/posts/2021/07/03/component-dev-principles.html",slug:"component-dev-principles",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/component-dev-principles.md",filePathRelative:"posts/component-dev-principles.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/03/component-dev-principles.html.vue",componentFilePathRelative:"pages/posts/2021/07/03/component-dev-principles.html.vue",componentFileChunkName:"v-7c282419",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/03/component-dev-principles.html.js",dataFilePathRelative:"pages/posts/2021/07/03/component-dev-principles.html.js",dataFileChunkName:"v-7c282419",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/07/03/component-dev-principles.html",htmlFilePathRelative:"posts/2021/07/03/component-dev-principles.html"},{key:"v-01554e16",path:"/posts/2018/03/27/css-grid.html",title:"CSS Grid 布局完全指南",lang:"zh-CN",frontmatter:{title:"CSS Grid 布局完全指南",description:"CSS Grid 布局完全指南",keywords:["css layout","css 布局","grid"],date:"2018-03-27T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"基本概念",slug:"基本概念",children:[]},{level:2,title:"网格容器相关属性",slug:"网格容器相关属性",children:[{level:3,title:"display",slug:"display",children:[]},{level:3,title:"grid-template-rows 和 grid-template-columns",slug:"grid-template-rows-和-grid-template-columns",children:[]},{level:3,title:"grid-template-areas",slug:"grid-template-areas",children:[]},{level:3,title:"grid-template",slug:"grid-template",children:[]},{level:3,title:"grid-row-gap 和 grid-column-gap",slug:"grid-row-gap-和-grid-column-gap",children:[]},{level:3,title:"grid-gap",slug:"grid-gap",children:[]},{level:3,title:"justify-items",slug:"justify-items",children:[]},{level:3,title:"align-items",slug:"align-items",children:[]},{level:3,title:"justify-content",slug:"justify-content",children:[]},{level:3,title:"align-content",slug:"align-content",children:[]},{level:3,title:"grid-auto-rows 和 grid-auto-columns",slug:"grid-auto-rows-和-grid-auto-columns",children:[]},{level:3,title:"grid-auto-flow",slug:"grid-auto-flow",children:[]},{level:3,title:"grid",slug:"grid",children:[]}]},{level:2,title:"网格元素相关属性",slug:"网格元素相关属性",children:[{level:3,title:"grid-row-start、grid-row-end、grid-column-start、grid-column-end",slug:"grid-row-start、grid-row-end、grid-column-start、grid-column-end",children:[]},{level:3,title:"grid-row 和 grid-column",slug:"grid-row-和-grid-column",children:[]},{level:3,title:"grid-area",slug:"grid-area",children:[]},{level:3,title:"justify-self",slug:"justify-self",children:[]},{level:3,title:"align-self",slug:"align-self",children:[]}]},{level:2,title:"参考链接",slug:"参考链接",children:[]}],content:'\nCSS Grid Layout（下称网格布局）是目前 css 可支持的最强大的布局系统。在 web 开发早期，开发者通常通过表格、浮动和定位等方式来对网页进行布局，严格意义上来说，这些方法都是以 hack 的方式来完成的，而且遗留了很多无法解决的问题，比如垂直居中。随着 Flexbox 逐步得到支持，网页布局工作得到了明显的改善。但是，Flexbox 也有明显的缺点，就是它只能完成一维布局，即只能完成行或者列的布局，当页面涉及到二维布局时，开发者往往需要使用多个 Flexbox 来完成。网格布局是一个二维布局系统，它可以很好的解决 Flexbox 无法解决的问题。\n\n## 基本概念\n\n在深入介绍网格布局的使用方法之前，先来了解一些必要的概念。\n\n- 网格容器（Grid Container）：网格布局的顶层容器。\n- 网格元素（Grid Item）：网格布局中的元素，注意，网格元素是网格容器的直接后代元素。\n- 网格线（Grid Line）：网格系统中区分行列的线。\n- 网格轨迹（Grid Track）：两个相邻网格线之间的区域。\n- 网格单元（Grid Cell）：两个相邻行线和两个相邻列线框定的区域。\n- 网格区域（Grid Area）：四个网格线（两行两列）之间的区域。一个网格区域可包含多个网格单元。\n\n## 网格容器相关属性\n\n### display\n\n该属性定义一个网格容器，并建立一个网格格式化上下文（grid formatting context）。该属性取值如下：\n\n- grid 建立一个块级网格\n- inline-grid 建立一个行内网格\n- subgrid 当网格容器本身是一个网格元素（网格嵌套）时使用，并指定使用其父元素的网格轨迹来布局。\n\n```css\n.container {\n  display: grid | inline-grid | subgrid;\n}\n```\n\n> 注意，column、float、clear 和 vertical-align 对网格容器无影响。\n\n### grid-template-rows 和 grid-template-columns\n\n这两个属性定义网格的行和列，取值为一个由空格分割的值列表。值表示轨迹（track）的大小，空格表示网格线。取值如下：\n\n- < track-size > 具体的长度、百分比或者是通过 fr 单位表示的对空白空间的占比\n- < line-name > 任意指定的线名称，线名称用中括号包裹，如 [line-1]\n\n```css\n.container {\n  grid-template-columns: <track-size> ... | <line-name> <track-size> ...;\n  grid-template-rows: <track-size> ... | <line-name> <track-size> ...;\n}\n```\n\n当未指定网格线名称时，线名称按序号自动确定，如：\n\n```css\n.container {\n  grid-template-columns: 40px 50px auto 50px 40px;\n  grid-template-rows: 25% 100px auto;\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-line-name-c.jpg)\n也可以指定网格线的名称，如：\n\n```css\n.container {\n  grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];\n  grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-line-name-2-c.jpg)\n一条网格线可以有多个名字，如：\n\n```css\n.container {\n  grid-template-rows: [row1-start] 25% [row1-end row2-start] 25% [row2-end];\n}\n```\n\n第二条线有两个名字，row1-end 和 row2-start。\n如果定义中存在多个重复的情况，可以通过如下方式快速完成：\n\n```css\n.container {\n  grid-template-columns: repeat(3, 20px [col-start]) 5%;\n}\n```\n\n等同于：\n\n```css\n.container {\n  grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;\n}\n```\n\n下面这个例子，等同于每个元素占用 1/3 容器的宽度。\n\n```css\n.container {\n  grid-template-columns: 1fr 1fr 1fr;\n}\n```\n\n`fr` 的计算是除去容器中无法伸缩的元素占用的空间以后的空白空间。比如：\n\n```css\n.container {\n  grid-template-columns: 1fr 50px 1fr 1fr;\n}\n```\n\n### grid-template-areas\n\n该属性定义网格布局的模板，通过使用网格元素中 `grid-area` 属性定义的名字，定义网格布局的结构。两个重复的 `grid-area` 会合并成一个占两倍空间的 `grid-area`。取值如下：\n\n- < grid-area-name > 网格元素中通过 `grid-area` 属性指定的名字\n- . 点号表示一个空的网格单元\n- none 没有定义网格区域\n\n```css\n.container {\n  grid-template-areas:\n    "<grid-area-name> | . | none | ..."\n    "...";\n}\n```\n\n比如：\n\n```css\n.item-a {\n  grid-area: header;\n}\n.item-b {\n  grid-area: main;\n}\n.item-c {\n  grid-area: sidebar;\n}\n.item-d {\n  grid-area: footer;\n}\n.container {\n  grid-template-columns: 50px 50px 50px 50px;\n  grid-template-rows: auto;\n  grid-template-areas:\n    "header header header header"\n    "main main . sidebar"\n    "footer footer footer footer";\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-template-areas-c.jpg)\n\n> 申明中的每一行需要保证有相同的网格单元数量。网格区域的开始和结束网格线根据网格区域自动生成，如网格区域名为 foo，则开始和结束网格线为 foo-start 和 foo-end。\n\n### grid-template\n\n该属性为 grid-template-rows, grid-template-columns, 和 grid-template-areas 的快捷写法。取值为：\n\n- none 设置三个属性值为初始值。\n- subgrid 设置 grid-template-rows 和 grid-template-columns 为 subgrid，设置 grid-template-areas 为初始值。\n- < grid-template-rows > / < grid-template-columns > 设置 grid-template-rows 和 grid-template-columns 为指定值，设置 grid-template-areas 为 none。\n\n```css\n.container {\n  grid-template: none | subgrid | <grid-template-rows> / <grid-template-columns>;\n}\n```\n\n还有一种同时设置三种属性的写法：\n\n```css\n.container {\n  grid-template:\n    [row1-start] "header header header" 25px [row1-end]\n    [row2-start] "footer footer footer" 25px [row2-end]\n    / auto 50px auto;\n}\n```\n\n等同于\n\n```css\n.container {\n  grid-template-rows: [row1-start] 25px [row1-end row2-start] 25px [row2-end];\n  grid-template-columns: auto 50px auto;\n  grid-template-areas:\n    "header header header"\n    "footer footer footer";\n}\n```\n\n### grid-row-gap 和 grid-column-gap\n\n这两个属性指定网格线的大小，即网格行与行、列与列之间间隔的宽度。取值如下：\n\n- < line-size > 具体的长度。\n\n比如：\n\n```css\n.container {\n  grid-template-columns: 100px 50px 100px;\n  grid-template-rows: 80px auto 80px;\n  grid-column-gap: 10px;\n  grid-row-gap: 15px;\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-gap-c.jpg)\n\n### grid-gap\n\n该属性为 grid-row-gap 和 grid-column-gap 的快捷写法。取值：\n\n- < grid-row-gap > < grid-column-gap > 具体的长度。\n\n```css\n.container {\n  grid-gap: <grid-row-gap> <grid-column-gap>;\n}\n```\n\n比如：\n\n```css\n.container {\n  grid-template-columns: 100px 50px 100px;\n  grid-template-rows: 80px auto 80px;\n  grid-gap: 10px 15px;\n}\n```\n\n### justify-items\n\n网格元素沿行方向的对其方式。类似于 Flexbox。取值为：\n\n- start 左对齐\n- end 右对齐\n- center 居中对齐\n- stretch 拉伸对齐，默认值\n\n```css\n.container {\n  justify-items: start | end | center | stretch;\n}\n```\n\n如：\n\n```css\n.container {\n  justify-items: start;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-items-start-c.jpg)\n\n```css\n.container {\n  justify-items: end;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-items-end-c.jpg)\n\n```css\n.container {\n  justify-items: center;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-items-center-c.jpg)\n\n```css\n.container {\n  justify-items: stretch;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-items-stretch-c.jpg)\n\n### align-items\n\n网格元素沿列方向的对其方式。类似于 Flexbox。取值为：\n\n- start 上对齐\n- end 下对齐\n- center 居中对齐\n- stretch 拉伸对齐，默认值\n\n```css\n.container {\n  align-items: start | end | center | stretch;\n}\n```\n\n如：\n\n```css\n.container {\n  align-items: start;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-items-start-c.jpg)\n\n```css\n.container {\n  align-items: end;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-items-end-c.jpg)\n\n```css\n.container {\n  align-items: center;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-items-center-c.jpg)\n\n```css\n.container {\n  align-items: stretch;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-items-stretch-c.jpg)\n\n### justify-content\n\n该属性用于当所有网格元素的总尺寸小于网格容器的尺寸时的沿行方向的对齐方式。取值：\n\n- start 网格容器的最左端\n- end 网格容器的最右端\n- center 网格容器的中央\n- stretch 拉伸填满网格容器\n- space-around 网格元素间的间距相等，网格元素与网格容器两端的间距为元素间间距的一半。\n- space-between 网格元素间的间距相等，网格元素与网格容器两端的间距为零。\n- space-evenly 所有间距相等。\n\n```css\n.container {\n  justify-content: start | end | center | stretch | space-around | space-between\n    | space-evenly;\n}\n```\n\n如：\n\n```css\n.container {\n  justify-content: start;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-content-start-c.jpg)\n\n```css\n.container {\n  justify-content: end;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-content-end-c.jpg)\n\n```css\n.container {\n  justify-content: center;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-content-center-c.jpg)\n\n```css\n.container {\n  justify-content: stretch;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-content-stretch-c.jpg)\n\n```css\n.container {\n  justify-content: space-around;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-content-space-around-c.jpg)\n\n```css\n.container {\n  justify-content: space-between;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-content-space-between-c.jpg)\n\n```css\n.container {\n  justify-content: space-evenly;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-content-space-evenly-c.jpg)\n\n### align-content\n\n该属性用于当所有网格元素的总尺寸小于网格容器的尺寸时的沿列方向的对齐方式。取值：\n\n- start 网格容器的最上端\n- end 网格容器的最下端\n- center 网格容器的中央\n- stretch 拉伸填满网格容器\n- space-around 网格元素间的间距相等，网格元素与网格容器两端的间距为元素间间距的一半。\n- space-between 网格元素间的间距相等，网格元素与网格容器两端的间距为零。\n- space-evenly 所有间距相等。\n\n```css\n.container {\n  align-content: start | end | center | stretch | space-around | space-between |\n    space-evenly;\n}\n```\n\n如：\n\n```css\n.container {\n  align-content: start;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-content-start-c.jpg)\n\n```css\n.container {\n  align-content: end;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-content-end-c.jpg)\n\n```css\n.container {\n  align-content: center;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-content-center-c.jpg)\n\n```css\n.container {\n  align-content: stretch;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-content-stretch-c.jpg)\n\n```css\n.container {\n  align-content: space-around;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-content-space-around-c.jpg)\n\n```css\n.container {\n  align-content: space-between;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-content-space-between-c.jpg)\n\n```css\n.container {\n  align-content: space-evenly;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-content-space-evenly-c.jpg)\n\n### grid-auto-rows 和 grid-auto-columns\n\n这两个属性设置自动生成的网格轨迹（隐式网格轨迹）的大小。通常当我们设置的行和列超过定义的网格时，会产生隐式网格轨迹。\n\n- < track-size > 确定长度、百分比或者是通过 fr 单位表示的对空白空间的占比\n\n```css\n.container {\n  grid-auto-columns: <track-size>...;\n  grid-auto-rows: <track-size>...;\n}\n```\n\n比如：\n\n```css\n.container {\n  grid-template-columns: 60px 60px;\n  grid-template-rows: 90px 90px;\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-auto-rows-columns-demo-c.jpg)\n此时设置：\n\n```css\n.item-a {\n  grid-column: 1 / 2;\n  grid-row: 2 / 3;\n}\n.item-b {\n  grid-column: 5 / 6;\n  grid-row: 2 / 3;\n}\n```\n\n> grid-column 和 grid-row 的定义参考下文。\n\n![IMAGE](/posts/images/css-grid/grid-auto-rows-columns-demo-2-c.jpg)\n\n因为我们定义的行和列超出了网格容器定义的网格，此时会生成宽度为零的网格轨迹。对网格容器添加如下样式：\n\n```css\n.container {\n  grid-auto-columns: 60px;\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-auto-rows-columns-demo-3-c.jpg)\n\n### grid-auto-flow\n\n当网格元素未指定排列方式时，网格容器默认的自动排列方式。取值：\n\n- row 自动沿行排列，必要情况下会添加新行\n- column 自动沿列排列，必要情况下会添加新列\n- dense 尽可能的填补之前布局的空白，可能会导致元素顺序发生改变\n\n```css\n.container {\n  grid-auto-flow: row | column | row dense | column dense;\n}\n```\n\n如，有如下代码：\n\n```html\n<section class="container">\n  <div class="item-a">item-a</div>\n  <div class="item-b">item-b</div>\n  <div class="item-c">item-c</div>\n  <div class="item-d">item-d</div>\n  <div class="item-e">item-e</div>\n</section>\n```\n\n样式定义如下：\n\n```css\n.container {\n  display: grid;\n  grid-template-columns: 60px 60px 60px 60px 60px;\n  grid-template-rows: 30px 30px;\n  grid-auto-flow: row;\n}\n.item-a {\n  grid-column: 1;\n  grid-row: 1 / 3;\n}\n.item-e {\n  grid-column: 5;\n  grid-row: 1 / 3;\n}\n```\n\n未设置排列方式的元素排列如下：\n\n![IMAGE](/posts/images/css-grid/grid-auto-flow-demo-c.jpg)\n\n修改容器样式：\n\n```css\n.container {\n  display: grid;\n  grid-template-columns: 60px 60px 60px 60px 60px;\n  grid-template-rows: 30px 30px;\n  grid-auto-flow: column;\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-auto-flow-demo-2-c.jpg)\n\n### grid\n\ngrid-template-rows, grid-template-columns, grid-template-areas, grid-auto-rows, grid-auto-columns, 和 grid-auto-flow 属性的快捷写法，同时设置 grid-column-gap 和 grid-row-gap 为他们的初始值。取值：\n\n- none 设置所有属性为初始值。\n- < grid-template-rows > / < grid-template-columns > 设置 grid-template-rows 和 grid-template-columns 为指定值，其他属性为初始值。\n- < grid-auto-flow > [< grid-auto-rows > [/ < grid-auto-columns >]] 设置 grid-auto-flow, grid-auto-rows 和 grid-auto-columns 的值，如果 grid-auto-columns 省略，则使用 grid-auto-rows，如果两个都省略，则使用初始值。\n\n```css\n.container {\n  grid: none | < grid-template-rows > / < grid-template-columns > | < grid-auto-flow > [< grid-auto-rows > [/ < grid-auto-columns >]];\n}\n```\n\n如：\n\n```css\n.container {\n  grid: 200px auto / 1fr auto 1fr;\n}\n```\n\n等同于\n\n```css\n.container {\n  grid-template-rows: 200px auto;\n  grid-template-columns: 1fr auto 1fr;\n  grid-template-areas: none;\n}\n```\n\n```css\n.container {\n  grid: column 1fr / auto;\n}\n```\n\n等同于\n\n```css\n.container {\n  grid-auto-flow: column;\n  grid-auto-rows: 1fr;\n  grid-auto-columns: auto;\n}\n```\n\n还有一种快捷写法为：\n\n```css\n.container {\n  grid:\n    [row1-start] "header header header" 1fr [row1-end]\n    [row2-start] "footer footer footer" 25px [row2-end]\n    / auto 50px auto;\n}\n```\n\n等同于：\n\n```css\n.container {\n  grid-template-areas:\n    "header header header"\n    "footer footer footer";\n  grid-template-rows: [row1-start] 1fr [row1-end row2-start] 25px [row2-end];\n  grid-template-columns: auto 50px auto;\n}\n```\n\n## 网格元素相关属性\n\n### grid-row-start、grid-row-end、grid-column-start、grid-column-end\n\n这四个属性指定网格元素在网格中的具体位置。grid-column-start/grid-row-start 指定开始位置, grid-column-end/grid-row-end 指定结束位置。取值：\n\n- < line > 具体的网格线，可以是数字或者网格线名称\n- span < number > 跨越指定数量的网格轨迹\n- span < name > 跨越区域直到遇到指定名称的网格线\n- auto 自动排列\n\n```css\n.item {\n  grid-column-start: <number> | <name> | span <number> | span <name> | auto\n  grid-column-end: <number> | <name> | span <number> | span <name> | auto\n  grid-row-start: <number> | <name> | span <number> | span <name> | auto\n  grid-row-end: <number> | <name> | span <number> | span <name> | auto\n}\n```\n\n如：\n\n```css\n.item-a {\n  grid-column-start: 2;\n  grid-column-end: five;\n  grid-row-start: row1-start;\n  grid-row-end: 3;\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-row-column-start-end-demo-c.jpg)\n\n```css\n.item-b {\n  grid-column-start: 1;\n  grid-column-end: span col4-start;\n  grid-row-start: 2;\n  grid-row-end: span 2;\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-row-column-start-end-demo-2-c.jpg)\n\n> 如果 grid-column-end 和 grid-row-end 未指定，默认跨越一个网格轨迹。网格元素允许重叠，可以通过 z-index 控制。\n\n### grid-row 和 grid-column\n\ngrid-row-start + grid-row-end 和 grid-column-start + grid-column-end 的快捷写法。取值：\n\n- < start-line > / < end-line > 取值与非快捷写法的取值相同。\n\n```css\n.item {\n  grid-column: <start-line> / <end-line> | <start-line> / span <value>;\n  grid-row: <start-line> / <end-line> | <start-line> / span <value>;\n}\n```\n\n如：\n\n```css\n.item-c {\n  grid-column: 3 / span 2;\n  grid-row: third-line / 4;\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-row-column-c.jpg)\n\n### grid-area\n\n该属性指定网格元素的名字，这样网格元素就可以被 `grid-template-areas` 引用。同时，该属性也可以被用作 grid-row-start + grid-column-start + grid-row-end + grid-column-end 的更加快捷的写法。取值：\n\n- < name > 名称，可被 `grid-template-areas` 引用。\n- < row-start> / < column-start> / < row-end> / < column-end> 数字或者网格线的名字\n\n```css\n.item {\n  grid-area: <name> | <row-start> / <column-start> / <row-end> / <column-end>;\n}\n```\n\n如：\n\n```css\n.item-d {\n  grid-area: 1 / col4-start / last-line / 6;\n}\n```\n\n![IMAGE](/posts/images/css-grid/grid-area-c.jpg)\n\n### justify-self\n\n该属性指定网格元素沿行方向的对齐方式。取值：\n\n- start 左对齐\n- end 右对齐\n- center 居中对齐\n- stretch 拉伸，默认值\n\n```css\n.item {\n  justify-self: start | end | center | stretch;\n}\n```\n\n如：\n\n```css\n.item-a {\n  justify-self: start;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-self-start-c.jpg)\n\n```css\n.item-a {\n  justify-self: end;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-self-end-c.jpg)\n\n```css\n.item-a {\n  justify-self: center;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-self-center-c.jpg)\n\n```css\n.item-a {\n  justify-self: stretch;\n}\n```\n\n![IMAGE](/posts/images/css-grid/justify-self-stretch-c.jpg)\n\n### align-self\n\n该属性指定网格元素沿列方向的对齐方式。取值：\n\n- start 上对齐\n- end 下对齐\n- center 居中对齐\n- stretch 拉伸，默认值\n\n```css\n.item {\n  align-self: start | end | center | stretch;\n}\n```\n\n如：\n\n```css\n.item-a {\n  align-self: start;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-self-start-c.jpg)\n\n```css\n.item-a {\n  align-self: end;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-self-start-c.jpg)\n\n```css\n.item-a {\n  align-self: center;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-self-start-c.jpg)\n\n```css\n.item-a {\n  align-self: stretch;\n}\n```\n\n![IMAGE](/posts/images/css-grid/align-self-start-c.jpg)\n\n## 参考链接\n\n- [A Complete Guide to Grid](https://css-tricks.com/snippets/css/complete-guide-grid/)\n',contentRendered:'<p>CSS Grid Layout（下称网格布局）是目前 css 可支持的最强大的布局系统。在 web 开发早期，开发者通常通过表格、浮动和定位等方式来对网页进行布局，严格意义上来说，这些方法都是以 hack 的方式来完成的，而且遗留了很多无法解决的问题，比如垂直居中。随着 Flexbox 逐步得到支持，网页布局工作得到了明显的改善。但是，Flexbox 也有明显的缺点，就是它只能完成一维布局，即只能完成行或者列的布局，当页面涉及到二维布局时，开发者往往需要使用多个 Flexbox 来完成。网格布局是一个二维布局系统，它可以很好的解决 Flexbox 无法解决的问题。</p>\n<h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h2>\n<p>在深入介绍网格布局的使用方法之前，先来了解一些必要的概念。</p>\n<ul>\n<li>网格容器（Grid Container）：网格布局的顶层容器。</li>\n<li>网格元素（Grid Item）：网格布局中的元素，注意，网格元素是网格容器的直接后代元素。</li>\n<li>网格线（Grid Line）：网格系统中区分行列的线。</li>\n<li>网格轨迹（Grid Track）：两个相邻网格线之间的区域。</li>\n<li>网格单元（Grid Cell）：两个相邻行线和两个相邻列线框定的区域。</li>\n<li>网格区域（Grid Area）：四个网格线（两行两列）之间的区域。一个网格区域可包含多个网格单元。</li>\n</ul>\n<h2 id="网格容器相关属性" tabindex="-1"><a class="header-anchor" href="#网格容器相关属性" aria-hidden="true">#</a> 网格容器相关属性</h2>\n<h3 id="display" tabindex="-1"><a class="header-anchor" href="#display" aria-hidden="true">#</a> display</h3>\n<p>该属性定义一个网格容器，并建立一个网格格式化上下文（grid formatting context）。该属性取值如下：</p>\n<ul>\n<li>grid 建立一个块级网格</li>\n<li>inline-grid 建立一个行内网格</li>\n<li>subgrid 当网格容器本身是一个网格元素（网格嵌套）时使用，并指定使用其父元素的网格轨迹来布局。</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> grid | inline-grid | subgrid<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote>\n<p>注意，column、float、clear 和 vertical-align 对网格容器无影响。</p>\n</blockquote>\n<h3 id="grid-template-rows-和-grid-template-columns" tabindex="-1"><a class="header-anchor" href="#grid-template-rows-和-grid-template-columns" aria-hidden="true">#</a> grid-template-rows 和 grid-template-columns</h3>\n<p>这两个属性定义网格的行和列，取值为一个由空格分割的值列表。值表示轨迹（track）的大小，空格表示网格线。取值如下：</p>\n<ul>\n<li>&lt; track-size &gt; 具体的长度、百分比或者是通过 fr 单位表示的对空白空间的占比</li>\n<li>&lt; line-name &gt; 任意指定的线名称，线名称用中括号包裹，如 [line-1]</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> &lt;track-size> ... | &lt;line-name> &lt;track-size> ...<span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> &lt;track-size> ... | &lt;line-name> &lt;track-size> ...<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当未指定网格线名称时，线名称按序号自动确定，如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 40px 50px auto 50px 40px<span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 25% 100px auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="/posts/images/css-grid/grid-line-name-c.jpg" alt="IMAGE">\n也可以指定网格线的名称，如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end]<span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> [row1-start] 25% [row1-end] 100px [third-line] auto [last-line]<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="/posts/images/css-grid/grid-line-name-2-c.jpg" alt="IMAGE">\n一条网格线可以有多个名字，如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> [row1-start] 25% [row1-end row2-start] 25% [row2-end]<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>第二条线有两个名字，row1-end 和 row2-start。\n如果定义中存在多个重复的情况，可以通过如下方式快速完成：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>3<span class="token punctuation">,</span> 20px [col-start]<span class="token punctuation">)</span> 5%<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>等同于：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 20px [col-start] 20px [col-start] 20px [col-start] 5%<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>下面这个例子，等同于每个元素占用 1/3 容器的宽度。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 1fr 1fr 1fr<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>fr</code> 的计算是除去容器中无法伸缩的元素占用的空间以后的空白空间。比如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 1fr 50px 1fr 1fr<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="grid-template-areas" tabindex="-1"><a class="header-anchor" href="#grid-template-areas" aria-hidden="true">#</a> grid-template-areas</h3>\n<p>该属性定义网格布局的模板，通过使用网格元素中 <code>grid-area</code> 属性定义的名字，定义网格布局的结构。两个重复的 <code>grid-area</code> 会合并成一个占两倍空间的 <code>grid-area</code>。取值如下：</p>\n<ul>\n<li>&lt; grid-area-name &gt; 网格元素中通过 <code>grid-area</code> 属性指定的名字</li>\n<li>. 点号表示一个空的网格单元</li>\n<li>none 没有定义网格区域</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-areas</span><span class="token punctuation">:</span>\n    <span class="token string">"&lt;grid-area-name> | . | none | ..."</span>\n    <span class="token string">"..."</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>比如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-area</span><span class="token punctuation">:</span> header<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item-b</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-area</span><span class="token punctuation">:</span> main<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item-c</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-area</span><span class="token punctuation">:</span> sidebar<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item-d</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-area</span><span class="token punctuation">:</span> footer<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 50px 50px 50px 50px<span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>\n  <span class="token property">grid-template-areas</span><span class="token punctuation">:</span>\n    <span class="token string">"header header header header"</span>\n    <span class="token string">"main main . sidebar"</span>\n    <span class="token string">"footer footer footer footer"</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><img src="/posts/images/css-grid/grid-template-areas-c.jpg" alt="IMAGE"></p>\n<blockquote>\n<p>申明中的每一行需要保证有相同的网格单元数量。网格区域的开始和结束网格线根据网格区域自动生成，如网格区域名为 foo，则开始和结束网格线为 foo-start 和 foo-end。</p>\n</blockquote>\n<h3 id="grid-template" tabindex="-1"><a class="header-anchor" href="#grid-template" aria-hidden="true">#</a> grid-template</h3>\n<p>该属性为 grid-template-rows, grid-template-columns, 和 grid-template-areas 的快捷写法。取值为：</p>\n<ul>\n<li>none 设置三个属性值为初始值。</li>\n<li>subgrid 设置 grid-template-rows 和 grid-template-columns 为 subgrid，设置 grid-template-areas 为初始值。</li>\n<li>&lt; grid-template-rows &gt; / &lt; grid-template-columns &gt; 设置 grid-template-rows 和 grid-template-columns 为指定值，设置 grid-template-areas 为 none。</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template</span><span class="token punctuation">:</span> none | subgrid | &lt;grid-template-rows> / &lt;grid-template-columns><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>还有一种同时设置三种属性的写法：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template</span><span class="token punctuation">:</span>\n    [row1-start] <span class="token string">"header header header"</span> 25px [row1-end]\n    [row2-start] <span class="token string">"footer footer footer"</span> 25px [row2-end]\n    / auto 50px auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>等同于</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> [row1-start] 25px [row1-end row2-start] 25px [row2-end]<span class="token punctuation">;</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> auto 50px auto<span class="token punctuation">;</span>\n  <span class="token property">grid-template-areas</span><span class="token punctuation">:</span>\n    <span class="token string">"header header header"</span>\n    <span class="token string">"footer footer footer"</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="grid-row-gap-和-grid-column-gap" tabindex="-1"><a class="header-anchor" href="#grid-row-gap-和-grid-column-gap" aria-hidden="true">#</a> grid-row-gap 和 grid-column-gap</h3>\n<p>这两个属性指定网格线的大小，即网格行与行、列与列之间间隔的宽度。取值如下：</p>\n<ul>\n<li>&lt; line-size &gt; 具体的长度。</li>\n</ul>\n<p>比如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 100px 50px 100px<span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 80px auto 80px<span class="token punctuation">;</span>\n  <span class="token property">grid-column-gap</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n  <span class="token property">grid-row-gap</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="/posts/images/css-grid/grid-gap-c.jpg" alt="IMAGE"></p>\n<h3 id="grid-gap" tabindex="-1"><a class="header-anchor" href="#grid-gap" aria-hidden="true">#</a> grid-gap</h3>\n<p>该属性为 grid-row-gap 和 grid-column-gap 的快捷写法。取值：</p>\n<ul>\n<li>&lt; grid-row-gap &gt; &lt; grid-column-gap &gt; 具体的长度。</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-gap</span><span class="token punctuation">:</span> &lt;grid-row-gap> &lt;grid-column-gap><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>比如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 100px 50px 100px<span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 80px auto 80px<span class="token punctuation">;</span>\n  <span class="token property">grid-gap</span><span class="token punctuation">:</span> 10px 15px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="justify-items" tabindex="-1"><a class="header-anchor" href="#justify-items" aria-hidden="true">#</a> justify-items</h3>\n<p>网格元素沿行方向的对其方式。类似于 Flexbox。取值为：</p>\n<ul>\n<li>start 左对齐</li>\n<li>end 右对齐</li>\n<li>center 居中对齐</li>\n<li>stretch 拉伸对齐，默认值</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-items</span><span class="token punctuation">:</span> start | end | center | stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-items</span><span class="token punctuation">:</span> start<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-items-start-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-items</span><span class="token punctuation">:</span> end<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-items-end-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-items-center-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-items</span><span class="token punctuation">:</span> stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-items-stretch-c.jpg" alt="IMAGE"></p>\n<h3 id="align-items" tabindex="-1"><a class="header-anchor" href="#align-items" aria-hidden="true">#</a> align-items</h3>\n<p>网格元素沿列方向的对其方式。类似于 Flexbox。取值为：</p>\n<ul>\n<li>start 上对齐</li>\n<li>end 下对齐</li>\n<li>center 居中对齐</li>\n<li>stretch 拉伸对齐，默认值</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-items</span><span class="token punctuation">:</span> start | end | center | stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-items</span><span class="token punctuation">:</span> start<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-items-start-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-items</span><span class="token punctuation">:</span> end<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-items-end-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-items-center-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-items</span><span class="token punctuation">:</span> stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-items-stretch-c.jpg" alt="IMAGE"></p>\n<h3 id="justify-content" tabindex="-1"><a class="header-anchor" href="#justify-content" aria-hidden="true">#</a> justify-content</h3>\n<p>该属性用于当所有网格元素的总尺寸小于网格容器的尺寸时的沿行方向的对齐方式。取值：</p>\n<ul>\n<li>start 网格容器的最左端</li>\n<li>end 网格容器的最右端</li>\n<li>center 网格容器的中央</li>\n<li>stretch 拉伸填满网格容器</li>\n<li>space-around 网格元素间的间距相等，网格元素与网格容器两端的间距为元素间间距的一半。</li>\n<li>space-between 网格元素间的间距相等，网格元素与网格容器两端的间距为零。</li>\n<li>space-evenly 所有间距相等。</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> start | end | center | stretch | space-around | space-between\n    | space-evenly<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> start<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-content-start-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> end<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-content-end-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-content-center-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-content-stretch-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> space-around<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-content-space-around-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> space-between<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-content-space-between-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> space-evenly<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-content-space-evenly-c.jpg" alt="IMAGE"></p>\n<h3 id="align-content" tabindex="-1"><a class="header-anchor" href="#align-content" aria-hidden="true">#</a> align-content</h3>\n<p>该属性用于当所有网格元素的总尺寸小于网格容器的尺寸时的沿列方向的对齐方式。取值：</p>\n<ul>\n<li>start 网格容器的最上端</li>\n<li>end 网格容器的最下端</li>\n<li>center 网格容器的中央</li>\n<li>stretch 拉伸填满网格容器</li>\n<li>space-around 网格元素间的间距相等，网格元素与网格容器两端的间距为元素间间距的一半。</li>\n<li>space-between 网格元素间的间距相等，网格元素与网格容器两端的间距为零。</li>\n<li>space-evenly 所有间距相等。</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> start | end | center | stretch | space-around | space-between |\n    space-evenly<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> start<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-content-start-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> end<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-content-end-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-content-center-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-content-stretch-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> space-around<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-content-space-around-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> space-between<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-content-space-between-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> space-evenly<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-content-space-evenly-c.jpg" alt="IMAGE"></p>\n<h3 id="grid-auto-rows-和-grid-auto-columns" tabindex="-1"><a class="header-anchor" href="#grid-auto-rows-和-grid-auto-columns" aria-hidden="true">#</a> grid-auto-rows 和 grid-auto-columns</h3>\n<p>这两个属性设置自动生成的网格轨迹（隐式网格轨迹）的大小。通常当我们设置的行和列超过定义的网格时，会产生隐式网格轨迹。</p>\n<ul>\n<li>&lt; track-size &gt; 确定长度、百分比或者是通过 fr 单位表示的对空白空间的占比</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-auto-columns</span><span class="token punctuation">:</span> &lt;track-size>...<span class="token punctuation">;</span>\n  <span class="token property">grid-auto-rows</span><span class="token punctuation">:</span> &lt;track-size>...<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>比如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 60px 60px<span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 90px 90px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="/posts/images/css-grid/grid-auto-rows-columns-demo-c.jpg" alt="IMAGE">\n此时设置：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-column</span><span class="token punctuation">:</span> 1 / 2<span class="token punctuation">;</span>\n  <span class="token property">grid-row</span><span class="token punctuation">:</span> 2 / 3<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item-b</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-column</span><span class="token punctuation">:</span> 5 / 6<span class="token punctuation">;</span>\n  <span class="token property">grid-row</span><span class="token punctuation">:</span> 2 / 3<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote>\n<p>grid-column 和 grid-row 的定义参考下文。</p>\n</blockquote>\n<p><img src="/posts/images/css-grid/grid-auto-rows-columns-demo-2-c.jpg" alt="IMAGE"></p>\n<p>因为我们定义的行和列超出了网格容器定义的网格，此时会生成宽度为零的网格轨迹。对网格容器添加如下样式：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-auto-columns</span><span class="token punctuation">:</span> 60px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/grid-auto-rows-columns-demo-3-c.jpg" alt="IMAGE"></p>\n<h3 id="grid-auto-flow" tabindex="-1"><a class="header-anchor" href="#grid-auto-flow" aria-hidden="true">#</a> grid-auto-flow</h3>\n<p>当网格元素未指定排列方式时，网格容器默认的自动排列方式。取值：</p>\n<ul>\n<li>row 自动沿行排列，必要情况下会添加新行</li>\n<li>column 自动沿列排列，必要情况下会添加新列</li>\n<li>dense 尽可能的填补之前布局的空白，可能会导致元素顺序发生改变</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-auto-flow</span><span class="token punctuation">:</span> row | column | row dense | column dense<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如，有如下代码：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item-a<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>item-a<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item-b<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>item-b<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item-c<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>item-c<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item-d<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>item-d<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item-e<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>item-e<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>样式定义如下：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 60px 60px 60px 60px 60px<span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 30px 30px<span class="token punctuation">;</span>\n  <span class="token property">grid-auto-flow</span><span class="token punctuation">:</span> row<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-column</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>\n  <span class="token property">grid-row</span><span class="token punctuation">:</span> 1 / 3<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.item-e</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-column</span><span class="token punctuation">:</span> 5<span class="token punctuation">;</span>\n  <span class="token property">grid-row</span><span class="token punctuation">:</span> 1 / 3<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>未设置排列方式的元素排列如下：</p>\n<p><img src="/posts/images/css-grid/grid-auto-flow-demo-c.jpg" alt="IMAGE"></p>\n<p>修改容器样式：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 60px 60px 60px 60px 60px<span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 30px 30px<span class="token punctuation">;</span>\n  <span class="token property">grid-auto-flow</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="/posts/images/css-grid/grid-auto-flow-demo-2-c.jpg" alt="IMAGE"></p>\n<h3 id="grid" tabindex="-1"><a class="header-anchor" href="#grid" aria-hidden="true">#</a> grid</h3>\n<p>grid-template-rows, grid-template-columns, grid-template-areas, grid-auto-rows, grid-auto-columns, 和 grid-auto-flow 属性的快捷写法，同时设置 grid-column-gap 和 grid-row-gap 为他们的初始值。取值：</p>\n<ul>\n<li>none 设置所有属性为初始值。</li>\n<li>&lt; grid-template-rows &gt; / &lt; grid-template-columns &gt; 设置 grid-template-rows 和 grid-template-columns 为指定值，其他属性为初始值。</li>\n<li>&lt; grid-auto-flow &gt; [&lt; grid-auto-rows &gt; [/ &lt; grid-auto-columns &gt;]] 设置 grid-auto-flow, grid-auto-rows 和 grid-auto-columns 的值，如果 grid-auto-columns 省略，则使用 grid-auto-rows，如果两个都省略，则使用初始值。</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid</span><span class="token punctuation">:</span> none | &lt; grid-template-rows > / &lt; grid-template-columns > | &lt; grid-auto-flow > [&lt; grid-auto-rows > [/ &lt; grid-auto-columns >]]<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid</span><span class="token punctuation">:</span> 200px auto / 1fr auto 1fr<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>等同于</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 200px auto<span class="token punctuation">;</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 1fr auto 1fr<span class="token punctuation">;</span>\n  <span class="token property">grid-template-areas</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid</span><span class="token punctuation">:</span> column 1fr / auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>等同于</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-auto-flow</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span>\n  <span class="token property">grid-auto-rows</span><span class="token punctuation">:</span> 1fr<span class="token punctuation">;</span>\n  <span class="token property">grid-auto-columns</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>还有一种快捷写法为：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid</span><span class="token punctuation">:</span>\n    [row1-start] <span class="token string">"header header header"</span> 1fr [row1-end]\n    [row2-start] <span class="token string">"footer footer footer"</span> 25px [row2-end]\n    / auto 50px auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>等同于：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-template-areas</span><span class="token punctuation">:</span>\n    <span class="token string">"header header header"</span>\n    <span class="token string">"footer footer footer"</span><span class="token punctuation">;</span>\n  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> [row1-start] 1fr [row1-end row2-start] 25px [row2-end]<span class="token punctuation">;</span>\n  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> auto 50px auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="网格元素相关属性" tabindex="-1"><a class="header-anchor" href="#网格元素相关属性" aria-hidden="true">#</a> 网格元素相关属性</h2>\n<h3 id="grid-row-start、grid-row-end、grid-column-start、grid-column-end" tabindex="-1"><a class="header-anchor" href="#grid-row-start、grid-row-end、grid-column-start、grid-column-end" aria-hidden="true">#</a> grid-row-start、grid-row-end、grid-column-start、grid-column-end</h3>\n<p>这四个属性指定网格元素在网格中的具体位置。grid-column-start/grid-row-start 指定开始位置, grid-column-end/grid-row-end 指定结束位置。取值：</p>\n<ul>\n<li>&lt; line &gt; 具体的网格线，可以是数字或者网格线名称</li>\n<li>span &lt; number &gt; 跨越指定数量的网格轨迹</li>\n<li>span &lt; name &gt; 跨越区域直到遇到指定名称的网格线</li>\n<li>auto 自动排列</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-column-start</span><span class="token punctuation">:</span> &lt;number> | &lt;name> | span &lt;number> | span &lt;name> | auto\n  <span class="token property">grid-column-end</span><span class="token punctuation">:</span> &lt;number> | &lt;name> | span &lt;number> | span &lt;name> | auto\n  <span class="token property">grid-row-start</span><span class="token punctuation">:</span> &lt;number> | &lt;name> | span &lt;number> | span &lt;name> | auto\n  <span class="token property">grid-row-end</span><span class="token punctuation">:</span> &lt;number> | &lt;name> | span &lt;number> | span &lt;name> | auto\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-column-start</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span>\n  <span class="token property">grid-column-end</span><span class="token punctuation">:</span> five<span class="token punctuation">;</span>\n  <span class="token property">grid-row-start</span><span class="token punctuation">:</span> row1-start<span class="token punctuation">;</span>\n  <span class="token property">grid-row-end</span><span class="token punctuation">:</span> 3<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="/posts/images/css-grid/grid-row-column-start-end-demo-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-b</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-column-start</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>\n  <span class="token property">grid-column-end</span><span class="token punctuation">:</span> span col4-start<span class="token punctuation">;</span>\n  <span class="token property">grid-row-start</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span>\n  <span class="token property">grid-row-end</span><span class="token punctuation">:</span> span 2<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="/posts/images/css-grid/grid-row-column-start-end-demo-2-c.jpg" alt="IMAGE"></p>\n<blockquote>\n<p>如果 grid-column-end 和 grid-row-end 未指定，默认跨越一个网格轨迹。网格元素允许重叠，可以通过 z-index 控制。</p>\n</blockquote>\n<h3 id="grid-row-和-grid-column" tabindex="-1"><a class="header-anchor" href="#grid-row-和-grid-column" aria-hidden="true">#</a> grid-row 和 grid-column</h3>\n<p>grid-row-start + grid-row-end 和 grid-column-start + grid-column-end 的快捷写法。取值：</p>\n<ul>\n<li>&lt; start-line &gt; / &lt; end-line &gt; 取值与非快捷写法的取值相同。</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-column</span><span class="token punctuation">:</span> &lt;start-line> / &lt;end-line> | &lt;start-line> / span &lt;value><span class="token punctuation">;</span>\n  <span class="token property">grid-row</span><span class="token punctuation">:</span> &lt;start-line> / &lt;end-line> | &lt;start-line> / span &lt;value><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-c</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-column</span><span class="token punctuation">:</span> 3 / span 2<span class="token punctuation">;</span>\n  <span class="token property">grid-row</span><span class="token punctuation">:</span> third-line / 4<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="/posts/images/css-grid/grid-row-column-c.jpg" alt="IMAGE"></p>\n<h3 id="grid-area" tabindex="-1"><a class="header-anchor" href="#grid-area" aria-hidden="true">#</a> grid-area</h3>\n<p>该属性指定网格元素的名字，这样网格元素就可以被 <code>grid-template-areas</code> 引用。同时，该属性也可以被用作 grid-row-start + grid-column-start + grid-row-end + grid-column-end 的更加快捷的写法。取值：</p>\n<ul>\n<li>&lt; name &gt; 名称，可被 <code>grid-template-areas</code> 引用。</li>\n<li>&lt; row-start&gt; / &lt; column-start&gt; / &lt; row-end&gt; / &lt; column-end&gt; 数字或者网格线的名字</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-area</span><span class="token punctuation">:</span> &lt;name> | &lt;row-start> / &lt;column-start> / &lt;row-end> / &lt;column-end><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-d</span> <span class="token punctuation">{</span>\n  <span class="token property">grid-area</span><span class="token punctuation">:</span> 1 / col4-start / last-line / 6<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/grid-area-c.jpg" alt="IMAGE"></p>\n<h3 id="justify-self" tabindex="-1"><a class="header-anchor" href="#justify-self" aria-hidden="true">#</a> justify-self</h3>\n<p>该属性指定网格元素沿行方向的对齐方式。取值：</p>\n<ul>\n<li>start 左对齐</li>\n<li>end 右对齐</li>\n<li>center 居中对齐</li>\n<li>stretch 拉伸，默认值</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-self</span><span class="token punctuation">:</span> start | end | center | stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-self</span><span class="token punctuation">:</span> start<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-self-start-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-self</span><span class="token punctuation">:</span> end<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-self-end-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-self</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-self-center-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-self</span><span class="token punctuation">:</span> stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/justify-self-stretch-c.jpg" alt="IMAGE"></p>\n<h3 id="align-self" tabindex="-1"><a class="header-anchor" href="#align-self" aria-hidden="true">#</a> align-self</h3>\n<p>该属性指定网格元素沿列方向的对齐方式。取值：</p>\n<ul>\n<li>start 上对齐</li>\n<li>end 下对齐</li>\n<li>center 居中对齐</li>\n<li>stretch 拉伸，默认值</li>\n</ul>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">align-self</span><span class="token punctuation">:</span> start | end | center | stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">align-self</span><span class="token punctuation">:</span> start<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-self-start-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">align-self</span><span class="token punctuation">:</span> end<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-self-start-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">align-self</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-self-start-c.jpg" alt="IMAGE"></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item-a</span> <span class="token punctuation">{</span>\n  <span class="token property">align-self</span><span class="token punctuation">:</span> stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/posts/images/css-grid/align-self-start-c.jpg" alt="IMAGE"></p>\n<h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>\n<ul>\n<li><a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="noopener noreferrer">A Complete Guide to Grid<OutboundLink/></a></li>\n</ul>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2018-03-27",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/css-grid.html",pathLocale:"/",permalink:"/posts/2018/03/27/css-grid.html",slug:"css-grid",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/css-grid.md",filePathRelative:"posts/css-grid.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2018/03/27/css-grid.html.vue",componentFilePathRelative:"pages/posts/2018/03/27/css-grid.html.vue",componentFileChunkName:"v-01554e16",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2018/03/27/css-grid.html.js",dataFilePathRelative:"pages/posts/2018/03/27/css-grid.html.js",dataFileChunkName:"v-01554e16",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2018/03/27/css-grid.html",htmlFilePathRelative:"posts/2018/03/27/css-grid.html"},{key:"v-cd04cc08",path:"/posts/2022/01/07/deep-dive-into-build-tools.html",title:"掌握前端构建的核心科技",lang:"zh-CN",frontmatter:{title:"掌握前端构建的核心科技",description:"webpack、esbuild、rollup、vite 各种工具层出不穷，学不动了？那是因为你没有掌握构建工具的核心能力。本文将跳出构建工具的具体细节，从共性规律出发，阐述构建工具的核心能力。",keywords:["webpack","esbuild","rollup","vite"],date:"2022-01-07T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"时代的大背景",slug:"时代的大背景",children:[]},{level:2,title:"前端构建的核心能力",slug:"前端构建的核心能力",children:[{level:3,title:"打包器",slug:"打包器",children:[]},{level:3,title:"转换器",slug:"转换器",children:[]},{level:3,title:"压缩器",slug:"压缩器",children:[]}]},{level:2,title:"我们应该怎么办",slug:"我们应该怎么办",children:[]}],content:"\n这几年，前端领域内的构建工具层出不穷，除了 webpack，叫得上号的还有 esbuild、rollup、vite、snowpack、swc、parcle 等等。咋一看，不由得感叹一句“前端好卷啊~”。其实，细想来看，倒不是大家真的卷，而是前端还处在一个高速发展的过程中，很多方面还不成熟，因此会有很多的工具出现来解决不成熟的问题。而当规范、浏览器支持方面逐渐成熟，形成足够的基础能力以后，这些工具就会逐步退出历史舞台。\n\n不管是老牌的 webpack，还是新晋的 esbuild、vite 等，如果我们把注意力都集中在这些工具提供的功能上面，只学习如何使用，那么当下一个构建工具出现的时候，又需要重头开始学习，难免有“学不动了”的感觉。\n\n本文将会跳出这些工具的具体细节，尝试总结一条工程构建领域内具有共性的规律。在这条规律的指导下，我们再来观察构建工具的能力。\n\n## 时代的大背景\n\n用“时代”这个词，稍微显得有点大，但是当说到 JavaScript 模块化这个问题时，业内确实也是经过了很多年的努力，才明确了一个大方向，现在也基本得到了主流浏览器的支持。\n\n众所周知，JavaScript 在诞生之初，是没有模块的概念的。早些年，我们还在写 jQuery 的时候，会格外注意每个 JS 文件在 HTML 中的顺序，被依赖的 JS 要在前面被加载。\n\n随着前端的发展，Web 上的应用越来越复杂，JS 代码越来越多，单靠人来维护各个 JS 文件之间的依赖关系已经不可实现。于是在工程实践层面先后诞生了 AMD、CMD 等规范，对应的实现有 RequireJS 和 SeaJS。在 NodeJS 诞生后，在服务端领域，引入了 CommonJS 规范。为了能让 JS 模块既能在浏览器运行，又能在服务端运行，又诞生了综合 AMD 和 CommonJS 的 UMD 规范。这些年，经过大家的不懈努力，JS 的模块化规范 ES Modules 终于落地，并已经得到大部分主流浏览器的支持。\n\n规范不同，语法格式也不同。不同格式的转换工作理所当然的落到了构建工具的身上。在现在的工程实践中，webpack 是集大成者，可以根据需要构建成各种模块格式，是当之无愧的业内主流。但当 ES Modules 被大部分主流浏览器支持以后，在新的基础能力之上成长起来的构建工具就可以丢弃沉重的历史包袱，轻装上阵，比如 vite、esbuild 都是基于 ES Modules 规范来构建。由于浏览器承担了一部分打包的工作，新的构建工具不再需要分析所有模块的代码且减少了很多对源代码的分析和转换，性能上提升了很多。\n\n下面是 vite 官方给出的两张图，可以看出基于 ES Modules 构建和基于 Bundle 构建的差异。\n\n![基于 Bundle 的 dev server](/posts/images/frontend-build-tools/bundle-dev-server-c.png)\n\n![基于 ES Modules 的 dev server](/posts/images/frontend-build-tools/esm-dev-server-c.png)\n\n因此，从 JavaScript 模块化发展的角度来看，不同的构建工具，因为利用规范和浏览器提供的能力的不同，表现出各方面尤其是性能方面的差异，采用 ES Modules 的构建工具性能更加卓著。\n\n## 前端构建的核心能力\n\nwebpack 是一款出色的构建工具，功能非常强大，我们可以通过配置处理各种场景下的构建问题。但是 webpack 的上手成本也很高，丰富的功能导致文档非常庞大，初学者很难看懂。很多人都是使用了 webpack 很久之后，才慢慢理解的 webpack。\n\n其实对于工程构建而言，有三个核心能力，大部分功能配置都是围绕这三个核心能力来展开，分别是：打包器（Bundler）、转换器（Transformer）和压缩器（Minimizer）。\n\n### 打包器\n\n打包器将项目代码打包成一到多个 JS 文件，每一个文件为一个包（Bundle），里面包含当前模块和依赖的其他模块。比如在 webpack 的输出结果中，通常包含三个文件：runtime.js、manifest.js 和 main.js 文件。\n\n随着 ES Modules 的发展，浏览器将会承担起越来越多的模块加载的工作，且效果也会越来越好，将来我们对打包的需求会越来越弱。现在 vite 在开发阶段，已经可以不再打包 JS 文件了，直接使用 ES 模块，参考上图。具体细节可以在 [vite 官方文档](https://cn.vitejs.dev/guide/why.html)中找到说明。\n\n### 转换器\n\n在前端生态中，典型的转换器场景就是 Babel，大家也都非常熟悉。Babel 将最新的 JS 语法转换成 es5 等浏览器支持的语法，让我们可以自由的使用最新的语法标准而不用担心浏览器兼容问题。\n\n一个典型的转换器的工作过程包含三部分：\n* Parse(解析)：将源代码转换成更加抽象的表示方法（抽象语法树 AST）\n* Transform(转换)：对（抽象语法树）做一些特殊处理，让它符合编译器的期望\n* Generate(代码生成)：将第二步经过转换过的（抽象语法树）生成新的代码\n\n转换器的核心是抽象语法树 AST，AST 的应用非常广泛，比如：\n* 编辑器的错误提示、代码格式化、代码高亮、代码自动补全；\n* elint、pretiier 对代码错误或风格的检查；\n* webpack 通过 babel 转译 javascript 语法；\n\n在工程构建方面，不管是 webpack，还是 esbuild、vite 都有转换器，区别是转换工作的多少。在 [esbuild 的文档](https://esbuild.github.io/faq/#why-is-esbuild-fast)中，我们可以看到，esbuild 只在词法分析、代码转换和代码压缩时需要处理 JavaScript AST，而其他构建工具，因为需要在多个库中传递数据，因此对代码的处理存在多个转换过程，比如 string → TS → JS → string，然后 string → JS → old JS → string，再然后 string → JS → minified JS → string，对于资源的使用更多，性能也会更差。\n\n除了 JavaScript AST 以外，很多构建工具都有 loader 的概念，用于处理图片、css 文件等各种各样的资源。这其实也是一种转换器，将其他静态资源转换成了 JS 模块。\n\n### 压缩器\n\n说到压缩大家都非常熟悉，比如代码压缩、图片压缩等，业内也有非常多的工具库可以使用。\n\n目前主流的代码压缩工具有 [terser](https://terser.org/)、[uglify-js](https://www.npmjs.com/package/uglify-js) 等。比如 terser 就是 webpack 的内置代码压缩工具。构建领域的新秀 esbuild 自己实现了代码压缩的能力，性能要甩开其他压缩工具至少一个数量级。\n\n社区里有一个[对比各个压缩工具性能的仓库](https://github.com/privatenumber/minification-benchmarks)，可以对比感受下各个压缩工具的性能差距。\n\n这里贴一张压缩 react 17 源代码的性能对比图。\n\n![代码压缩性能对比](/posts/images/frontend-build-tools/minification-c.png)\n\n## 我们应该怎么办\n\n到这里，我们并没有讲什么实现细节，但是相信大家对构建这块心里已经有了一个基本的模型，知道有哪些核心问题了。\n\n现在我们来说说，在面对层出不穷的构建工具时，我们应该怎么办。是每个构建工具都学一遍吗？肯定不是。其实，还是要从核心问题出发，看看这些构建工具具体解决了什么问题，是否已经足够成熟可以在生产环境中使用了。\n\n比如，esbuild 还在快速迭代过程中，很多周边生态还不完善，直接在生产环境中使用风险比较大。但是我们可以在 webpack 使用 esbuild 的压缩能力来提升构建的性能。\n\nvite 也在高速迭代过程中，已经具备了初步的生产使用的基础。vite 内部也大量使用了 esbuild 的能力，比如[预构建](https://cn.vitejs.dev/guide/dep-pre-bundling.html)、代码压缩等。vite 我们可以保持适当关注，不仅仅因为它是 vue 3 的默认构建工具，同时也给我们提供了 webpack 以外的其他选择。\n",contentRendered:'<p>这几年，前端领域内的构建工具层出不穷，除了 webpack，叫得上号的还有 esbuild、rollup、vite、snowpack、swc、parcle 等等。咋一看，不由得感叹一句“前端好卷啊~”。其实，细想来看，倒不是大家真的卷，而是前端还处在一个高速发展的过程中，很多方面还不成熟，因此会有很多的工具出现来解决不成熟的问题。而当规范、浏览器支持方面逐渐成熟，形成足够的基础能力以后，这些工具就会逐步退出历史舞台。</p>\n<p>不管是老牌的 webpack，还是新晋的 esbuild、vite 等，如果我们把注意力都集中在这些工具提供的功能上面，只学习如何使用，那么当下一个构建工具出现的时候，又需要重头开始学习，难免有“学不动了”的感觉。</p>\n<p>本文将会跳出这些工具的具体细节，尝试总结一条工程构建领域内具有共性的规律。在这条规律的指导下，我们再来观察构建工具的能力。</p>\n<h2 id="时代的大背景" tabindex="-1"><a class="header-anchor" href="#时代的大背景" aria-hidden="true">#</a> 时代的大背景</h2>\n<p>用“时代”这个词，稍微显得有点大，但是当说到 JavaScript 模块化这个问题时，业内确实也是经过了很多年的努力，才明确了一个大方向，现在也基本得到了主流浏览器的支持。</p>\n<p>众所周知，JavaScript 在诞生之初，是没有模块的概念的。早些年，我们还在写 jQuery 的时候，会格外注意每个 JS 文件在 HTML 中的顺序，被依赖的 JS 要在前面被加载。</p>\n<p>随着前端的发展，Web 上的应用越来越复杂，JS 代码越来越多，单靠人来维护各个 JS 文件之间的依赖关系已经不可实现。于是在工程实践层面先后诞生了 AMD、CMD 等规范，对应的实现有 RequireJS 和 SeaJS。在 NodeJS 诞生后，在服务端领域，引入了 CommonJS 规范。为了能让 JS 模块既能在浏览器运行，又能在服务端运行，又诞生了综合 AMD 和 CommonJS 的 UMD 规范。这些年，经过大家的不懈努力，JS 的模块化规范 ES Modules 终于落地，并已经得到大部分主流浏览器的支持。</p>\n<p>规范不同，语法格式也不同。不同格式的转换工作理所当然的落到了构建工具的身上。在现在的工程实践中，webpack 是集大成者，可以根据需要构建成各种模块格式，是当之无愧的业内主流。但当 ES Modules 被大部分主流浏览器支持以后，在新的基础能力之上成长起来的构建工具就可以丢弃沉重的历史包袱，轻装上阵，比如 vite、esbuild 都是基于 ES Modules 规范来构建。由于浏览器承担了一部分打包的工作，新的构建工具不再需要分析所有模块的代码且减少了很多对源代码的分析和转换，性能上提升了很多。</p>\n<p>下面是 vite 官方给出的两张图，可以看出基于 ES Modules 构建和基于 Bundle 构建的差异。</p>\n<p><img src="/posts/images/frontend-build-tools/bundle-dev-server-c.png" alt="基于 Bundle 的 dev server"></p>\n<p><img src="/posts/images/frontend-build-tools/esm-dev-server-c.png" alt="基于 ES Modules 的 dev server"></p>\n<p>因此，从 JavaScript 模块化发展的角度来看，不同的构建工具，因为利用规范和浏览器提供的能力的不同，表现出各方面尤其是性能方面的差异，采用 ES Modules 的构建工具性能更加卓著。</p>\n<h2 id="前端构建的核心能力" tabindex="-1"><a class="header-anchor" href="#前端构建的核心能力" aria-hidden="true">#</a> 前端构建的核心能力</h2>\n<p>webpack 是一款出色的构建工具，功能非常强大，我们可以通过配置处理各种场景下的构建问题。但是 webpack 的上手成本也很高，丰富的功能导致文档非常庞大，初学者很难看懂。很多人都是使用了 webpack 很久之后，才慢慢理解的 webpack。</p>\n<p>其实对于工程构建而言，有三个核心能力，大部分功能配置都是围绕这三个核心能力来展开，分别是：打包器（Bundler）、转换器（Transformer）和压缩器（Minimizer）。</p>\n<h3 id="打包器" tabindex="-1"><a class="header-anchor" href="#打包器" aria-hidden="true">#</a> 打包器</h3>\n<p>打包器将项目代码打包成一到多个 JS 文件，每一个文件为一个包（Bundle），里面包含当前模块和依赖的其他模块。比如在 webpack 的输出结果中，通常包含三个文件：runtime.js、manifest.js 和 main.js 文件。</p>\n<p>随着 ES Modules 的发展，浏览器将会承担起越来越多的模块加载的工作，且效果也会越来越好，将来我们对打包的需求会越来越弱。现在 vite 在开发阶段，已经可以不再打包 JS 文件了，直接使用 ES 模块，参考上图。具体细节可以在 <a href="https://cn.vitejs.dev/guide/why.html" target="_blank" rel="noopener noreferrer">vite 官方文档<OutboundLink/></a>中找到说明。</p>\n<h3 id="转换器" tabindex="-1"><a class="header-anchor" href="#转换器" aria-hidden="true">#</a> 转换器</h3>\n<p>在前端生态中，典型的转换器场景就是 Babel，大家也都非常熟悉。Babel 将最新的 JS 语法转换成 es5 等浏览器支持的语法，让我们可以自由的使用最新的语法标准而不用担心浏览器兼容问题。</p>\n<p>一个典型的转换器的工作过程包含三部分：</p>\n<ul>\n<li>Parse(解析)：将源代码转换成更加抽象的表示方法（抽象语法树 AST）</li>\n<li>Transform(转换)：对（抽象语法树）做一些特殊处理，让它符合编译器的期望</li>\n<li>Generate(代码生成)：将第二步经过转换过的（抽象语法树）生成新的代码</li>\n</ul>\n<p>转换器的核心是抽象语法树 AST，AST 的应用非常广泛，比如：</p>\n<ul>\n<li>编辑器的错误提示、代码格式化、代码高亮、代码自动补全；</li>\n<li>elint、pretiier 对代码错误或风格的检查；</li>\n<li>webpack 通过 babel 转译 javascript 语法；</li>\n</ul>\n<p>在工程构建方面，不管是 webpack，还是 esbuild、vite 都有转换器，区别是转换工作的多少。在 <a href="https://esbuild.github.io/faq/#why-is-esbuild-fast" target="_blank" rel="noopener noreferrer">esbuild 的文档<OutboundLink/></a>中，我们可以看到，esbuild 只在词法分析、代码转换和代码压缩时需要处理 JavaScript AST，而其他构建工具，因为需要在多个库中传递数据，因此对代码的处理存在多个转换过程，比如 string → TS → JS → string，然后 string → JS → old JS → string，再然后 string → JS → minified JS → string，对于资源的使用更多，性能也会更差。</p>\n<p>除了 JavaScript AST 以外，很多构建工具都有 loader 的概念，用于处理图片、css 文件等各种各样的资源。这其实也是一种转换器，将其他静态资源转换成了 JS 模块。</p>\n<h3 id="压缩器" tabindex="-1"><a class="header-anchor" href="#压缩器" aria-hidden="true">#</a> 压缩器</h3>\n<p>说到压缩大家都非常熟悉，比如代码压缩、图片压缩等，业内也有非常多的工具库可以使用。</p>\n<p>目前主流的代码压缩工具有 <a href="https://terser.org/" target="_blank" rel="noopener noreferrer">terser<OutboundLink/></a>、<a href="https://www.npmjs.com/package/uglify-js" target="_blank" rel="noopener noreferrer">uglify-js<OutboundLink/></a> 等。比如 terser 就是 webpack 的内置代码压缩工具。构建领域的新秀 esbuild 自己实现了代码压缩的能力，性能要甩开其他压缩工具至少一个数量级。</p>\n<p>社区里有一个<a href="https://github.com/privatenumber/minification-benchmarks" target="_blank" rel="noopener noreferrer">对比各个压缩工具性能的仓库<OutboundLink/></a>，可以对比感受下各个压缩工具的性能差距。</p>\n<p>这里贴一张压缩 react 17 源代码的性能对比图。</p>\n<p><img src="/posts/images/frontend-build-tools/minification-c.png" alt="代码压缩性能对比"></p>\n<h2 id="我们应该怎么办" tabindex="-1"><a class="header-anchor" href="#我们应该怎么办" aria-hidden="true">#</a> 我们应该怎么办</h2>\n<p>到这里，我们并没有讲什么实现细节，但是相信大家对构建这块心里已经有了一个基本的模型，知道有哪些核心问题了。</p>\n<p>现在我们来说说，在面对层出不穷的构建工具时，我们应该怎么办。是每个构建工具都学一遍吗？肯定不是。其实，还是要从核心问题出发，看看这些构建工具具体解决了什么问题，是否已经足够成熟可以在生产环境中使用了。</p>\n<p>比如，esbuild 还在快速迭代过程中，很多周边生态还不完善，直接在生产环境中使用风险比较大。但是我们可以在 webpack 使用 esbuild 的压缩能力来提升构建的性能。</p>\n<p>vite 也在高速迭代过程中，已经具备了初步的生产使用的基础。vite 内部也大量使用了 esbuild 的能力，比如<a href="https://cn.vitejs.dev/guide/dep-pre-bundling.html" target="_blank" rel="noopener noreferrer">预构建<OutboundLink/></a>、代码压缩等。vite 我们可以保持适当关注，不仅仅因为它是 vue 3 的默认构建工具，同时也给我们提供了 webpack 以外的其他选择。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-01-07",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/deep-dive-into-build-tools.html",pathLocale:"/",permalink:"/posts/2022/01/07/deep-dive-into-build-tools.html",slug:"deep-dive-into-build-tools",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/deep-dive-into-build-tools.md",filePathRelative:"posts/deep-dive-into-build-tools.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/01/07/deep-dive-into-build-tools.html.vue",componentFilePathRelative:"pages/posts/2022/01/07/deep-dive-into-build-tools.html.vue",componentFileChunkName:"v-cd04cc08",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/01/07/deep-dive-into-build-tools.html.js",dataFilePathRelative:"pages/posts/2022/01/07/deep-dive-into-build-tools.html.js",dataFileChunkName:"v-cd04cc08",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2022/01/07/deep-dive-into-build-tools.html",htmlFilePathRelative:"posts/2022/01/07/deep-dive-into-build-tools.html"},{key:"v-0bf56d7a",path:"/posts/2021/08/05/deep-dive-into-es-module.html",title:"深入理解 ES 模块",lang:"zh-CN",frontmatter:{title:"深入理解 ES 模块",description:"ES 模块正在被各大浏览器和 NodeJS 原生支持。本文从 ES 模块的诞生背景出发，详细说明为什么需要 ES模块，以及 ES 模块的工作原理。",keywords:["ES 模块"],date:"2021-08-05T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"ES 模块解决了什么问题",slug:"es-模块解决了什么问题",children:[]},{level:2,title:"模块如何解决这个问题",slug:"模块如何解决这个问题",children:[]},{level:2,title:"ES 模块是如何工作的",slug:"es-模块是如何工作的",children:[{level:3,title:"构建过程（construction）",slug:"构建过程-construction",children:[]},{level:3,title:"初始化（Instantiation）",slug:"初始化-instantiation",children:[]},{level:3,title:"求值（Evaluation）",slug:"求值-evaluation",children:[]}]}],content:'\nES 模块标准化了将近 10 年，好消息是现在各大主流浏览器厂商已经原生支持 ES 模块，同时 NodeJS 对 ES 模块原生支持也在完善中。\n\n许多前端开发者都知道 ES 模块一直存在争议。但很少有人真正了解 ES 模块的工作原理。让我们来看看 ES 模块解决了什么问题，以及它们与其他模块系统中的模块有何不同。\n\n## ES 模块解决了什么问题\n\n仔细想想，我们平时的编码过程就是管理变量的过程，为变量赋值，为变量添加数字，将两个变量组合在一起并将它们放入另一个变量中等等。\n\n![变量](/posts/images/es-modules/variables-c.png)\n\n因为我们大部分代码都只是关于更改变量，所以如何组织这些变量将对我们的编码能力以及维护代码的能力产生重大影响。\n\n借助于 JavaScript 的作用域，我们可以一次只管理几个变量，极大的降低了编写和维护代码的难度。但是由于作用域的限制，函数无法访问其他函数中定义的变量。如果我们需要跨作用域共享一些变量，将会非常麻烦。\n\n![模块作用域](/posts/images/es-modules/module-scope-c.png)\n\n如果我们想在作用域之外共享变量的话，通常只能将变量放在更上层的作用域里。比如，放在全局作用域内。就像在 jQuery 时代，在加载任何 jQuery 插件之前，我们必须确保 jQuery 在全局作用域内。\n\n![jQuery 例子](/posts/images/es-modules/jquery-c.png)\n\n虽然这种方式可以很好的工作，但是也有很多问题。比如，所有 JS 脚本都需要按正确的顺序排列，同时我们还要确保没有人把这个顺序弄乱。一旦顺序出错，那么在运行过程中，我们的应用程序就会抛出错误。\n\n![jQuery 执行出错](/posts/images/es-modules/jquery-error-c.png)\n\n长此以往，代码变得越来越难以维护。因为不同代码之间的依赖关系是隐式的，删除旧代码或脚本标签的后果变得不可预知。任何函数都可以获取全局作用域上的任何东西，所以我们也不知道哪些函数依赖于哪些脚本。\n\n同时，因为这些变量在全局作用域内，理论上任何一段代码都可以更改这些变量。恶意代码可以故意更改变量，导致代码执行预期之外的事情。非恶意代码也可能意外破坏变量导致程序出错。\n\n## 模块如何解决这个问题\n\n使用模块，我们可以将有意义的变量和函数组合在一起。这些变量和函数都处于同一个模块作用域中，函数之间可以共享这些变量。同时，模块还可以与其他模块共享变量或者函数，只需要将这些可以共享的函数或者变量导出即可。\n\n当一个变量或者函数可以被模块外访问时，我们称之为导出了这个变量或函数。当一个变量或函数被导出后，其他模块就可以使用这个变量或函数。\n\n![导出与依赖](/posts/images/es-modules/export-c.png)\n\n这是一个明确依赖的关系，所以我们可以判断出如果删除另一个模块，哪些模块会出错。\n\n当我们能够在模块之间导出和导入变量之后，我们就可以更轻松地将代码分解为可以相互独立工作的小块。然后我们可以重新组合这些块，来创建不同类型的应用程序。\n\n由于模块非常有用，在 ES 模块之前就已经有模块系统存在了。CommonJS (CJS) 是 NodeJS 正在使用的模块加载规范。\n\n## ES 模块是如何工作的\n\n当我们使用模块进行开发时，我们会构建一个依赖关系图。不同依赖项之间的连接来自我们使用的任何 `import` 语句。\n\n浏览器或 NodeJS 通过这些 `import` 语句来感知需要加载哪些代码。通过从程序的入口文件开始，浏览器或者 NodeJS 会跟随任何 `import` 语句来查找其余的代码。\n\n![导入](/posts/images/es-modules/import-graph-c.png)\n\n浏览器或者 NodeJS 解析所有这些文件，将它们转换为一定的数据结构，这个数据结构被称为模块记录（module record）。\n\n![模块记录](/posts/images/es-modules/module-record-c.png)\n\n之后，模块记录被转化成模块实例。一个模块实例包含两部分：代码和状态。\n\n代码是一组指令，就像一个指导说明。我们不能使用代码本身做任何事情，我们需要借助于状态来使用这些指令。状态是变量在任何时间点的实际值，存储在内存中。\n\n因此，模块实例包含代码（一组指令）和状态（变量的值）。\n\n![模块记录](/posts/images/es-modules/module-instance-c.png)\n\n程序运行的时候需要的是每个模块的模块实例。模块加载的过程就是从这个入口点文件到拥有一个完整的模块实例图的过程。\n\n对于 ES 模块来说，通常分为三步：\n\n1. 构建过程（Construction） -- 查找、下载和解析所有的模块文件，生成模块记录。\n2. 初始化（Instantiation） -- 为模块导出的变量分配内存（但不求值）。然后将导入和导出都指向这些内存地址，这称为链接。\n3. 求值（Evaluation） -- 运行代码，将变量值填充到内存中去。\n\n![模块实例化过程](/posts/images/es-modules/phases-c.png)\n\n在 [ES 模块规范](https://tc39.github.io/ecma262/#sec-modules) 中只定义了如何构建模块记录，以及如何初始化和对模块求值，但是没有定义如何加载这些模块。\n\n在浏览器中，如何加载模块定义在 [HTML 规范](https://html.spec.whatwg.org/#fetch-a-module-script-tree)中。\n\n![加载模块](/posts/images/es-modules/loader-es-c.png)\n\n同时，浏览器还控制了如何实例化模块。通过调用 ES 模块的 `ParseModule`、`Module.Instantiate` 和 `Module.Evaluate` 等方法，浏览器像操作木偶一样操作 JS 引擎来实例化模块。\n\n![浏览器实例化模块](/posts/images/es-modules/puppeteer-c.png)\n\n现在我们来看看模块实例化的每一步发生了什么。\n\n### 构建过程（construction）\n\n每个模块在构建过程都会经历如下三步：\n\n- 确定在哪里可以获取模块（module resolution）\n- 获取模块（从网络上下载或者从文件读取）\n- 解析文件，将其转换成模块记录\n\n**查找并获取模块**\n\n浏览器会负责查找并下载文件。我们通过 `script` 标签来告诉浏览器入口文件。\n\n![入口文件](/posts/images/es-modules/script-entry-c.png)\n\n之后浏览器会根据导入语句来加载其他模块。\n\n![导入语句](/posts/images/es-modules/module-specifier-c.png)\n\n值得说明的是，导入语句后方的那段被称为模块说明符（module specifier）。不同平台对于模块说明符的处理不同。比如浏览器和 NodeJS 就存在差异。每个平台都会有一套模块解析算法（module resolution algorithm）来加载模块。\n\n在浏览器中，加载模块是异步的。因为浏览器通过 URL 来查找并下载模块。假如浏览器通过同步的方式来加载模块，那么要解析模块间的依赖关系就需要顺序下载模块并执行代码才能实现，这将会非常耗时，同时在这个过程中浏览器不能做任何事情。\n\n![同步加载模块](/posts/images/es-modules/construction-c.png)\n\n我们知道，CPU 时间和下载的网络耗时差别是非常大的。\n\n![CPU时间和网络耗时](/posts/images/es-modules/latency-c.png)\n\n因此，同步加载模块会让我们的应用非常的慢，体验很差。因此，ES 模块的实例化过程被分成了三个阶段。将模块的构建（construction）过程独立出来以后，浏览器可以免于执行代码就能获取模块间的依赖关系。\n\n前面说到 NodeJS 使用 CommonJS 规范来加载模块。CommonJS 模块是同步加载的。因此从文件系统读取文件比网络下载要快的多，NodeJS 完全可以在读取完文件以后直接初始化和对模块求值。因此，在 NodeJS 中，模块在其依赖的所有其他模块都完成实例化之后才会返回。\n\n![NodeJS 加载模块](/posts/images/es-modules/cjs-require-c.png)\n\n正因为 CommonJS 的这个特点，在 NodeJS 中，模块说明符（module specifier）中可以使用变量。ES 模块中不可以。\n\n![静态导入](/posts/images/es-modules/static-import-c.png)\n\n但是有时候我们确实需要动态改变模块路径，在 ES 模块中，我们可以通过[动态导入](https://github.com/tc39/proposal-dynamic-import)的方式来实现，使用 `import()` 函数。\n\n![动态导入](/posts/images/es-modules/dynamic-import-c.png)\n\n使用 `import()` 函数导入的模块会生成一张子模块图，这个子模块图的处理将会与当前模块图的处理隔离开。\n\n有一点要注意，所有的模块，在任何一个阶段都只有一个实例。浏览器会缓存模块实例，这样可以避免当一个模块被多个模块依赖的时候被下载和解析多次。\n\n浏览器使用模块缓存（[module-map](https://html.spec.whatwg.org/multipage/webappapis.html#module-map)）来存储这些模块实例。每一个顶级作用域都有各自独立的模块缓存。\n\n当浏览器解析一个模块的时候，它会把这个模块放到模块缓存中，标记模块状态为加载中（fetching）。之后浏览器会发起请求下载这个文件。\n\n![模块缓存](/posts/images/es-modules/module-map-c.png)\n\n如果其他模块也依赖了这个模块，浏览器会检查模块缓存，如果发现缓存中已经有了这个模块的记录，即时还是加载中，浏览器也不会再重复处理这个模块了。\n\n**解析模块（parsing）**\n\n当浏览器获取到模块文件以后，就可以解析成模块记录。模块记录帮助浏览器识别模块中的不同部分分别是什么。\n\n![文件解析成模块记录](/posts/images/es-modules/file-to-module-record-c.png)\n\n一旦模块记录生成以后，浏览器就会将其放到模块缓存中，之后在任何地方引用这个模块，浏览器可以直接从缓存中取出这个模块。\n\n![模块缓存](/posts/images/es-modules/module-map-2-c.png)\n\n默认情况下，模块被浏览器按照严格模式（"use strict"）进行解析，同时顶层的 `await` 是保留的，顶层`this` 的值是 `undefinded`。\n\n当然也有其他的解析方式。不同的解析方式成为解析目标（parse goal）。同一个文件使用不同的解析目标进行解析，得到的结果不同。在浏览器中，我们通过给 `script` 标签添加 `type="module"` 属性来告诉浏览器要按照模块来解析文件，在 NodeJS 中我们通过 `.mjs` 后缀的方式来指明这是一个模块。\n\n![解析目标](/posts/images/es-modules/parse-goal-c.png)\n\n当浏览器从入口文件开始解析完所有的模块以后，我们就得到了一组模块记录。\n\n![从入口文件到模块记录](/posts/images/es-modules/construction-c.png)\n\n### 初始化（Instantiation）\n\n一个模块实例包含代码和状态，实例化的过程就是往内存中写入状态的过程。\n\n首先，JS 引擎会创建一个模块环境记录（module environment record）。这个模块环境记录负责管理模块记录中的变量。然后它会在内存中为所有导出的变量分配内存地址。模块环境记录将跟踪内存中的地址和每个导出变量间的关联关系。\n\n分配好的内存地址并不会立即被填入值，填值要等到求值（evaluation）阶段。\n\n在初始化模块图的过程中，JS 引擎会通过深度优先后序遍历的方式，先处理一个模块及其依赖模块的导出，再处理导入。也就是说，JS 引擎会先找到模块依赖的模块中最末端没有任何依赖的模块，处理导出，然后逐层返回处理导出，最后处理入口模块的导出。之后，同样的方法处理导入。\n\n![live-binding](/posts/images/es-modules/live-bindings-c.png)\n\n注意，导入和导出的变量在内存中指向同一个地址。先处理导出的优点是可以让导入导出一一对应。\n\n![live-binding](/posts/images/es-modules/live-bindings-02-c.png)\n\n这一点与 CommonJS 不同。CommonJS 的导出是一份完全的拷贝。也就是说，如果导出的变量是一个数值，那么导出的变量是模块内变量值得拷贝。后续这两个变量之间没有任何关系。\n\n![cjs-variable](/posts/images/es-modules/cjs-variable-c.png)\n\n与 CommonJS 相反，ES 模块使用实时绑定（live binding），导出的变量和导入的变量在内存中使用同一个地址，但是导入的变量不能修改变量值。\n\n![live-bindings](/posts/images/es-modules/live-bindings-03-c.png)\n\n之所以使用实时绑定，是因为这样可以在不执行任何代码的情况下就能将所有模块关联起来，当处理模块间的循环引用的时候将会非常有用。\n\n### 求值（Evaluation）\n\n当浏览器开始运行代码时，会从顶层代码开始运行，及函数外的代码。\n\n![顶层代码](/posts/images/es-modules/top-level-code-c.png)\n\n但是，执行代码必可避免的会有副作用产生。比如有些代码会向服务端发起请求。因此，同一段代码运行多次可能有不同的结果。\n\n因此，我们需要借助于模块缓存，使得每次解析到相同模块的时候，都是引用的同一个缓存记录，从而保证每个模块的代码只执行一次。\n\n前面说到循环依赖的问题。通常一个循环依赖会很深，即产生循环依赖的两个模块之间会有多个模块。简单起见，我们举个两个直接相互依赖的模块做例子。\n\n![循环依赖](/posts/images/es-modules/cyclic-graph-c.png)\n\n我们来看看 CommonJS 是如何处理的。\n\n![循环依赖](/posts/images/es-modules/cjs-cycle-c.png)\n\n首先，JS 引擎会解析 `require` 语句，接着解析 Counter 模块。Counter 模块此时会尝试获取 `message` 的值。因为 Main 模块还没有求值，此时 `message` 的值是 undefined。JS 引擎会在内存中为这个变量分配内存，然后将值置为 undefined。\n\n![CJS 变量](/posts/images/es-modules/cjs-variable-2-c.png)\n\n之后，JS 引擎执行完 Counter 模块的顶层代码，恢复执行 Main 模块的顶层代码。为了检验 Counter 是否拿到了正确的 `message` 的值，我们在代码中加了一个 `setTimeout`。\n\n![CJS 变量](/posts/images/es-modules/cjs-variable-3-c.png)\n\n在对 Main 模块进行求值的时候，`message` 得到了值，写入内存。但是因为两个模块的导入导出之间没有建立连接，Counter 模块中的 `message` 还是 undefined。\n\nES 模块的实时绑定机制就可以有效解决这个问题。\n',contentRendered:'<p>ES 模块标准化了将近 10 年，好消息是现在各大主流浏览器厂商已经原生支持 ES 模块，同时 NodeJS 对 ES 模块原生支持也在完善中。</p>\n<p>许多前端开发者都知道 ES 模块一直存在争议。但很少有人真正了解 ES 模块的工作原理。让我们来看看 ES 模块解决了什么问题，以及它们与其他模块系统中的模块有何不同。</p>\n<h2 id="es-模块解决了什么问题" tabindex="-1"><a class="header-anchor" href="#es-模块解决了什么问题" aria-hidden="true">#</a> ES 模块解决了什么问题</h2>\n<p>仔细想想，我们平时的编码过程就是管理变量的过程，为变量赋值，为变量添加数字，将两个变量组合在一起并将它们放入另一个变量中等等。</p>\n<p><img src="/posts/images/es-modules/variables-c.png" alt="变量"></p>\n<p>因为我们大部分代码都只是关于更改变量，所以如何组织这些变量将对我们的编码能力以及维护代码的能力产生重大影响。</p>\n<p>借助于 JavaScript 的作用域，我们可以一次只管理几个变量，极大的降低了编写和维护代码的难度。但是由于作用域的限制，函数无法访问其他函数中定义的变量。如果我们需要跨作用域共享一些变量，将会非常麻烦。</p>\n<p><img src="/posts/images/es-modules/module-scope-c.png" alt="模块作用域"></p>\n<p>如果我们想在作用域之外共享变量的话，通常只能将变量放在更上层的作用域里。比如，放在全局作用域内。就像在 jQuery 时代，在加载任何 jQuery 插件之前，我们必须确保 jQuery 在全局作用域内。</p>\n<p><img src="/posts/images/es-modules/jquery-c.png" alt="jQuery 例子"></p>\n<p>虽然这种方式可以很好的工作，但是也有很多问题。比如，所有 JS 脚本都需要按正确的顺序排列，同时我们还要确保没有人把这个顺序弄乱。一旦顺序出错，那么在运行过程中，我们的应用程序就会抛出错误。</p>\n<p><img src="/posts/images/es-modules/jquery-error-c.png" alt="jQuery 执行出错"></p>\n<p>长此以往，代码变得越来越难以维护。因为不同代码之间的依赖关系是隐式的，删除旧代码或脚本标签的后果变得不可预知。任何函数都可以获取全局作用域上的任何东西，所以我们也不知道哪些函数依赖于哪些脚本。</p>\n<p>同时，因为这些变量在全局作用域内，理论上任何一段代码都可以更改这些变量。恶意代码可以故意更改变量，导致代码执行预期之外的事情。非恶意代码也可能意外破坏变量导致程序出错。</p>\n<h2 id="模块如何解决这个问题" tabindex="-1"><a class="header-anchor" href="#模块如何解决这个问题" aria-hidden="true">#</a> 模块如何解决这个问题</h2>\n<p>使用模块，我们可以将有意义的变量和函数组合在一起。这些变量和函数都处于同一个模块作用域中，函数之间可以共享这些变量。同时，模块还可以与其他模块共享变量或者函数，只需要将这些可以共享的函数或者变量导出即可。</p>\n<p>当一个变量或者函数可以被模块外访问时，我们称之为导出了这个变量或函数。当一个变量或函数被导出后，其他模块就可以使用这个变量或函数。</p>\n<p><img src="/posts/images/es-modules/export-c.png" alt="导出与依赖"></p>\n<p>这是一个明确依赖的关系，所以我们可以判断出如果删除另一个模块，哪些模块会出错。</p>\n<p>当我们能够在模块之间导出和导入变量之后，我们就可以更轻松地将代码分解为可以相互独立工作的小块。然后我们可以重新组合这些块，来创建不同类型的应用程序。</p>\n<p>由于模块非常有用，在 ES 模块之前就已经有模块系统存在了。CommonJS (CJS) 是 NodeJS 正在使用的模块加载规范。</p>\n<h2 id="es-模块是如何工作的" tabindex="-1"><a class="header-anchor" href="#es-模块是如何工作的" aria-hidden="true">#</a> ES 模块是如何工作的</h2>\n<p>当我们使用模块进行开发时，我们会构建一个依赖关系图。不同依赖项之间的连接来自我们使用的任何 <code>import</code> 语句。</p>\n<p>浏览器或 NodeJS 通过这些 <code>import</code> 语句来感知需要加载哪些代码。通过从程序的入口文件开始，浏览器或者 NodeJS 会跟随任何 <code>import</code> 语句来查找其余的代码。</p>\n<p><img src="/posts/images/es-modules/import-graph-c.png" alt="导入"></p>\n<p>浏览器或者 NodeJS 解析所有这些文件，将它们转换为一定的数据结构，这个数据结构被称为模块记录（module record）。</p>\n<p><img src="/posts/images/es-modules/module-record-c.png" alt="模块记录"></p>\n<p>之后，模块记录被转化成模块实例。一个模块实例包含两部分：代码和状态。</p>\n<p>代码是一组指令，就像一个指导说明。我们不能使用代码本身做任何事情，我们需要借助于状态来使用这些指令。状态是变量在任何时间点的实际值，存储在内存中。</p>\n<p>因此，模块实例包含代码（一组指令）和状态（变量的值）。</p>\n<p><img src="/posts/images/es-modules/module-instance-c.png" alt="模块记录"></p>\n<p>程序运行的时候需要的是每个模块的模块实例。模块加载的过程就是从这个入口点文件到拥有一个完整的模块实例图的过程。</p>\n<p>对于 ES 模块来说，通常分为三步：</p>\n<ol>\n<li>构建过程（Construction） -- 查找、下载和解析所有的模块文件，生成模块记录。</li>\n<li>初始化（Instantiation） -- 为模块导出的变量分配内存（但不求值）。然后将导入和导出都指向这些内存地址，这称为链接。</li>\n<li>求值（Evaluation） -- 运行代码，将变量值填充到内存中去。</li>\n</ol>\n<p><img src="/posts/images/es-modules/phases-c.png" alt="模块实例化过程"></p>\n<p>在 <a href="https://tc39.github.io/ecma262/#sec-modules" target="_blank" rel="noopener noreferrer">ES 模块规范<OutboundLink/></a> 中只定义了如何构建模块记录，以及如何初始化和对模块求值，但是没有定义如何加载这些模块。</p>\n<p>在浏览器中，如何加载模块定义在 <a href="https://html.spec.whatwg.org/#fetch-a-module-script-tree" target="_blank" rel="noopener noreferrer">HTML 规范<OutboundLink/></a>中。</p>\n<p><img src="/posts/images/es-modules/loader-es-c.png" alt="加载模块"></p>\n<p>同时，浏览器还控制了如何实例化模块。通过调用 ES 模块的 <code>ParseModule</code>、<code>Module.Instantiate</code> 和 <code>Module.Evaluate</code> 等方法，浏览器像操作木偶一样操作 JS 引擎来实例化模块。</p>\n<p><img src="/posts/images/es-modules/puppeteer-c.png" alt="浏览器实例化模块"></p>\n<p>现在我们来看看模块实例化的每一步发生了什么。</p>\n<h3 id="构建过程-construction" tabindex="-1"><a class="header-anchor" href="#构建过程-construction" aria-hidden="true">#</a> 构建过程（construction）</h3>\n<p>每个模块在构建过程都会经历如下三步：</p>\n<ul>\n<li>确定在哪里可以获取模块（module resolution）</li>\n<li>获取模块（从网络上下载或者从文件读取）</li>\n<li>解析文件，将其转换成模块记录</li>\n</ul>\n<p><strong>查找并获取模块</strong></p>\n<p>浏览器会负责查找并下载文件。我们通过 <code>script</code> 标签来告诉浏览器入口文件。</p>\n<p><img src="/posts/images/es-modules/script-entry-c.png" alt="入口文件"></p>\n<p>之后浏览器会根据导入语句来加载其他模块。</p>\n<p><img src="/posts/images/es-modules/module-specifier-c.png" alt="导入语句"></p>\n<p>值得说明的是，导入语句后方的那段被称为模块说明符（module specifier）。不同平台对于模块说明符的处理不同。比如浏览器和 NodeJS 就存在差异。每个平台都会有一套模块解析算法（module resolution algorithm）来加载模块。</p>\n<p>在浏览器中，加载模块是异步的。因为浏览器通过 URL 来查找并下载模块。假如浏览器通过同步的方式来加载模块，那么要解析模块间的依赖关系就需要顺序下载模块并执行代码才能实现，这将会非常耗时，同时在这个过程中浏览器不能做任何事情。</p>\n<p><img src="/posts/images/es-modules/construction-c.png" alt="同步加载模块"></p>\n<p>我们知道，CPU 时间和下载的网络耗时差别是非常大的。</p>\n<p><img src="/posts/images/es-modules/latency-c.png" alt="CPU时间和网络耗时"></p>\n<p>因此，同步加载模块会让我们的应用非常的慢，体验很差。因此，ES 模块的实例化过程被分成了三个阶段。将模块的构建（construction）过程独立出来以后，浏览器可以免于执行代码就能获取模块间的依赖关系。</p>\n<p>前面说到 NodeJS 使用 CommonJS 规范来加载模块。CommonJS 模块是同步加载的。因此从文件系统读取文件比网络下载要快的多，NodeJS 完全可以在读取完文件以后直接初始化和对模块求值。因此，在 NodeJS 中，模块在其依赖的所有其他模块都完成实例化之后才会返回。</p>\n<p><img src="/posts/images/es-modules/cjs-require-c.png" alt="NodeJS 加载模块"></p>\n<p>正因为 CommonJS 的这个特点，在 NodeJS 中，模块说明符（module specifier）中可以使用变量。ES 模块中不可以。</p>\n<p><img src="/posts/images/es-modules/static-import-c.png" alt="静态导入"></p>\n<p>但是有时候我们确实需要动态改变模块路径，在 ES 模块中，我们可以通过<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener noreferrer">动态导入<OutboundLink/></a>的方式来实现，使用 <code>import()</code> 函数。</p>\n<p><img src="/posts/images/es-modules/dynamic-import-c.png" alt="动态导入"></p>\n<p>使用 <code>import()</code> 函数导入的模块会生成一张子模块图，这个子模块图的处理将会与当前模块图的处理隔离开。</p>\n<p>有一点要注意，所有的模块，在任何一个阶段都只有一个实例。浏览器会缓存模块实例，这样可以避免当一个模块被多个模块依赖的时候被下载和解析多次。</p>\n<p>浏览器使用模块缓存（<a href="https://html.spec.whatwg.org/multipage/webappapis.html#module-map" target="_blank" rel="noopener noreferrer">module-map<OutboundLink/></a>）来存储这些模块实例。每一个顶级作用域都有各自独立的模块缓存。</p>\n<p>当浏览器解析一个模块的时候，它会把这个模块放到模块缓存中，标记模块状态为加载中（fetching）。之后浏览器会发起请求下载这个文件。</p>\n<p><img src="/posts/images/es-modules/module-map-c.png" alt="模块缓存"></p>\n<p>如果其他模块也依赖了这个模块，浏览器会检查模块缓存，如果发现缓存中已经有了这个模块的记录，即时还是加载中，浏览器也不会再重复处理这个模块了。</p>\n<p><strong>解析模块（parsing）</strong></p>\n<p>当浏览器获取到模块文件以后，就可以解析成模块记录。模块记录帮助浏览器识别模块中的不同部分分别是什么。</p>\n<p><img src="/posts/images/es-modules/file-to-module-record-c.png" alt="文件解析成模块记录"></p>\n<p>一旦模块记录生成以后，浏览器就会将其放到模块缓存中，之后在任何地方引用这个模块，浏览器可以直接从缓存中取出这个模块。</p>\n<p><img src="/posts/images/es-modules/module-map-2-c.png" alt="模块缓存"></p>\n<p>默认情况下，模块被浏览器按照严格模式（&quot;use strict&quot;）进行解析，同时顶层的 <code>await</code> 是保留的，顶层<code>this</code> 的值是 <code>undefinded</code>。</p>\n<p>当然也有其他的解析方式。不同的解析方式成为解析目标（parse goal）。同一个文件使用不同的解析目标进行解析，得到的结果不同。在浏览器中，我们通过给 <code>script</code> 标签添加 <code>type=&quot;module&quot;</code> 属性来告诉浏览器要按照模块来解析文件，在 NodeJS 中我们通过 <code>.mjs</code> 后缀的方式来指明这是一个模块。</p>\n<p><img src="/posts/images/es-modules/parse-goal-c.png" alt="解析目标"></p>\n<p>当浏览器从入口文件开始解析完所有的模块以后，我们就得到了一组模块记录。</p>\n<p><img src="/posts/images/es-modules/construction-c.png" alt="从入口文件到模块记录"></p>\n<h3 id="初始化-instantiation" tabindex="-1"><a class="header-anchor" href="#初始化-instantiation" aria-hidden="true">#</a> 初始化（Instantiation）</h3>\n<p>一个模块实例包含代码和状态，实例化的过程就是往内存中写入状态的过程。</p>\n<p>首先，JS 引擎会创建一个模块环境记录（module environment record）。这个模块环境记录负责管理模块记录中的变量。然后它会在内存中为所有导出的变量分配内存地址。模块环境记录将跟踪内存中的地址和每个导出变量间的关联关系。</p>\n<p>分配好的内存地址并不会立即被填入值，填值要等到求值（evaluation）阶段。</p>\n<p>在初始化模块图的过程中，JS 引擎会通过深度优先后序遍历的方式，先处理一个模块及其依赖模块的导出，再处理导入。也就是说，JS 引擎会先找到模块依赖的模块中最末端没有任何依赖的模块，处理导出，然后逐层返回处理导出，最后处理入口模块的导出。之后，同样的方法处理导入。</p>\n<p><img src="/posts/images/es-modules/live-bindings-c.png" alt="live-binding"></p>\n<p>注意，导入和导出的变量在内存中指向同一个地址。先处理导出的优点是可以让导入导出一一对应。</p>\n<p><img src="/posts/images/es-modules/live-bindings-02-c.png" alt="live-binding"></p>\n<p>这一点与 CommonJS 不同。CommonJS 的导出是一份完全的拷贝。也就是说，如果导出的变量是一个数值，那么导出的变量是模块内变量值得拷贝。后续这两个变量之间没有任何关系。</p>\n<p><img src="/posts/images/es-modules/cjs-variable-c.png" alt="cjs-variable"></p>\n<p>与 CommonJS 相反，ES 模块使用实时绑定（live binding），导出的变量和导入的变量在内存中使用同一个地址，但是导入的变量不能修改变量值。</p>\n<p><img src="/posts/images/es-modules/live-bindings-03-c.png" alt="live-bindings"></p>\n<p>之所以使用实时绑定，是因为这样可以在不执行任何代码的情况下就能将所有模块关联起来，当处理模块间的循环引用的时候将会非常有用。</p>\n<h3 id="求值-evaluation" tabindex="-1"><a class="header-anchor" href="#求值-evaluation" aria-hidden="true">#</a> 求值（Evaluation）</h3>\n<p>当浏览器开始运行代码时，会从顶层代码开始运行，及函数外的代码。</p>\n<p><img src="/posts/images/es-modules/top-level-code-c.png" alt="顶层代码"></p>\n<p>但是，执行代码必可避免的会有副作用产生。比如有些代码会向服务端发起请求。因此，同一段代码运行多次可能有不同的结果。</p>\n<p>因此，我们需要借助于模块缓存，使得每次解析到相同模块的时候，都是引用的同一个缓存记录，从而保证每个模块的代码只执行一次。</p>\n<p>前面说到循环依赖的问题。通常一个循环依赖会很深，即产生循环依赖的两个模块之间会有多个模块。简单起见，我们举个两个直接相互依赖的模块做例子。</p>\n<p><img src="/posts/images/es-modules/cyclic-graph-c.png" alt="循环依赖"></p>\n<p>我们来看看 CommonJS 是如何处理的。</p>\n<p><img src="/posts/images/es-modules/cjs-cycle-c.png" alt="循环依赖"></p>\n<p>首先，JS 引擎会解析 <code>require</code> 语句，接着解析 Counter 模块。Counter 模块此时会尝试获取 <code>message</code> 的值。因为 Main 模块还没有求值，此时 <code>message</code> 的值是 undefined。JS 引擎会在内存中为这个变量分配内存，然后将值置为 undefined。</p>\n<p><img src="/posts/images/es-modules/cjs-variable-2-c.png" alt="CJS 变量"></p>\n<p>之后，JS 引擎执行完 Counter 模块的顶层代码，恢复执行 Main 模块的顶层代码。为了检验 Counter 是否拿到了正确的 <code>message</code> 的值，我们在代码中加了一个 <code>setTimeout</code>。</p>\n<p><img src="/posts/images/es-modules/cjs-variable-3-c.png" alt="CJS 变量"></p>\n<p>在对 Main 模块进行求值的时候，<code>message</code> 得到了值，写入内存。但是因为两个模块的导入导出之间没有建立连接，Counter 模块中的 <code>message</code> 还是 undefined。</p>\n<p>ES 模块的实时绑定机制就可以有效解决这个问题。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-05",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/deep-dive-into-es-module.html",pathLocale:"/",permalink:"/posts/2021/08/05/deep-dive-into-es-module.html",slug:"deep-dive-into-es-module",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/deep-dive-into-es-module.md",filePathRelative:"posts/deep-dive-into-es-module.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/05/deep-dive-into-es-module.html.vue",componentFilePathRelative:"pages/posts/2021/08/05/deep-dive-into-es-module.html.vue",componentFileChunkName:"v-0bf56d7a",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/05/deep-dive-into-es-module.html.js",dataFilePathRelative:"pages/posts/2021/08/05/deep-dive-into-es-module.html.js",dataFileChunkName:"v-0bf56d7a",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/08/05/deep-dive-into-es-module.html",htmlFilePathRelative:"posts/2021/08/05/deep-dive-into-es-module.html"},{key:"v-bf5b33d2",path:"/posts/2022/01/21/esm-in-browser-and-nodejs.html",title:"在浏览器和 NodeJS 中使用 ES Module",lang:"zh-CN",frontmatter:{title:"在浏览器和 NodeJS 中使用 ES Module",description:"ES Module 正在被各大浏览器和 NodeJS 原生支持。本文叙述如何正确地在浏览器和 NodeJS 中使用 ES Module。",keywords:["ES Module"],date:"2022-01-21T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"在浏览器中使用",slug:"在浏览器中使用",children:[]},{level:2,title:"在 NodeJS 中使用",slug:"在-nodejs-中使用",children:[{level:3,title:"exports",slug:"exports",children:[]},{level:3,title:"imports",slug:"imports",children:[]}]},{level:2,title:"小结",slug:"小结",children:[]}],content:'\n前面我们在[深入理解 ES Module](./deep-dive-into-es-module.md) 中详细介绍过 ES Module 的工作原理。目前，ES Module 已经在逐步得到各大浏览器厂商以及 NodeJS 的原生支持。像 vite 等新一代的构建工具已经逐步使用 ES Module 并有计划的运用到生产环境中。因此，了解如何在浏览器以及 NodeJS 中使用 ES Module 是必要的。\n\n## 在浏览器中使用\n\n支持 ES Module 的浏览器通过 script 标签上的 `type` 字段来识别 ES Module，即 `type=module` 就是 ES Module。\n\n```html\n<script type="module">\n  import { foo } from \'bar\';\n  export default foo;\n<\/script>\n<script type="module" src="/path/to/script"><\/script>\n```\n\n浏览器在遇到 `type=module` 的 script 标签时，会将其作为 ES Module 来解析，如果有依赖模块时，会递归的加载依赖模块。模块加载原理与 Webpack 是类似的。\n\n现在问题来了，浏览器如何加载模块呢？\n\n有三种主要方式：\n\n* 绝对路径，比如 `http://domain.com/path/to/module`\n* 相对路径，比如：`./path/to/module`\n* 包名（裸说明符，bare specifier），比如： `lodash-es`\n\n绝对路径和相对路径都很好理解，与普通的 script 用法是一样的。直接使用包名浏览器如何处理呢？\n\n我们在使用 Webpack 等打包器的时候，项目依赖的模块是安装在 node_modules 目录下的。在打包器执行构建的时候，会从 node_modules 中查询依赖的包，找到对应的模块，最终将模块代码合并到最终的构建输出文件中。\n\n在浏览器中，其实是一样的，只不过我们要告诉浏览器去哪里找这些包。目前有一个规范（草案阶段）给出了解决方案，那就是 [`import-map`](https://wicg.github.io/import-maps/)。我们简单说明一下。\n\n```html\n<script type="importmap">\n{\n  "imports": {\n    "moment": "/node_modules/moment/src/moment.js",\n    "lodash": "/node_modules/lodash-es/lodash.js",\n  }\n}\n<\/script>\n```\n\n通过 `type=importmap` 的 script 标签，来告诉浏览器可以在哪里找到这些模块。\n\n![import-map 的浏览器支持情况](/posts/images/esm-in-browser-and-nodejs/import-map-caniuse-c.png)\n\n从 [caniuse](https://caniuse.com/?search=import-map) 上看，目前主流浏览器对 `import-map` 的支持不一，因此，我们还不能在浏览器中直接使用。\n\n现在常规的做法还是经一道打包器的处理，将依赖的模块都打到最终的构建输出中（代码依然是 ES Module）。\n\n## 在 NodeJS 中使用\n\nNodeJS 有三种方式来识别 ES Module，分别是：\n\n* 以 `.mjs` 后缀结尾的文件。\n* 以 `.js` 后缀结尾的文件，但是所在包 `package.json` 中设置了 `type` 字段并且值为 `module`。\n* 命令行中指定了 `--input-type=module` 参数\n\n除了命令行以外，NodeJS 在处理 ES Module 的时候，都与 `package.json` 中的字段有关，这里详细说明下。\n\n`package.json` 中与模块处理的字段主要有如下几个。\n\n* `name` 包的名称，可以与 `imports` 和 `exports` 配合使用\n* `main` 包的默认导出模块\n* `type` 用于在加载 `.js` 文件时确定模块类型\n* `exports` 指定包导出了哪些模块\n* `imports` 包导入了哪些模块，只供包内部使用\n\n`main` 字段指定包的默认导出模块，在所有 NodeJS 版本中都适用。同时，`exports` 字段也可以定义包的入口点，而且除了 `exports` 定义的入口点以外，包内的其他模块将对外不可见，即 `exports` 同时还提供了一定的封装特性。\n\n当 `main` 和 `exports` 同时定义的时候，`exports` 的优先级比 `main` 更高，即 NodeJS 会忽略 `main` 中的定义。\n\n### exports\n\n`exports` 字段定义了包导出的模块，有这么几种定义方式，我们分别说明。\n\n#### `.` 导出\n\n```json\n{\n  "exports": {\n    ".": "./lib/index.js"\n  }\n}\n```\n\n`.` 导出定义了包的默认导出模块，即 `import xxx from \'package\'` 的导出模块。\n\n如果 `.` 不与其他导出一同使用的话（就像上面的样例一样），可以简写为：\n\n```json\n{\n  "exports": "./lib/index.js"\n}\n```\n\n#### 子路径导出\n\n```json\n{\n  "exports": {\n    "./lib": "./lib/index.js"\n  }\n}\n```\n\n上面的例子定义了 `import xxx from \'package/lib\'` 导出的模块。当然，如果我们想将 `./lib` 目录下的所有的模块不受限制的导出的话，可以这么设置：\n\n```json\n{\n  "exports": {\n    "./lib/*": "./lib/*.js",\n  }\n}\n```\n路径中的 `*` 只做字符串替换，即 `import xxx from \'package/lib/a/b/c.js\'` 将会最终被定位到 `./node_modules/package/lib/a/b/c.js`。\n\n> `exports` 中的 `./lib` 等都是相对于包的根目录而言，且子路径导出都需要以 `./` 开头。\n\n如果我们想禁止 `./lib` 目录下的某些模块被外部使用，同时又想通过 `*` 的方式导出模块，我们可以显式的将某一个目录导出设置为 `null`，如下。\n\n```json\n{\n  "exports": {\n     "./lib/*": "./lib/*.js",\n    "./lib/private-internal/*": null\n  },\n}\n```\n\n#### 条件导出\n\n```json\n{\n  "main": "./main-require.cjs",\n  "exports": {\n    "import": "./main-module.js",\n    "require": "./main-require.cjs"\n  },\n  "type": "module"\n}\n```\n\n条件导出支持的条件如下：\n\n* `node` NodeJS 环境下适用，既可以是 ES Module 文件，也可以是 CommonJS 文件，通常不需要显式指定。\n* `node-addons` 与 `node` 类似，用于 NodeJS 插件。\n* `import` 当通过 `import` 或者 `import()` 方式加载模块时使用，与 `require` 互斥。\n* `require` 当通过 `require()` 方式加载模块时使用，与 `import` 互斥。\n* `default` 兜底方案，目标文件可以为 CommonJS 文件也可以为 ES Module 文件，通常排在最后。\n\n> `exports` 字段中 key 的顺序至关重要，排在前面的优先级更高。因此，排在前面的通常是条件要求最严格的，排在后面的通常是要求最宽泛的。\n\n> 除了上面官方支持的几个条件以外，社区还定义了 `types`、`deno`、`browser`、`development`、`production` 等条件。\n\n子路径导出也支持设置条件，如下：\n\n```json\n{\n  "main": "./main.js",\n  "exports": {\n    ".": "./main.js",\n    "./feature": {\n      "node": "./feature-node.js",\n      "default": "./feature.js"\n    }\n  }\n}\n```\n\n同时，条件导出还支持嵌套，如下，在 `node` 条件下，又区分了 `import` 和 `require` 条件。\n\n```json\n{\n  "main": "./main.js",\n  "exports": {\n    "node": {\n      "import": "./feature-node.mjs",\n      "require": "./feature-node.cjs"\n    },\n    "default": "./feature.mjs"\n  }\n}\n```\n\n我们可以通过如下方式指定条件：\n\n```bash\nnode --conditions=development main.js\n```\n\n**上面介绍了几种模块导出方式，这里需要强调的一点是，`exports` 显示定义了包导出的模块，未在 `exports` 导出的模块，外界不可访问。`exports` 给了包的开发者定义对外 API 的能力。**\n\n\n### imports\n\n我们可以通过 `imports` 定义导入包内模块的快捷方式。`imports` 字段中所有的 key 都需要以 `#` 开头。\n\n```json\n{\n  "imports": {\n    "#dep": {\n      "node": "dep-node-native",\n      "default": "./dep-polyfill.js"\n    }\n  },\n  "dependencies": {\n    "dep-node-native": "^1.0.0"\n  }\n}\n```\n\n与 `exports` 不同的是，`imports` 允许导入包外模块。上面的样例中，在 `node` 条件下，`import \'#dep\'` 会导入 `dep-node-native`，在其他环境中，会导入 `./dep-polyfill.js`。\n\n`imports` 也支持子路径导入，与 `exports` 类似，如下：\n\n```json\n{\n  "imports": {\n    "#internal/*": "./src/internal/*.js"\n  }\n}\n```\n\n效果如下：\n\n```js\nimport internalZ from \'#internal/z\';\n// Loads ./node_modules/es-module-package/src/internal/z.js\n```\n\n## 小结\n\n本文介绍了如何在浏览器和 NodeJS 中使用 ES Module 的方法。\n\n如果你只是单纯的做页面开发，借助于成熟的构建工具，可能不太需要注意这些细节。但是掌握了基本原理，可以更好的帮助我们排查问题。\n\n如果你是包开发者，那么如果想要使用 ES Module 并且想让包的使用者也能享受到 ES Module 的优点的话，就需要对模块的导入导出非常熟悉了。\n',contentRendered:'<p>前面我们在<RouterLink to="/posts/deep-dive-into-es-module.html">深入理解 ES Module</RouterLink> 中详细介绍过 ES Module 的工作原理。目前，ES Module 已经在逐步得到各大浏览器厂商以及 NodeJS 的原生支持。像 vite 等新一代的构建工具已经逐步使用 ES Module 并有计划的运用到生产环境中。因此，了解如何在浏览器以及 NodeJS 中使用 ES Module 是必要的。</p>\n<h2 id="在浏览器中使用" tabindex="-1"><a class="header-anchor" href="#在浏览器中使用" aria-hidden="true">#</a> 在浏览器中使用</h2>\n<p>支持 ES Module 的浏览器通过 script 标签上的 <code>type</code> 字段来识别 ES Module，即 <code>type=module</code> 就是 ES Module。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'bar\'</span><span class="token punctuation">;</span>\n  <span class="token keyword">export</span> <span class="token keyword">default</span> foo<span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/path/to/script<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>浏览器在遇到 <code>type=module</code> 的 script 标签时，会将其作为 ES Module 来解析，如果有依赖模块时，会递归的加载依赖模块。模块加载原理与 Webpack 是类似的。</p>\n<p>现在问题来了，浏览器如何加载模块呢？</p>\n<p>有三种主要方式：</p>\n<ul>\n<li>绝对路径，比如 <code>http://domain.com/path/to/module</code></li>\n<li>相对路径，比如：<code>./path/to/module</code></li>\n<li>包名（裸说明符，bare specifier），比如： <code>lodash-es</code></li>\n</ul>\n<p>绝对路径和相对路径都很好理解，与普通的 script 用法是一样的。直接使用包名浏览器如何处理呢？</p>\n<p>我们在使用 Webpack 等打包器的时候，项目依赖的模块是安装在 node_modules 目录下的。在打包器执行构建的时候，会从 node_modules 中查询依赖的包，找到对应的模块，最终将模块代码合并到最终的构建输出文件中。</p>\n<p>在浏览器中，其实是一样的，只不过我们要告诉浏览器去哪里找这些包。目前有一个规范（草案阶段）给出了解决方案，那就是 <a href="https://wicg.github.io/import-maps/" target="_blank" rel="noopener noreferrer"><code>import-map</code><OutboundLink/></a>。我们简单说明一下。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>importmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token punctuation">{</span>\n  <span class="token string">"imports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"moment"</span><span class="token operator">:</span> <span class="token string">"/node_modules/moment/src/moment.js"</span><span class="token punctuation">,</span>\n    <span class="token string">"lodash"</span><span class="token operator">:</span> <span class="token string">"/node_modules/lodash-es/lodash.js"</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>通过 <code>type=importmap</code> 的 script 标签，来告诉浏览器可以在哪里找到这些模块。</p>\n<p><img src="/posts/images/esm-in-browser-and-nodejs/import-map-caniuse-c.png" alt="import-map 的浏览器支持情况"></p>\n<p>从 <a href="https://caniuse.com/?search=import-map" target="_blank" rel="noopener noreferrer">caniuse<OutboundLink/></a> 上看，目前主流浏览器对 <code>import-map</code> 的支持不一，因此，我们还不能在浏览器中直接使用。</p>\n<p>现在常规的做法还是经一道打包器的处理，将依赖的模块都打到最终的构建输出中（代码依然是 ES Module）。</p>\n<h2 id="在-nodejs-中使用" tabindex="-1"><a class="header-anchor" href="#在-nodejs-中使用" aria-hidden="true">#</a> 在 NodeJS 中使用</h2>\n<p>NodeJS 有三种方式来识别 ES Module，分别是：</p>\n<ul>\n<li>以 <code>.mjs</code> 后缀结尾的文件。</li>\n<li>以 <code>.js</code> 后缀结尾的文件，但是所在包 <code>package.json</code> 中设置了 <code>type</code> 字段并且值为 <code>module</code>。</li>\n<li>命令行中指定了 <code>--input-type=module</code> 参数</li>\n</ul>\n<p>除了命令行以外，NodeJS 在处理 ES Module 的时候，都与 <code>package.json</code> 中的字段有关，这里详细说明下。</p>\n<p><code>package.json</code> 中与模块处理的字段主要有如下几个。</p>\n<ul>\n<li><code>name</code> 包的名称，可以与 <code>imports</code> 和 <code>exports</code> 配合使用</li>\n<li><code>main</code> 包的默认导出模块</li>\n<li><code>type</code> 用于在加载 <code>.js</code> 文件时确定模块类型</li>\n<li><code>exports</code> 指定包导出了哪些模块</li>\n<li><code>imports</code> 包导入了哪些模块，只供包内部使用</li>\n</ul>\n<p><code>main</code> 字段指定包的默认导出模块，在所有 NodeJS 版本中都适用。同时，<code>exports</code> 字段也可以定义包的入口点，而且除了 <code>exports</code> 定义的入口点以外，包内的其他模块将对外不可见，即 <code>exports</code> 同时还提供了一定的封装特性。</p>\n<p>当 <code>main</code> 和 <code>exports</code> 同时定义的时候，<code>exports</code> 的优先级比 <code>main</code> 更高，即 NodeJS 会忽略 <code>main</code> 中的定义。</p>\n<h3 id="exports" tabindex="-1"><a class="header-anchor" href="#exports" aria-hidden="true">#</a> exports</h3>\n<p><code>exports</code> 字段定义了包导出的模块，有这么几种定义方式，我们分别说明。</p>\n<h4 id="导出" tabindex="-1"><a class="header-anchor" href="#导出" aria-hidden="true">#</a> <code>.</code> 导出</h4>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"."</span><span class="token operator">:</span> <span class="token string">"./lib/index.js"</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>.</code> 导出定义了包的默认导出模块，即 <code>import xxx from \'package\'</code> 的导出模块。</p>\n<p>如果 <code>.</code> 不与其他导出一同使用的话（就像上面的样例一样），可以简写为：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token string">"./lib/index.js"</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="子路径导出" tabindex="-1"><a class="header-anchor" href="#子路径导出" aria-hidden="true">#</a> 子路径导出</h4>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"./lib"</span><span class="token operator">:</span> <span class="token string">"./lib/index.js"</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面的例子定义了 <code>import xxx from \'package/lib\'</code> 导出的模块。当然，如果我们想将 <code>./lib</code> 目录下的所有的模块不受限制的导出的话，可以这么设置：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"./lib/*"</span><span class="token operator">:</span> <span class="token string">"./lib/*.js"</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>路径中的 <code>*</code> 只做字符串替换，即 <code>import xxx from \'package/lib/a/b/c.js\'</code> 将会最终被定位到 <code>./node_modules/package/lib/a/b/c.js</code>。</p>\n<blockquote>\n<p><code>exports</code> 中的 <code>./lib</code> 等都是相对于包的根目录而言，且子路径导出都需要以 <code>./</code> 开头。</p>\n</blockquote>\n<p>如果我们想禁止 <code>./lib</code> 目录下的某些模块被外部使用，同时又想通过 <code>*</code> 的方式导出模块，我们可以显式的将某一个目录导出设置为 <code>null</code>，如下。</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n     <span class="token property">"./lib/*"</span><span class="token operator">:</span> <span class="token string">"./lib/*.js"</span><span class="token punctuation">,</span>\n    <span class="token property">"./lib/private-internal/*"</span><span class="token operator">:</span> <span class="token null keyword">null</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="条件导出" tabindex="-1"><a class="header-anchor" href="#条件导出" aria-hidden="true">#</a> 条件导出</h4>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"./main-require.cjs"</span><span class="token punctuation">,</span>\n  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./main-module.js"</span><span class="token punctuation">,</span>\n    <span class="token property">"require"</span><span class="token operator">:</span> <span class="token string">"./main-require.cjs"</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"module"</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>条件导出支持的条件如下：</p>\n<ul>\n<li><code>node</code> NodeJS 环境下适用，既可以是 ES Module 文件，也可以是 CommonJS 文件，通常不需要显式指定。</li>\n<li><code>node-addons</code> 与 <code>node</code> 类似，用于 NodeJS 插件。</li>\n<li><code>import</code> 当通过 <code>import</code> 或者 <code>import()</code> 方式加载模块时使用，与 <code>require</code> 互斥。</li>\n<li><code>require</code> 当通过 <code>require()</code> 方式加载模块时使用，与 <code>import</code> 互斥。</li>\n<li><code>default</code> 兜底方案，目标文件可以为 CommonJS 文件也可以为 ES Module 文件，通常排在最后。</li>\n</ul>\n<blockquote>\n<p><code>exports</code> 字段中 key 的顺序至关重要，排在前面的优先级更高。因此，排在前面的通常是条件要求最严格的，排在后面的通常是要求最宽泛的。</p>\n</blockquote>\n<blockquote>\n<p>除了上面官方支持的几个条件以外，社区还定义了 <code>types</code>、<code>deno</code>、<code>browser</code>、<code>development</code>、<code>production</code> 等条件。</p>\n</blockquote>\n<p>子路径导出也支持设置条件，如下：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"./main.js"</span><span class="token punctuation">,</span>\n  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"."</span><span class="token operator">:</span> <span class="token string">"./main.js"</span><span class="token punctuation">,</span>\n    <span class="token property">"./feature"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"node"</span><span class="token operator">:</span> <span class="token string">"./feature-node.js"</span><span class="token punctuation">,</span>\n      <span class="token property">"default"</span><span class="token operator">:</span> <span class="token string">"./feature.js"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>同时，条件导出还支持嵌套，如下，在 <code>node</code> 条件下，又区分了 <code>import</code> 和 <code>require</code> 条件。</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"./main.js"</span><span class="token punctuation">,</span>\n  <span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"node"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"import"</span><span class="token operator">:</span> <span class="token string">"./feature-node.mjs"</span><span class="token punctuation">,</span>\n      <span class="token property">"require"</span><span class="token operator">:</span> <span class="token string">"./feature-node.cjs"</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token property">"default"</span><span class="token operator">:</span> <span class="token string">"./feature.mjs"</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们可以通过如下方式指定条件：</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>node --conditions<span class="token operator">=</span>development main.js\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>上面介绍了几种模块导出方式，这里需要强调的一点是，<code>exports</code> 显示定义了包导出的模块，未在 <code>exports</code> 导出的模块，外界不可访问。<code>exports</code> 给了包的开发者定义对外 API 的能力。</strong></p>\n<h3 id="imports" tabindex="-1"><a class="header-anchor" href="#imports" aria-hidden="true">#</a> imports</h3>\n<p>我们可以通过 <code>imports</code> 定义导入包内模块的快捷方式。<code>imports</code> 字段中所有的 key 都需要以 <code>#</code> 开头。</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"imports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"#dep"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">"node"</span><span class="token operator">:</span> <span class="token string">"dep-node-native"</span><span class="token punctuation">,</span>\n      <span class="token property">"default"</span><span class="token operator">:</span> <span class="token string">"./dep-polyfill.js"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"dep-node-native"</span><span class="token operator">:</span> <span class="token string">"^1.0.0"</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>与 <code>exports</code> 不同的是，<code>imports</code> 允许导入包外模块。上面的样例中，在 <code>node</code> 条件下，<code>import \'#dep\'</code> 会导入 <code>dep-node-native</code>，在其他环境中，会导入 <code>./dep-polyfill.js</code>。</p>\n<p><code>imports</code> 也支持子路径导入，与 <code>exports</code> 类似，如下：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"imports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">"#internal/*"</span><span class="token operator">:</span> <span class="token string">"./src/internal/*.js"</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>效果如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> internalZ <span class="token keyword">from</span> <span class="token string">\'#internal/z\'</span><span class="token punctuation">;</span>\n<span class="token comment">// Loads ./node_modules/es-module-package/src/internal/z.js</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>本文介绍了如何在浏览器和 NodeJS 中使用 ES Module 的方法。</p>\n<p>如果你只是单纯的做页面开发，借助于成熟的构建工具，可能不太需要注意这些细节。但是掌握了基本原理，可以更好的帮助我们排查问题。</p>\n<p>如果你是包开发者，那么如果想要使用 ES Module 并且想让包的使用者也能享受到 ES Module 的优点的话，就需要对模块的导入导出非常熟悉了。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-01-21",deps:[],hoistedTags:[],links:[{raw:"./deep-dive-into-es-module.md",relative:"posts/deep-dive-into-es-module.md",absolute:"/posts/deep-dive-into-es-module.md"}],pathInferred:"/posts/esm-in-browser-and-nodejs.html",pathLocale:"/",permalink:"/posts/2022/01/21/esm-in-browser-and-nodejs.html",slug:"esm-in-browser-and-nodejs",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/esm-in-browser-and-nodejs.md",filePathRelative:"posts/esm-in-browser-and-nodejs.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/01/21/esm-in-browser-and-nodejs.html.vue",componentFilePathRelative:"pages/posts/2022/01/21/esm-in-browser-and-nodejs.html.vue",componentFileChunkName:"v-bf5b33d2",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/01/21/esm-in-browser-and-nodejs.html.js",dataFilePathRelative:"pages/posts/2022/01/21/esm-in-browser-and-nodejs.html.js",dataFileChunkName:"v-bf5b33d2",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2022/01/21/esm-in-browser-and-nodejs.html",htmlFilePathRelative:"posts/2022/01/21/esm-in-browser-and-nodejs.html"},{key:"v-2665f526",path:"/posts/2022/11/05/eval.html",title:"正确使用 eval 从这篇开始",lang:"zh-CN",frontmatter:{title:"正确使用 eval 从这篇开始",description:"eval 直接调用和间接调用的区别",keywords:["eval","direct call","indirect call"],date:"2022-11-05T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"直接调用",slug:"直接调用",children:[]},{level:2,title:"间接调用",slug:"间接调用",children:[]},{level:2,title:"微前端中的使用",slug:"微前端中的使用",children:[]}],content:"\n`eval` 这个函数前端同学应该都见过，却很少使用过，甚至因为其存在一定的安全隐患而在很多编码规范中被禁止使用。笔者最近在看一些开源框架源码的时候，发现 `eval` 因其一个特点在一些场景中起到了非常关键的作用。因此，本文对 `eval` 的这一特点进行介绍。\n\n首先我们来 `eval` 函数的定义：\n\n> The `eval()` function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.\n\n意思是说，`eval` 函数会将传给它的字符串作为 JavaScript 代码来执行，并将执行完成时的值作为返回值返回。比如 `eval('1 + 1')` 返回 `2`。\n\n根据规范中的定义，`eval` 函数在执行代码的时候，代码的作用域与调用 `eval` 的作用域有关。比如在下面的代码，最终获取的结果是内部的 `x` 的值。\n\n```js\n var x = 'outer';\n  (function() {\n    var x = 'inner';\n    eval('x'); // \"inner\"\n  })();\n```\n\n那么，这个看着平平无奇，而且使用不当还有一丝安全风险的 `eval` 到底有什么特点呢？\n\n## 直接调用\n\n所谓直接调用，规范中是这么定义的：\n\n> A direct call to the eval function is one that is expressed as a CallExpression that meets the following two conditions:\nThe Reference that is the result of evaluating the MemberExpression in the CallExpression has an environment record as its base value and its reference name is \"eval\".\nThe result of calling the abstract operation GetValue with that Reference as the argument is the standard builtin function defined in 15.1.2.1.\n\n这里有两个名词需要先解释下，`CallExpression` 和 `MemberExpression`，这是 JavaScript 语法中的两种表达式类型。这里为了简便起见，我们可以这么理解，`CallExpression` 可以理解成函数调用表达式，而 `MemberExpression` 就是括号左边的表达式。详细说明可以参考[规范](https://262.ecma-international.org/5.1/#sec-11.2)中的定义。\n\n现在我们来看直接调用的定义。所谓直接调用，就是同时满足如下两个条件的函数调用表达式：\n\n* 括号左边的表达式的结果是一个**引用**，同时这个引用的值是内置原生的 \"eval\" 函数\n* 这个应用的名称是 \"eval\"\n\n注意，这里“引用”两个字被加粗了，这是判断是否是直接调用的关键，后面在间接调用的说明中我们会详细说明。\n\n下面这些都是直接调用。\n\n```js\neval('...')\n(eval)('...')\n(((eval)))('...')\n(function() { return eval('...') })()\neval('eval(\"...\")')\n(function(eval) { return eval('...'); })(eval)\nwith({ eval: eval }) eval('...')\nwith(window) eval('...')\n```\n\n直接调用的时候，代码的作用域与调用所在的作用域有关。这是符合规范定义的。\n\n## 间接调用\n\n简单来说，不是直接调用的都是间接调用。\n\n如下的例子就都是间接调用。\n\n```js\nconst func = eval;\nfunc('1 + 1');\n\n(0, eval)(...)\n\neval = (function(eval) {\n  return function(expr) {\n    return eval(expr);\n  };\n})(eval);\neval('1+1');\n```\n\n眼尖的同学可能会问，为什么 `(0, eval)(...)` 是间接引用，而`(eval)(...)` 是直接调用呢？这就要回到被加粗的“引用”二字上来。\n\n规范中定义，左侧表达式的结果必须是引用，不能是值。`(0, eval)(...)` 左边是逗号表达式，最终要返回一个值，即 `eval` 的值。`(eval)(...)` 左侧是括号（分组）表达式，不求值，因此结果还是引用。同理，`(((eval)))(...)` 依然是直接引用。\n\n**间接调用，执行代码的作用域是全局作用域。**\n\n## 微前端中的使用\n\n讨论了直接调用和间接调用，我们知道，间接调用的时候，执行代码的作用域是全局作用域。这在微前端场景下就起到了非常关键的作用。\n\n微前端的主应用需要将子应用运行起来，就需要执行子应用的代码。为了避免主应用代码的作用域影响到子应用的运行，需要保证子应用的代码是在全局作用域运行的。这就需要使用到 `eval` 的间接调用的特性。\n\n同时为了做好沙箱隔离，通常在微前端中会借助各种方式来对 `window` 等全局变量做一个保护，比如通过 `proxy` 来处理。\n\n下面是一段运行子应用的伪代码，简单示意一下处理流程。\n\n```js\nconst scriptText = fetch('https://path/to/subapp/code.js'); // 子应用代码\n\nconst globalWindow = (0, eval)('window'); // 获取全局的 window 对象\nglobalWindow.proxy = proxy; // 此处的 proxy 是经过处理后的沙箱。\n\n// 将沙箱作为子应用的 window 来使用\nconst wrappedCode = `;(function(window, self, globalThis){;${scriptText}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`\n\n(0, eval)(wrappedCode); // 执行代码\n```\n\n笔者查看了目前主流的几个微前端框架，不管是 [qiankun](https://github.com/umijs/qiankun) 还是 [garfish](https://github.com/modern-js-dev/garfish)，运行子应用代码都是通过 `eval` 的间接调用来完成的。\n",contentRendered:'<p><code>eval</code> 这个函数前端同学应该都见过，却很少使用过，甚至因为其存在一定的安全隐患而在很多编码规范中被禁止使用。笔者最近在看一些开源框架源码的时候，发现 <code>eval</code> 因其一个特点在一些场景中起到了非常关键的作用。因此，本文对 <code>eval</code> 的这一特点进行介绍。</p>\n<p>首先我们来 <code>eval</code> 函数的定义：</p>\n<blockquote>\n<p>The <code>eval()</code> function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.</p>\n</blockquote>\n<p>意思是说，<code>eval</code> 函数会将传给它的字符串作为 JavaScript 代码来执行，并将执行完成时的值作为返回值返回。比如 <code>eval(\'1 + 1\')</code> 返回 <code>2</code>。</p>\n<p>根据规范中的定义，<code>eval</code> 函数在执行代码的时候，代码的作用域与调用 <code>eval</code> 的作用域有关。比如在下面的代码，最终获取的结果是内部的 <code>x</code> 的值。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code> <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">\'outer\'</span><span class="token punctuation">;</span>\n  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">\'inner\'</span><span class="token punctuation">;</span>\n    <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">\'x\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "inner"</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>那么，这个看着平平无奇，而且使用不当还有一丝安全风险的 <code>eval</code> 到底有什么特点呢？</p>\n<h2 id="直接调用" tabindex="-1"><a class="header-anchor" href="#直接调用" aria-hidden="true">#</a> 直接调用</h2>\n<p>所谓直接调用，规范中是这么定义的：</p>\n<blockquote>\n<p>A direct call to the eval function is one that is expressed as a CallExpression that meets the following two conditions:\nThe Reference that is the result of evaluating the MemberExpression in the CallExpression has an environment record as its base value and its reference name is &quot;eval&quot;.\nThe result of calling the abstract operation GetValue with that Reference as the argument is the standard builtin function defined in 15.1.2.1.</p>\n</blockquote>\n<p>这里有两个名词需要先解释下，<code>CallExpression</code> 和 <code>MemberExpression</code>，这是 JavaScript 语法中的两种表达式类型。这里为了简便起见，我们可以这么理解，<code>CallExpression</code> 可以理解成函数调用表达式，而 <code>MemberExpression</code> 就是括号左边的表达式。详细说明可以参考<a href="https://262.ecma-international.org/5.1/#sec-11.2" target="_blank" rel="noopener noreferrer">规范<OutboundLink/></a>中的定义。</p>\n<p>现在我们来看直接调用的定义。所谓直接调用，就是同时满足如下两个条件的函数调用表达式：</p>\n<ul>\n<li>括号左边的表达式的结果是一个<strong>引用</strong>，同时这个引用的值是内置原生的 &quot;eval&quot; 函数</li>\n<li>这个应用的名称是 &quot;eval&quot;</li>\n</ul>\n<p>注意，这里“引用”两个字被加粗了，这是判断是否是直接调用的关键，后面在间接调用的说明中我们会详细说明。</p>\n<p>下面这些都是直接调用。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">\'...\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">(</span>eval<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">\'...\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>eval<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">\'...\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">\'...\'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">\'eval("...")\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">eval</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">\'...\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>eval<span class="token punctuation">)</span>\n<span class="token keyword">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> eval<span class="token operator">:</span> eval <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">\'...\'</span><span class="token punctuation">)</span>\n<span class="token keyword">with</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">\'...\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>直接调用的时候，代码的作用域与调用所在的作用域有关。这是符合规范定义的。</p>\n<h2 id="间接调用" tabindex="-1"><a class="header-anchor" href="#间接调用" aria-hidden="true">#</a> 间接调用</h2>\n<p>简单来说，不是直接调用的都是间接调用。</p>\n<p>如下的例子就都是间接调用。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> func <span class="token operator">=</span> eval<span class="token punctuation">;</span>\n<span class="token function">func</span><span class="token punctuation">(</span><span class="token string">\'1 + 1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> eval<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>\n\neval <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">eval</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">expr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">eval</span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>eval<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">\'1+1\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>眼尖的同学可能会问，为什么 <code>(0, eval)(...)</code> 是间接引用，而<code>(eval)(...)</code> 是直接调用呢？这就要回到被加粗的“引用”二字上来。</p>\n<p>规范中定义，左侧表达式的结果必须是引用，不能是值。<code>(0, eval)(...)</code> 左边是逗号表达式，最终要返回一个值，即 <code>eval</code> 的值。<code>(eval)(...)</code> 左侧是括号（分组）表达式，不求值，因此结果还是引用。同理，<code>(((eval)))(...)</code> 依然是直接引用。</p>\n<p><strong>间接调用，执行代码的作用域是全局作用域。</strong></p>\n<h2 id="微前端中的使用" tabindex="-1"><a class="header-anchor" href="#微前端中的使用" aria-hidden="true">#</a> 微前端中的使用</h2>\n<p>讨论了直接调用和间接调用，我们知道，间接调用的时候，执行代码的作用域是全局作用域。这在微前端场景下就起到了非常关键的作用。</p>\n<p>微前端的主应用需要将子应用运行起来，就需要执行子应用的代码。为了避免主应用代码的作用域影响到子应用的运行，需要保证子应用的代码是在全局作用域运行的。这就需要使用到 <code>eval</code> 的间接调用的特性。</p>\n<p>同时为了做好沙箱隔离，通常在微前端中会借助各种方式来对 <code>window</code> 等全局变量做一个保护，比如通过 <code>proxy</code> 来处理。</p>\n<p>下面是一段运行子应用的伪代码，简单示意一下处理流程。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> scriptText <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'https://path/to/subapp/code.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 子应用代码</span>\n\n<span class="token keyword">const</span> globalWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> eval<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">\'window\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取全局的 window 对象</span>\nglobalWindow<span class="token punctuation">.</span>proxy <span class="token operator">=</span> proxy<span class="token punctuation">;</span> <span class="token comment">// 此处的 proxy 是经过处理后的沙箱。</span>\n\n<span class="token comment">// 将沙箱作为子应用的 window 来使用</span>\n<span class="token keyword">const</span> wrappedCode <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">;(function(window, self, globalThis){;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>scriptText<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);</span><span class="token template-punctuation string">`</span></span>\n\n<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> eval<span class="token punctuation">)</span><span class="token punctuation">(</span>wrappedCode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行代码</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>笔者查看了目前主流的几个微前端框架，不管是 <a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener noreferrer">qiankun<OutboundLink/></a> 还是 <a href="https://github.com/modern-js-dev/garfish" target="_blank" rel="noopener noreferrer">garfish<OutboundLink/></a>，运行子应用代码都是通过 <code>eval</code> 的间接调用来完成的。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-11-05",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/eval.html",pathLocale:"/",permalink:"/posts/2022/11/05/eval.html",slug:"eval",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/eval.md",filePathRelative:"posts/eval.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/11/05/eval.html.vue",componentFilePathRelative:"pages/posts/2022/11/05/eval.html.vue",componentFileChunkName:"v-2665f526",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/11/05/eval.html.js",dataFilePathRelative:"pages/posts/2022/11/05/eval.html.js",dataFileChunkName:"v-2665f526",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2022/11/05/eval.html",htmlFilePathRelative:"posts/2022/11/05/eval.html"},{key:"v-b40eab24",path:"/posts/2021/07/12/export-default.html",title:"export default A 与 export { A as default } 的不同",lang:"zh-CN",frontmatter:{title:"export default A 与 export { A as default } 的不同",description:"描述 export default A 与 export { A as default } 的不同",keywords:["export default"],date:"2021-07-12T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"import 语句导入的是引用，不是值",slug:"import-语句导入的是引用-不是值",children:[]},{level:2,title:"export default",slug:"export-default",children:[]},{level:2,title:"export { A as default }",slug:"export-a-as-default",children:[]},{level:2,title:"export default function",slug:"export-default-function",children:[]}],content:"\n`export default A` 和 `export { A as default }` 乍一看是一样的，但是里面有一些细微的区别比较容易留坑。本文介绍两种写法的不同之处。\n\n## `import` 语句导入的是引用，不是值\n\n有导出就必然有导入，我们先明确下 `import` 语句的工作原理。\n\n```js\nimport { A } from './module.js';\n```\n\n显而易见，在上面的代码中，`A` 和 `./module.js` 中的 A 是相同的。再看这段代码：\n\n```js\nconst module = await import('./module.js');\nconst { A: destructuredA } = await import('./module.js');\n```\n\n在这段代码中，`module.A` 与 `A` 是相同的，但是因为 `destructuredA` 是结构赋值，因此就有一些不同了。\n\n我们来看下 `./module.js`：\n\n```js\n// module.js\nexport let A = 'initial';\n\nsetTimeout(() => {\n  A = 'changed';\n}, 500);\n```\n\n导入 `./module.js` 的代码为 `./main.js`：\n\n```js\n// main.js\nimport { A as importedA } from './module.js';\nconst module = await import('./module.js');\nlet { A } = await import('./module.js');\n\nsetTimeout(() => {\n  console.log(importedA); // \"changed\"\n  console.log(module.A); // \"changed\"\n  console.log(A); // \"initial\"\n}, 1000);\n```\n\n`import` 语句导入的是引用，也就是说，当 `./module.js` 中 `A` 的值发生变化的时候，`./main.js` 中也会跟着变化。解构赋值获得的 `A` 不会变化是因为解构过程中是使用的值赋值给了新变量，而不是引用。\n\n值得注意的是，静态语句 `import { A } ...` 虽然看着像解构赋值，实际上与解构赋值并不相同。\n\n小结一下：\n\n```js\n// 以下代码获得是引用\nimport { A } from './module.js';\nimport { A as otherName } from './module.js';\nimport * as module from './module.js';\nconst module = await import('./module.js');\n// 以下代码获得的是值\nlet { A } = await import('./module.js');\n```\n\n## `export default`\n\n我们修改下 `./module.js`：\n\n```js\n// module.js\nlet A = 'initial';\n\nexport { A };\nexport default A;\n\nsetTimeout(() => {\n  A = 'changed';\n}, 500);\n```\n\n同时也修改 `./main.js`：\n\n```js\n// main.js\nimport { A, default as defaultA } from './module.js';\nimport anotherDefaultA from './module.js';\n\nsetTimeout(() => {\n  console.log(A); // \"changed\"\n  console.log(defaultA); // \"initial\"\n  console.log(anotherDefaultA); // \"initial\"\n}, 1000);\n```\n\n输出结果是 `\"initial\"`，为什么呢？\n\n我们知道，我们可以直接 `export default 'hello';` 但是却不能 `export { 'hello' as A }`。规范在这两种语法上有一点不同。`export default` 后面的将会被作为表达式对待。因此我们可以 `export default 'hello';`， 甚至可以 `export default 1 + 2;`。因此，在 `export default A` 中，`A` 是作为表达式语句使用的，因此使用的是 A 的值。因此，当 `A` 的值在 `setTimeout` 中被改变的时候，`export default` 出去的值并没有变化。\n\n小结一下：\n\n```js\n// 引用\nimport { A } from './module.js';\nimport { A as otherName } from './module.js';\nimport * as module from './module.js';\nconst module = await import('./module.js');\n// 值\nlet { A } = await import('./module.js');\n\n// 导出引用\nexport { A };\nexport { A as otherName };\n// 导出值\nexport default A;\nexport default 'hello!';\n```\n\n## `export { A as default }`\n\n`export {}` 导出的始终是一个引用，因此：\n\n```js\n// module.js\nlet A = 'initial';\n\nexport { A, A as default };\n\nsetTimeout(() => {\n  A = 'changed';\n}, 500);\n```\n\n同样，在先前的 `./main.js` 中：\n\n```js\n// main.js\nimport { A, default as defaultA } from './module.js';\nimport anotherDefaultA from './module.js';\n\nsetTimeout(() => {\n  console.log(A); // \"changed\"\n  console.log(defaultA); // \"changed\"\n  console.log(anotherDefaultA); // \"changed\"\n}, 1000);\n```\n\n小结下：\n\n```js\n// 导入引用\nimport { A } from './module.js';\nimport { A as otherName } from './module.js';\nimport * as module from './module.js';\nconst module = await import('./module.js');\n// 导入值\nlet { A } = await import('./module.js');\n\n// 导出引用\nexport { A };\nexport { A as otherName };\nexport { A as default };\n// 导出值\nexport default A;\nexport default 'hello!';\n```\n\n## `export default function`\n\n虽然，前面说过 `export default` 后面的会被作为表达式使用。但是也有一些例外：\n\n```js\n// module.js\nexport default function A() {}\n\nsetTimeout(() => {\n  A = 'changed';\n}, 500);\n```\n\n```js\n// main.js\nimport A from './module.js';\n\nsetTimeout(() => {\n  console.log(A); // \"changed\"\n}, 1000);\n```\n\n输出 `\"changed\"`，因为 `export default function` 有其特殊的语法，在这个语法中，函数是作为引用传递的。\n\n我们稍微做一下修改：\n```js\n// module.js\nfunction A() {}\n\nexport default A;\n\nsetTimeout(() => {\n  A = 'changed';\n}, 500);\n```\n\n此时控制台输出 `ƒ A() {}`，`export` 语句不再符合 `export default function` 语法形式，`A` 便使用了值传递。\n\n不仅仅 `export default function`，`export default class` 也是同样的表现。\n\n为什么呢？\n\n原因与这些语句当被用作表达式时的表现有关。\n\n```js\nfunction someFunction() {}\nclass SomeClass {}\n\nconsole.log(typeof someFunction); // \"function\"\nconsole.log(typeof SomeClass); // \"function\"\n```\n\n如果我们将他们变成表达式：\n\n```js\n(function someFunction() {});\n(class SomeClass {});\n\nconsole.log(typeof someFunction); // \"undefined\"\nconsole.log(typeof SomeClass); // \"undefined\"\n```\n\n`function` 和 `class` 语句会在作用域/块中创建标识符，而 `function` 和 `class` 语句却不会，尽管他们的函数名和类名可以被使用。\n\n因此，下面代码中：\n\n```js\nexport default function someFunction() {}\nconsole.log(typeof someFunction); // \"function\"\n```\n\n如果不进行特殊处理的话，输出的将会是 `\"undefined\"`。\n\n小结如下：\n\n```js\n// 导入引用\nimport { A } from './module.js';\nimport { A as otherName } from './module.js';\nimport * as module from './module.js';\nconst module = await import('./module.js');\n// 导入值\nlet { A } = await import('./module.js');\n\n// 导出引用\nexport { A };\nexport { A as otherName };\nexport { A as default };\nexport default function A() {}\n// 导出值\nexport default A;\nexport default 'hello!';\n```\n\n> 在早些时候，模块中的默认导出是这样的 `export default = A`，这样看来，`A` 被当做表达式会更明显一些。\n",contentRendered:'<p><code>export default A</code> 和 <code>export { A as default }</code> 乍一看是一样的，但是里面有一些细微的区别比较容易留坑。本文介绍两种写法的不同之处。</p>\n<h2 id="import-语句导入的是引用-不是值" tabindex="-1"><a class="header-anchor" href="#import-语句导入的是引用-不是值" aria-hidden="true">#</a> <code>import</code> 语句导入的是引用，不是值</h2>\n<p>有导出就必然有导入，我们先明确下 <code>import</code> 语句的工作原理。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>显而易见，在上面的代码中，<code>A</code> 和 <code>./module.js</code> 中的 A 是相同的。再看这段代码：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token constant">A</span><span class="token operator">:</span> destructuredA <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这段代码中，<code>module.A</code> 与 <code>A</code> 是相同的，但是因为 <code>destructuredA</code> 是结构赋值，因此就有一些不同了。</p>\n<p>我们来看下 <code>./module.js</code>：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// module.js</span>\n<span class="token keyword">export</span> <span class="token keyword">let</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token string">\'initial\'</span><span class="token punctuation">;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token string">\'changed\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>导入 <code>./module.js</code> 的代码为 <code>./main.js</code>：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// main.js</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> importedA <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>importedA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "changed"</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "changed"</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "initial"</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>import</code> 语句导入的是引用，也就是说，当 <code>./module.js</code> 中 <code>A</code> 的值发生变化的时候，<code>./main.js</code> 中也会跟着变化。解构赋值获得的 <code>A</code> 不会变化是因为解构过程中是使用的值赋值给了新变量，而不是引用。</p>\n<p>值得注意的是，静态语句 <code>import { A } ...</code> 虽然看着像解构赋值，实际上与解构赋值并不相同。</p>\n<p>小结一下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 以下代码获得是引用</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> otherName <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> module <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 以下代码获得的是值</span>\n<span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="export-default" tabindex="-1"><a class="header-anchor" href="#export-default" aria-hidden="true">#</a> <code>export default</code></h2>\n<p>我们修改下 <code>./module.js</code>：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// module.js</span>\n<span class="token keyword">let</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token string">\'initial\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token constant">A</span><span class="token punctuation">;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token string">\'changed\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>同时也修改 <code>./main.js</code>：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// main.js</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token keyword">default</span> <span class="token keyword">as</span> defaultA <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> anotherDefaultA <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "changed"</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>defaultA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "initial"</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>anotherDefaultA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "initial"</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>输出结果是 <code>&quot;initial&quot;</code>，为什么呢？</p>\n<p>我们知道，我们可以直接 <code>export default \'hello\';</code> 但是却不能 <code>export { \'hello\' as A }</code>。规范在这两种语法上有一点不同。<code>export default</code> 后面的将会被作为表达式对待。因此我们可以 <code>export default \'hello\';</code>， 甚至可以 <code>export default 1 + 2;</code>。因此，在 <code>export default A</code> 中，<code>A</code> 是作为表达式语句使用的，因此使用的是 A 的值。因此，当 <code>A</code> 的值在 <code>setTimeout</code> 中被改变的时候，<code>export default</code> 出去的值并没有变化。</p>\n<p>小结一下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 引用</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> otherName <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> module <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 值</span>\n<span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 导出引用</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> otherName <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token comment">// 导出值</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token constant">A</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">\'hello!\'</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="export-a-as-default" tabindex="-1"><a class="header-anchor" href="#export-a-as-default" aria-hidden="true">#</a> <code>export { A as default }</code></h2>\n<p><code>export {}</code> 导出的始终是一个引用，因此：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// module.js</span>\n<span class="token keyword">let</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token string">\'initial\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">A</span> <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token string">\'changed\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>同样，在先前的 <code>./main.js</code> 中：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// main.js</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token keyword">default</span> <span class="token keyword">as</span> defaultA <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> anotherDefaultA <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "changed"</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>defaultA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "changed"</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>anotherDefaultA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "changed"</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>小结下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 导入引用</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> otherName <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> module <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 导入值</span>\n<span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 导出引用</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> otherName <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token comment">// 导出值</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token constant">A</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">\'hello!\'</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="export-default-function" tabindex="-1"><a class="header-anchor" href="#export-default-function" aria-hidden="true">#</a> <code>export default function</code></h2>\n<p>虽然，前面说过 <code>export default</code> 后面的会被作为表达式使用。但是也有一些例外：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// module.js</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token string">\'changed\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// main.js</span>\n<span class="token keyword">import</span> <span class="token constant">A</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "changed"</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>输出 <code>&quot;changed&quot;</code>，因为 <code>export default function</code> 有其特殊的语法，在这个语法中，函数是作为引用传递的。</p>\n<p>我们稍微做一下修改：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// module.js</span>\n<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token constant">A</span><span class="token punctuation">;</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token string">\'changed\'</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>此时控制台输出 <code>ƒ A() {}</code>，<code>export</code> 语句不再符合 <code>export default function</code> 语法形式，<code>A</code> 便使用了值传递。</p>\n<p>不仅仅 <code>export default function</code>，<code>export default class</code> 也是同样的表现。</p>\n<p>为什么呢？</p>\n<p>原因与这些语句当被用作表达式时的表现有关。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> someFunction<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "function"</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> SomeClass<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "function"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果我们将他们变成表达式：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> someFunction<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "undefined"</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> SomeClass<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "undefined"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>function</code> 和 <code>class</code> 语句会在作用域/块中创建标识符，而 <code>function</code> 和 <code>class</code> 语句却不会，尽管他们的函数名和类名可以被使用。</p>\n<p>因此，下面代码中：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> someFunction<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "function"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果不进行特殊处理的话，输出的将会是 <code>&quot;undefined&quot;</code>。</p>\n<p>小结如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 导入引用</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> otherName <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> module <span class="token keyword">from</span> <span class="token string">\'./module.js\'</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 导入值</span>\n<span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">\'./module.js\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 导出引用</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> otherName <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token constant">A</span> <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token comment">// 导出值</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token constant">A</span><span class="token punctuation">;</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">\'hello!\'</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><blockquote>\n<p>在早些时候，模块中的默认导出是这样的 <code>export default = A</code>，这样看来，<code>A</code> 被当做表达式会更明显一些。</p>\n</blockquote>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-07-12",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/export-default.html",pathLocale:"/",permalink:"/posts/2021/07/12/export-default.html",slug:"export-default",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/export-default.md",filePathRelative:"posts/export-default.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/12/export-default.html.vue",componentFilePathRelative:"pages/posts/2021/07/12/export-default.html.vue",componentFileChunkName:"v-b40eab24",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/12/export-default.html.js",dataFilePathRelative:"pages/posts/2021/07/12/export-default.html.js",dataFileChunkName:"v-b40eab24",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/07/12/export-default.html",htmlFilePathRelative:"posts/2021/07/12/export-default.html"},{key:"v-57d2f725",path:"/posts/2016/05/20/flexbox.html",title:"Flexbox 布局完全指南",lang:"zh-CN",frontmatter:{title:"Flexbox 布局完全指南",description:"css flexbox 布局",keywords:["css layout","css 布局","flexbox"],date:"2016-05-20T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"应用于 flex container 的属性",slug:"应用于-flex-container-的属性",children:[]},{level:2,title:"应用于 flex item 的属性",slug:"应用于-flex-item-的属性",children:[]},{level:2,title:"参考链接",slug:"参考链接",children:[]}],content:'\n## 应用于 flex container 的属性\n\n![flex-container](/posts/images/flex/flex-container-c.png)\n\n**display**\n该属性定义一个 flex container，根据不同取值定义为 inline 或 block 的 flex container。应用了该属性的元素为它的所有子元素创建了一个 flex context。\n\n```css\n.container {\n  display: flex; /* or inline-flex */\n}\n```\n\n> 注意，CSS3 的多列布局对 flex 容器没有任何影响。\n\n**flex-direction**\n\n![flex-direction1](/posts/images/flex/flex-direction-c.png)\n\n该属性建立主轴，规定了 flex container 中的 flex item 的排布方向。Flexbox 是一种单向布局概念，可以认为 flex item 都优先沿着水平行或竖直列布局。\n\n```css\n.container {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n- row （默认值）： 在 ltr 上下文中为由左到右；在 rtl 上下文中为由右到左。\n- row-reverse ： 在 ltr 上下文中为由右到左；在 rtl 上下文中为由左到右。\n- column ： 与 row 类似，只不过是由上到下。\n- column-reverse ： 与 row-reverse 类似，只不过是由下到上。\n\n**flex-wrap**\n\n![flex-wrap](/posts/images/flex/flex-wrap-c.png)\n\n默认情况下，所有的 flex item 都将尽量保持在一个 line （行或者列，下同）之内。可以通过这个属性让 flex item 在需要的情况下换行或者换列。这里，新行或新列从哪里开始由 flex-direction 决定。\n\n```css\n.container {\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n- nowrap （默认值）： 单 line。在 ltr 上下文中为由左到右；在 rtl 上下文中为由右到左。\n- wrap ： 多 line。在 ltr 上下文中为由左到右；在 rtl 上下文中为由右到左。\n- wrap-reverse ： 多 line。在 ltr 上下文中为由右到左；在 rtl 上下文中为由左到右。\n\n**flex-flow**\n该属性为 flex-direction 和 flex-wrap 的简写属性，同时定义了 flex container 的主轴和交叉轴。默认值为 row nowrap。\n\n```css\nflex-flow: <‘flex-direction’> || <‘flex-wrap’>;\n```\n\n**justify-content**\n\n![justify-content](/posts/images/flex/justify-content-c.png)\n\n该属性定义了沿着主轴的对齐方式。它被用来处理当所有 flex item 都已经放置完毕后的剩余空白空间。\n\n```css\n.container {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n- flex-start （默认值）： 所有的 flex item 都向 line 的开始位置对齐。\n- flex-end ： 所有的 flex item 都向 line 结束位置对齐。\n- center ： 所有的 flex item 都沿着 line 的中间位置对齐。\n- space-between ： 所有的 flex item 都均匀的沿着 line 分布，第一个 item 排在 line 的开始位置，最后一个 item 排在 line 的结束位置。\n- space-around ： 所有的 flex item 都均匀的沿着 line 分布，每个 item 周围的空白空间相等。注意，看上去每个 item 周围的空白空间不一定完全相等，因为所有的 item 的两边都拥有大小完全相同的空白空间。\n\n**align-items**\n\n![align-items](/posts/images/flex/align-items-c.png)\n\n该属性定义了在当前 line 中 flex item 沿着交叉轴布局的默认行为。可以认为它是针对交叉轴的 justify-content。\n\n```css\n.container {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n- flex-start ： 沿着交叉轴方向的 margin 边缘将会沿着交叉轴的开始位置对齐。\n- flex-end ： 沿着交叉轴方向的 margin 边缘将会沿着交叉轴的结束位置对齐。\n- center ： 所有的 flex item 将沿着交叉轴的中央对齐。\n- baseline ： 所有的 flex item 将会沿着他们的 baseline 对齐。\n- stretch （默认值）： 拉伸以填满容器（依然受 min-width/max-width 限制）。\n\n**align-content**\n\n![align-content](/posts/images/flex/align-content-c.png)\n\n该属性用来在交叉轴还有空白空间的情况下控制 flex container 内的所有 line 的对齐方式。与 justify-content 控制 flex item 如何沿着主轴方向对齐的方式类似。\n注意： 单 line 情况下，该属性不生效。\n\n```css\n.container {\n  align-content: flex-start | flex-end | center | space-between | space-around |\n    stretch;\n}\n```\n\n- flex-start ： 所有的 line 都向 container 的开始位置对齐。\n- flex-end ： 所有的 line 都向 container 的结束位置对齐。\n- center ： 所有的 line 都沿着 container 的中央对齐。\n- space-between ： 所有的 line 均匀分布，第一个 line 在 container 的开始位置，最后一个 line 在 container 的结束位置。\n- space-around ： 所有的 line 均匀分布，每个 line 周围的空白空间相等。\n- stretch （默认值）： 所有的 line 拉伸以填满剩余空间。\n\n## 应用于 flex item 的属性\n\n![flex-items](/posts/images/flex/flex-items-c.png)\n\n**order**\n\n![order](/posts/images/flex/order-c.png)\n\n在默认情况下，所有的 flex items 按照源代码中定义的顺序布局。但是， order 属性控制了 flex item 在 flex container 中显示的优先级。\n\n```css\n.item {\n  order: <integer>;\n}\n```\n\n**flex-grow**\n\n![flex-grow](/posts/images/flex/flex-grow-c.png)\n\n该属性赋予 flex item 生长（grow）的能力。它接受一个无单位的值，并将其作为比例值，表示在 flex container 中，这个 flex item 能够占有多大比例的可用空间。\n如果所有的 flex item 的 flex-grow 属性都设置为 1，那么 container 的剩余空间将被均匀的分配给所有 flex item。如果当中有一个 item 的 flex-grow 属性设置为 2，那么 这个 item 将占有 2 倍于其他 item 占有的可用空间。\n\n```css\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n负值是非法取值。\n\n**flex-shrink**\n该属性赋予 flex item 在必要的情况下收缩的能力。\n\n```css\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n负值是非法取值。\n\n**flex-basis**\n该属性用于在分配剩余空间之前定义 flex item 的默认尺寸大小。它的取值可以为一个绝对长度值（比如 20%，5rem，等）或者是一个关键字。auto 关键字表示根据 flex item 自身的 width 和 height 属性取值确定。 content 关键字表示根据 flex item 的 content 来确定，但是目前并没有得到很好的支持。\n\n```css\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n\n如果该属性取值为 0，那么在该 flex item 的 content 周围的额外空间将不被计算在内。如果取值为 auto，那么 flex item 的大小将根据 flex-grow 的取值来确定。可以参考[这张图](https://www.w3.org/TR/css-flexbox-1/images/rel-vs-abs-flex.svg)。\n\n**flex**\n该属性为 flex-grow, flex-shrink 和 flex-basis 的混合简写方式。 其中第二个和第三个参数（flex-shrink 和 flex-basis）为可选参数。该属性的默认值为 0 1 auto。\n\n```css\n.item {\n  flex: none | [ < "flex-grow" > < "flex-shrink" >? || < "flex-basis" > ];\n}\n```\n\n**align-self**\n\n![align-self](/posts/images/flex/align-self-c.png)\n\n该属性可以为每个 flex item 指定对齐方式。我们可以通过该属性修改 flex item 默认的或者由 align-items 指定的对齐方式。它的取值说明参考 align-items 的取值说明。\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n注意，float，clear 和 vertical-align 对 flex item 无任何影响。\n\n## 参考链接\n\n- [A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)\n',contentRendered:'<h2 id="应用于-flex-container-的属性" tabindex="-1"><a class="header-anchor" href="#应用于-flex-container-的属性" aria-hidden="true">#</a> 应用于 flex container 的属性</h2>\n<p><img src="/posts/images/flex/flex-container-c.png" alt="flex-container"></p>\n<p><strong>display</strong>\n该属性定义一个 flex container，根据不同取值定义为 inline 或 block 的 flex container。应用了该属性的元素为它的所有子元素创建了一个 flex context。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span> <span class="token comment">/* or inline-flex */</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote>\n<p>注意，CSS3 的多列布局对 flex 容器没有任何影响。</p>\n</blockquote>\n<p><strong>flex-direction</strong></p>\n<p><img src="/posts/images/flex/flex-direction-c.png" alt="flex-direction1"></p>\n<p>该属性建立主轴，规定了 flex container 中的 flex item 的排布方向。Flexbox 是一种单向布局概念，可以认为 flex item 都优先沿着水平行或竖直列布局。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">flex-direction</span><span class="token punctuation">:</span> row | row-reverse | column | column-reverse<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul>\n<li>row （默认值）： 在 ltr 上下文中为由左到右；在 rtl 上下文中为由右到左。</li>\n<li>row-reverse ： 在 ltr 上下文中为由右到左；在 rtl 上下文中为由左到右。</li>\n<li>column ： 与 row 类似，只不过是由上到下。</li>\n<li>column-reverse ： 与 row-reverse 类似，只不过是由下到上。</li>\n</ul>\n<p><strong>flex-wrap</strong></p>\n<p><img src="/posts/images/flex/flex-wrap-c.png" alt="flex-wrap"></p>\n<p>默认情况下，所有的 flex item 都将尽量保持在一个 line （行或者列，下同）之内。可以通过这个属性让 flex item 在需要的情况下换行或者换列。这里，新行或新列从哪里开始由 flex-direction 决定。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap | wrap | wrap-reverse<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul>\n<li>nowrap （默认值）： 单 line。在 ltr 上下文中为由左到右；在 rtl 上下文中为由右到左。</li>\n<li>wrap ： 多 line。在 ltr 上下文中为由左到右；在 rtl 上下文中为由右到左。</li>\n<li>wrap-reverse ： 多 line。在 ltr 上下文中为由右到左；在 rtl 上下文中为由左到右。</li>\n</ul>\n<p><strong>flex-flow</strong>\n该属性为 flex-direction 和 flex-wrap 的简写属性，同时定义了 flex container 的主轴和交叉轴。默认值为 row nowrap。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token property">flex-flow</span><span class="token punctuation">:</span> &lt;‘flex-direction’> || &lt;‘flex-wrap’><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>justify-content</strong></p>\n<p><img src="/posts/images/flex/justify-content-c.png" alt="justify-content"></p>\n<p>该属性定义了沿着主轴的对齐方式。它被用来处理当所有 flex item 都已经放置完毕后的剩余空白空间。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul>\n<li>flex-start （默认值）： 所有的 flex item 都向 line 的开始位置对齐。</li>\n<li>flex-end ： 所有的 flex item 都向 line 结束位置对齐。</li>\n<li>center ： 所有的 flex item 都沿着 line 的中间位置对齐。</li>\n<li>space-between ： 所有的 flex item 都均匀的沿着 line 分布，第一个 item 排在 line 的开始位置，最后一个 item 排在 line 的结束位置。</li>\n<li>space-around ： 所有的 flex item 都均匀的沿着 line 分布，每个 item 周围的空白空间相等。注意，看上去每个 item 周围的空白空间不一定完全相等，因为所有的 item 的两边都拥有大小完全相同的空白空间。</li>\n</ul>\n<p><strong>align-items</strong></p>\n<p><img src="/posts/images/flex/align-items-c.png" alt="align-items"></p>\n<p>该属性定义了在当前 line 中 flex item 沿着交叉轴布局的默认行为。可以认为它是针对交叉轴的 justify-content。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul>\n<li>flex-start ： 沿着交叉轴方向的 margin 边缘将会沿着交叉轴的开始位置对齐。</li>\n<li>flex-end ： 沿着交叉轴方向的 margin 边缘将会沿着交叉轴的结束位置对齐。</li>\n<li>center ： 所有的 flex item 将沿着交叉轴的中央对齐。</li>\n<li>baseline ： 所有的 flex item 将会沿着他们的 baseline 对齐。</li>\n<li>stretch （默认值）： 拉伸以填满容器（依然受 min-width/max-width 限制）。</li>\n</ul>\n<p><strong>align-content</strong></p>\n<p><img src="/posts/images/flex/align-content-c.png" alt="align-content"></p>\n<p>该属性用来在交叉轴还有空白空间的情况下控制 flex container 内的所有 line 的对齐方式。与 justify-content 控制 flex item 如何沿着主轴方向对齐的方式类似。\n注意： 单 line 情况下，该属性不生效。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around |\n    stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul>\n<li>flex-start ： 所有的 line 都向 container 的开始位置对齐。</li>\n<li>flex-end ： 所有的 line 都向 container 的结束位置对齐。</li>\n<li>center ： 所有的 line 都沿着 container 的中央对齐。</li>\n<li>space-between ： 所有的 line 均匀分布，第一个 line 在 container 的开始位置，最后一个 line 在 container 的结束位置。</li>\n<li>space-around ： 所有的 line 均匀分布，每个 line 周围的空白空间相等。</li>\n<li>stretch （默认值）： 所有的 line 拉伸以填满剩余空间。</li>\n</ul>\n<h2 id="应用于-flex-item-的属性" tabindex="-1"><a class="header-anchor" href="#应用于-flex-item-的属性" aria-hidden="true">#</a> 应用于 flex item 的属性</h2>\n<p><img src="/posts/images/flex/flex-items-c.png" alt="flex-items"></p>\n<p><strong>order</strong></p>\n<p><img src="/posts/images/flex/order-c.png" alt="order"></p>\n<p>在默认情况下，所有的 flex items 按照源代码中定义的顺序布局。但是， order 属性控制了 flex item 在 flex container 中显示的优先级。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">order</span><span class="token punctuation">:</span> &lt;integer><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>flex-grow</strong></p>\n<p><img src="/posts/images/flex/flex-grow-c.png" alt="flex-grow"></p>\n<p>该属性赋予 flex item 生长（grow）的能力。它接受一个无单位的值，并将其作为比例值，表示在 flex container 中，这个 flex item 能够占有多大比例的可用空间。\n如果所有的 flex item 的 flex-grow 属性都设置为 1，那么 container 的剩余空间将被均匀的分配给所有 flex item。如果当中有一个 item 的 flex-grow 属性设置为 2，那么 这个 item 将占有 2 倍于其他 item 占有的可用空间。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">flex-grow</span><span class="token punctuation">:</span> &lt;number><span class="token punctuation">;</span> <span class="token comment">/* default 0 */</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>负值是非法取值。</p>\n<p><strong>flex-shrink</strong>\n该属性赋予 flex item 在必要的情况下收缩的能力。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">flex-shrink</span><span class="token punctuation">:</span> &lt;number><span class="token punctuation">;</span> <span class="token comment">/* default 1 */</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>负值是非法取值。</p>\n<p><strong>flex-basis</strong>\n该属性用于在分配剩余空间之前定义 flex item 的默认尺寸大小。它的取值可以为一个绝对长度值（比如 20%，5rem，等）或者是一个关键字。auto 关键字表示根据 flex item 自身的 width 和 height 属性取值确定。 content 关键字表示根据 flex item 的 content 来确定，但是目前并没有得到很好的支持。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">flex-basis</span><span class="token punctuation">:</span> &lt;length> | auto<span class="token punctuation">;</span> <span class="token comment">/* default auto */</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果该属性取值为 0，那么在该 flex item 的 content 周围的额外空间将不被计算在内。如果取值为 auto，那么 flex item 的大小将根据 flex-grow 的取值来确定。可以参考<a href="https://www.w3.org/TR/css-flexbox-1/images/rel-vs-abs-flex.svg" target="_blank" rel="noopener noreferrer">这张图<OutboundLink/></a>。</p>\n<p><strong>flex</strong>\n该属性为 flex-grow, flex-shrink 和 flex-basis 的混合简写方式。 其中第二个和第三个参数（flex-shrink 和 flex-basis）为可选参数。该属性的默认值为 0 1 auto。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">flex</span><span class="token punctuation">:</span> none | [ &lt; <span class="token string">"flex-grow"</span> > &lt; <span class="token string">"flex-shrink"</span> >? || &lt; <span class="token string">"flex-basis"</span> > ]<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>align-self</strong></p>\n<p><img src="/posts/images/flex/align-self-c.png" alt="align-self"></p>\n<p>该属性可以为每个 flex item 指定对齐方式。我们可以通过该属性修改 flex item 默认的或者由 align-items 指定的对齐方式。它的取值说明参考 align-items 的取值说明。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.item</span> <span class="token punctuation">{</span>\n  <span class="token property">align-self</span><span class="token punctuation">:</span> auto | flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意，float，clear 和 vertical-align 对 flex item 无任何影响。</p>\n<h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>\n<ul>\n<li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener noreferrer">A Complete Guide to Flexbox<OutboundLink/></a></li>\n</ul>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2016-05-20",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/flexbox.html",pathLocale:"/",permalink:"/posts/2016/05/20/flexbox.html",slug:"flexbox",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/flexbox.md",filePathRelative:"posts/flexbox.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2016/05/20/flexbox.html.vue",componentFilePathRelative:"pages/posts/2016/05/20/flexbox.html.vue",componentFileChunkName:"v-57d2f725",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2016/05/20/flexbox.html.js",dataFilePathRelative:"pages/posts/2016/05/20/flexbox.html.js",dataFileChunkName:"v-57d2f725",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2016/05/20/flexbox.html",htmlFilePathRelative:"posts/2016/05/20/flexbox.html"},{key:"v-038e5071",path:"/posts/2021/10/14/guildlines-for-nodejs-framework.html",title:"如何选择 NodeJS 框架？",lang:"zh-CN",frontmatter:{title:"如何选择 NodeJS 框架？",description:"NodeJS 框架越来越多，在做技术选型的时候难免会眼花缭乱。本文介绍一些选型的指导原则。",keywords:["NodeJS"],date:"2021-10-14T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"我们的使用场景是什么？",slug:"我们的使用场景是什么",children:[]},{level:2,title:"框架的风格",slug:"框架的风格",children:[]},{level:2,title:"文档",slug:"文档",children:[]},{level:2,title:"实用的样例",slug:"实用的样例",children:[]},{level:2,title:"社区生态",slug:"社区生态",children:[]},{level:2,title:"项目的健康程度",slug:"项目的健康程度",children:[]},{level:2,title:"总结",slug:"总结",children:[]}],content:'\n作为一个有一定工作经验的工程师，工作中经常会遇到技术选型的问题。比如当我们在工作中需要使用到 NodeJS 时，第一个要解决的问题就是如何选择一个合适的框架。\n\n不同的框架有不同的特点，如果我们仅仅从框架提供的能力出发，往往会迷失在对不同框架能力的对比中。如果能有一个清单，照着这个清单来考察每个框架，最终选出最符合要求的框架，那就真是太棒了！\n\n我们今天就试图来讨论出一个检查清单，通过这个清单，我们可以找出最适合我们的框架。\n\n## 我们的使用场景是什么？\n\n使用场景是最重要的考虑因素。在选择框架之前，先搞清楚我们的诉求是什么。\n\n下面是一些常见的需要考虑的点：\n\n* **我们的应用是全栈应用还是只提供 API 服务？** 如果只提供 API 服务的话，是 [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) 接口还是 [GraphQL](https://graphql.org/) 接口？\n* **是否需要服务端渲染？** 如果我们使用 React 或者 Vue 来开发页面的话，一些 NodeJS 框架本身提供了对这些 UI 框架的支持。\n* **是否需要实时响应？** 如果我们需要使用到 WebSockets，是选择一个支持 WebSockets 的框架，还是找一个社区维护的第三方库来集成到框架中？\n* **是否支持 TypeScript？** 我们是否要用 TypeScript 来开发应用？有些框架是使用 TypeScript 开发的，有些框架只提供了类型声明，而有些框架只有社区第三方维护的类型声明。即使我们不使用 TypeScript 开发，类型声明也可以通过编辑器提示给我们带来巨大的帮助。\n\n## 框架的风格\n\n有些框架除了处理 HTTP 请求和响应以外，还提供了类似于校验、日志、认证、数据库抽象以及依赖注入等其他丰富的功能。这些框架通常对开发者有一些额外的要求，比如要按照框架要求的形式来组织代码才能使用框架的一些能力。\n\n有一些框架只提供处理 HTTP 请求和响应的基本能力。其他能力需要开发者自行实现或者从框架的生态中自行获取。使用这些框架的开发者自由度很高，可以自由组织代码形式。但是当需要一些其他功能时，开发者需要额外付出精力来筛选合适的社区实现。\n\n还有一些框架采取了中庸的形式，即除了提供 HTTP 请求和响应的基本能力以外，还提供了稍许功能，比如日志和校验等。\n\n选择哪种风格的框架，可以从上面列出的使用场景出发，也可以从个人和团队的风格偏好出发。\n\n## 文档\n\n丰富的文档至关重要。没有人会想一边开发业务，一边通过阅读框架的代码来了解框架的能力。如果一个框架没有文档，我们应该拒绝使用。对于有文档的框架，我们如何评价文档的质量呢？\n\n可以从下面几点出发：\n\n* **是否可以方便的查找？** 比如文档的结构是否容易理解？是否提供搜索功能？\n* **文档是否有意义？** 文档很重要，有用的文档更重要。没有用的文档写的再多也没有意义。\n* **当写代码的时候，这些文档是否能派上用场？** 阅读和理解如果做一件事是一回事，动手做一件事是另一回事。在我们写代码的时候，文档是否可以直接明确的帮助我们？\n\n## 实用的样例\n\n说的再多不如写一个样例给我。阅读文档有时候会让我们迷失方向，如同坠入一团雾中。如果有一些官方提供的实用样例的话，对理解框架以及解决实际问题的帮助就很大。官方提供的样例通常也会是解决某一个具体问题的最佳实践。\n\n通常，我们可以在框架源代码的 `examples` 目录中找到样例，有些框架还会有一个专门的仓库来存放各种各样的样例。\n\n## 社区生态\n\n一个框架的社区生态非常重要。在选择框架的时候，观察下框架是否有讨论组之类的东西。参与其中的人是否友好、是否乐于帮助他人等。\n\n框架是否流行不能决定我们是否选择这个框架。但是我们在选择框架的时候，要了解是否有其他开发者也在使用。如果我们选择了一个被广泛使用的框架，那么我们通常可以找到其他开发者开发的类库（中间件或者插件等）。\n\n一个仓库的 star 数量某种意义上能够代表框架的受欢迎程度。但是却不能准确的表达框架的使用情况，我们可以从框架的下载量着手。虽然有一些框架被其他类库内置使用，导致下载量很高，但是一定程度上可以说明框架在市面上的使用程度。我们可以在 [npm trends](https://www.npmtrends.com/) 上看到框架的下载量变化。\n\n## 项目的健康程度\n\n当我们决定选择一个框架的时候，我们还需要确保这个框架在可见的未来时间内依然能够得到有效的维护。\n\n我们可以从下面几个方面来考察项目的健康程度：\n\n* **版本发布频率** 即使一个框架的功能已经非常完善了，安全更新和问题修复依然十分重要。因此在面对已经暂停维护或者很长时间没有发版的项目的时候，需要慎重考虑。\n* **官方在 issue 的活跃程度** 如果一个项目的 issue 里官方成员的参与程度很低，可能在暗示这个项目已经不再维护了。相反，如果一个项目的 issue 很少，有可能说明社区对这个框架的使用程度很低。\n* **Pull request** 一个健康的项目，通常都会有一些近期刚提交的 pull request。如果一个项目有很多很好的 pull request 没有合并，可能说明这个项目已经不再维护了。\n* **贡献者** 如果一个框架的贡献者只有一两个人，说明社区对这个框架的关注度不高。同时较少的贡献者，会给框架的长期维护带来不确定性。一个健康的框架，应该有很多贡献者参与进来。\n* **项目依赖** 一个有着很多依赖的框架，可能受攻击的地方也很多。同时，太多的依赖也可能给开发调试带来很多问题。我们可以通过 [npmgraph](https://npmgraph.js.org/) 这个工具才查看一个项目的依赖情况。\n\n这里有一些评价一个项目健康度的工具可以使用：\n\n* **[Synk Open Source Advisor](https://snyk.io/advisor/)** 这个工具会从多方收集一个包的数据，然后给出这个包的打分。\n* **GitHub 仓库的 "Insights" Tab 页** GitHub 上每个仓库中的这个 Tab 提供了这个仓库近期的活动情况，包括发版、pull request、issue 和贡献者等。\n* **[Moiva](https://moiva.io/)** 这是一个开源工具，与上面两个工具提供的能力相同。但是这个工具允许我们同时对比多个框架。\n\n## 总结\n\n在选择一个 NodeJS 框架的时候，我们有很多方面需要考虑。但是最后也是最重要的一点是，我们在使用这个框架的时候，是否享受使用它的过程。如果不是，那么即使框架解决了一些问题，我们也会非常难受。\n\n选择一个靠谱的 NodeJS 框架有时候非常棘手，希望这个检查列表能给正在做框架选型的人一些帮助。\n',contentRendered:'<p>作为一个有一定工作经验的工程师，工作中经常会遇到技术选型的问题。比如当我们在工作中需要使用到 NodeJS 时，第一个要解决的问题就是如何选择一个合适的框架。</p>\n<p>不同的框架有不同的特点，如果我们仅仅从框架提供的能力出发，往往会迷失在对不同框架能力的对比中。如果能有一个清单，照着这个清单来考察每个框架，最终选出最符合要求的框架，那就真是太棒了！</p>\n<p>我们今天就试图来讨论出一个检查清单，通过这个清单，我们可以找出最适合我们的框架。</p>\n<h2 id="我们的使用场景是什么" tabindex="-1"><a class="header-anchor" href="#我们的使用场景是什么" aria-hidden="true">#</a> 我们的使用场景是什么？</h2>\n<p>使用场景是最重要的考虑因素。在选择框架之前，先搞清楚我们的诉求是什么。</p>\n<p>下面是一些常见的需要考虑的点：</p>\n<ul>\n<li><strong>我们的应用是全栈应用还是只提供 API 服务？</strong> 如果只提供 API 服务的话，是 <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener noreferrer">REST<OutboundLink/></a> 接口还是 <a href="https://graphql.org/" target="_blank" rel="noopener noreferrer">GraphQL<OutboundLink/></a> 接口？</li>\n<li><strong>是否需要服务端渲染？</strong> 如果我们使用 React 或者 Vue 来开发页面的话，一些 NodeJS 框架本身提供了对这些 UI 框架的支持。</li>\n<li><strong>是否需要实时响应？</strong> 如果我们需要使用到 WebSockets，是选择一个支持 WebSockets 的框架，还是找一个社区维护的第三方库来集成到框架中？</li>\n<li><strong>是否支持 TypeScript？</strong> 我们是否要用 TypeScript 来开发应用？有些框架是使用 TypeScript 开发的，有些框架只提供了类型声明，而有些框架只有社区第三方维护的类型声明。即使我们不使用 TypeScript 开发，类型声明也可以通过编辑器提示给我们带来巨大的帮助。</li>\n</ul>\n<h2 id="框架的风格" tabindex="-1"><a class="header-anchor" href="#框架的风格" aria-hidden="true">#</a> 框架的风格</h2>\n<p>有些框架除了处理 HTTP 请求和响应以外，还提供了类似于校验、日志、认证、数据库抽象以及依赖注入等其他丰富的功能。这些框架通常对开发者有一些额外的要求，比如要按照框架要求的形式来组织代码才能使用框架的一些能力。</p>\n<p>有一些框架只提供处理 HTTP 请求和响应的基本能力。其他能力需要开发者自行实现或者从框架的生态中自行获取。使用这些框架的开发者自由度很高，可以自由组织代码形式。但是当需要一些其他功能时，开发者需要额外付出精力来筛选合适的社区实现。</p>\n<p>还有一些框架采取了中庸的形式，即除了提供 HTTP 请求和响应的基本能力以外，还提供了稍许功能，比如日志和校验等。</p>\n<p>选择哪种风格的框架，可以从上面列出的使用场景出发，也可以从个人和团队的风格偏好出发。</p>\n<h2 id="文档" tabindex="-1"><a class="header-anchor" href="#文档" aria-hidden="true">#</a> 文档</h2>\n<p>丰富的文档至关重要。没有人会想一边开发业务，一边通过阅读框架的代码来了解框架的能力。如果一个框架没有文档，我们应该拒绝使用。对于有文档的框架，我们如何评价文档的质量呢？</p>\n<p>可以从下面几点出发：</p>\n<ul>\n<li><strong>是否可以方便的查找？</strong> 比如文档的结构是否容易理解？是否提供搜索功能？</li>\n<li><strong>文档是否有意义？</strong> 文档很重要，有用的文档更重要。没有用的文档写的再多也没有意义。</li>\n<li><strong>当写代码的时候，这些文档是否能派上用场？</strong> 阅读和理解如果做一件事是一回事，动手做一件事是另一回事。在我们写代码的时候，文档是否可以直接明确的帮助我们？</li>\n</ul>\n<h2 id="实用的样例" tabindex="-1"><a class="header-anchor" href="#实用的样例" aria-hidden="true">#</a> 实用的样例</h2>\n<p>说的再多不如写一个样例给我。阅读文档有时候会让我们迷失方向，如同坠入一团雾中。如果有一些官方提供的实用样例的话，对理解框架以及解决实际问题的帮助就很大。官方提供的样例通常也会是解决某一个具体问题的最佳实践。</p>\n<p>通常，我们可以在框架源代码的 <code>examples</code> 目录中找到样例，有些框架还会有一个专门的仓库来存放各种各样的样例。</p>\n<h2 id="社区生态" tabindex="-1"><a class="header-anchor" href="#社区生态" aria-hidden="true">#</a> 社区生态</h2>\n<p>一个框架的社区生态非常重要。在选择框架的时候，观察下框架是否有讨论组之类的东西。参与其中的人是否友好、是否乐于帮助他人等。</p>\n<p>框架是否流行不能决定我们是否选择这个框架。但是我们在选择框架的时候，要了解是否有其他开发者也在使用。如果我们选择了一个被广泛使用的框架，那么我们通常可以找到其他开发者开发的类库（中间件或者插件等）。</p>\n<p>一个仓库的 star 数量某种意义上能够代表框架的受欢迎程度。但是却不能准确的表达框架的使用情况，我们可以从框架的下载量着手。虽然有一些框架被其他类库内置使用，导致下载量很高，但是一定程度上可以说明框架在市面上的使用程度。我们可以在 <a href="https://www.npmtrends.com/" target="_blank" rel="noopener noreferrer">npm trends<OutboundLink/></a> 上看到框架的下载量变化。</p>\n<h2 id="项目的健康程度" tabindex="-1"><a class="header-anchor" href="#项目的健康程度" aria-hidden="true">#</a> 项目的健康程度</h2>\n<p>当我们决定选择一个框架的时候，我们还需要确保这个框架在可见的未来时间内依然能够得到有效的维护。</p>\n<p>我们可以从下面几个方面来考察项目的健康程度：</p>\n<ul>\n<li><strong>版本发布频率</strong> 即使一个框架的功能已经非常完善了，安全更新和问题修复依然十分重要。因此在面对已经暂停维护或者很长时间没有发版的项目的时候，需要慎重考虑。</li>\n<li><strong>官方在 issue 的活跃程度</strong> 如果一个项目的 issue 里官方成员的参与程度很低，可能在暗示这个项目已经不再维护了。相反，如果一个项目的 issue 很少，有可能说明社区对这个框架的使用程度很低。</li>\n<li><strong>Pull request</strong> 一个健康的项目，通常都会有一些近期刚提交的 pull request。如果一个项目有很多很好的 pull request 没有合并，可能说明这个项目已经不再维护了。</li>\n<li><strong>贡献者</strong> 如果一个框架的贡献者只有一两个人，说明社区对这个框架的关注度不高。同时较少的贡献者，会给框架的长期维护带来不确定性。一个健康的框架，应该有很多贡献者参与进来。</li>\n<li><strong>项目依赖</strong> 一个有着很多依赖的框架，可能受攻击的地方也很多。同时，太多的依赖也可能给开发调试带来很多问题。我们可以通过 <a href="https://npmgraph.js.org/" target="_blank" rel="noopener noreferrer">npmgraph<OutboundLink/></a> 这个工具才查看一个项目的依赖情况。</li>\n</ul>\n<p>这里有一些评价一个项目健康度的工具可以使用：</p>\n<ul>\n<li><strong><a href="https://snyk.io/advisor/" target="_blank" rel="noopener noreferrer">Synk Open Source Advisor<OutboundLink/></a></strong> 这个工具会从多方收集一个包的数据，然后给出这个包的打分。</li>\n<li><strong>GitHub 仓库的 &quot;Insights&quot; Tab 页</strong> GitHub 上每个仓库中的这个 Tab 提供了这个仓库近期的活动情况，包括发版、pull request、issue 和贡献者等。</li>\n<li><strong><a href="https://moiva.io/" target="_blank" rel="noopener noreferrer">Moiva<OutboundLink/></a></strong> 这是一个开源工具，与上面两个工具提供的能力相同。但是这个工具允许我们同时对比多个框架。</li>\n</ul>\n<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>\n<p>在选择一个 NodeJS 框架的时候，我们有很多方面需要考虑。但是最后也是最重要的一点是，我们在使用这个框架的时候，是否享受使用它的过程。如果不是，那么即使框架解决了一些问题，我们也会非常难受。</p>\n<p>选择一个靠谱的 NodeJS 框架有时候非常棘手，希望这个检查列表能给正在做框架选型的人一些帮助。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-10-14",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/guildlines-for-nodejs-framework.html",pathLocale:"/",permalink:"/posts/2021/10/14/guildlines-for-nodejs-framework.html",slug:"guildlines-for-nodejs-framework",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/guildlines-for-nodejs-framework.md",filePathRelative:"posts/guildlines-for-nodejs-framework.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/10/14/guildlines-for-nodejs-framework.html.vue",componentFilePathRelative:"pages/posts/2021/10/14/guildlines-for-nodejs-framework.html.vue",componentFileChunkName:"v-038e5071",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/10/14/guildlines-for-nodejs-framework.html.js",dataFilePathRelative:"pages/posts/2021/10/14/guildlines-for-nodejs-framework.html.js",dataFileChunkName:"v-038e5071",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/10/14/guildlines-for-nodejs-framework.html",htmlFilePathRelative:"posts/2021/10/14/guildlines-for-nodejs-framework.html"},{key:"v-50a5c4e0",path:"/posts/2022/03/31/how-flexbox-works.html",title:"Flexbox 是如何工作的",lang:"zh-CN",frontmatter:{title:"Flexbox 是如何工作的",description:"通过例子说明 css flexbox 布局的工作原理。",keywords:["css layout","css 布局","flexbox"],date:"2022-03-31T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"Flexbox 的布局原理",slug:"flexbox-的布局原理",children:[]},{level:2,title:"例子说明",slug:"例子说明",children:[{level:3,title:"设置 flex-grow",slug:"设置-flex-grow",children:[]},{level:3,title:"差异化的 flex-grow",slug:"差异化的-flex-grow",children:[]},{level:3,title:"设置 flex-basis: auto",slug:"设置-flex-basis-auto",children:[]},{level:3,title:"设置 flex-shrink",slug:"设置-flex-shrink",children:[]},{level:3,title:"设置 flex-wrap",slug:"设置-flex-wrap",children:[]}]},{level:2,title:"总结",slug:"总结",children:[]}],content:'\nFlexbox 是一种 CSS 布局机制，可以说是目前浏览器原生支持的最好、使用最广泛的布局机制了。本文通过一些例子来说明 Flexbox 布局的工作原理，可以让我们更好的使用 Flexbox。\n\n与 CSS Grid 可以同时在横向和纵向两个方向进行布局不同，Flexbox 只能在单一方向上进行布局，即要么横向，要么纵向。所谓布局，其实就是空间的分配过程，也就是说计算元素尺寸和容器剩余空间尺寸的过程。\n\n## Flexbox 的布局原理\n\n整个布局过程我们可以简单的总结如下：\n\n1. 计算 flex 容器内的可用空间。整个容器的尺寸减去容器的 border、padding 等所得的剩余空间尺寸。\n2. 计算每个 flex 元素的 flex base 尺寸和元素的假设尺寸。具体计算方法是取 flex-basis、min-width 和 flex 元素内容尺寸的较大者。flex base 尺寸是 flex 元素需要的最小尺寸，这个尺寸不能小于元素内容的尺寸。元素的假设尺寸是指在 flex 因子生效前元素的尺寸，flex 因子生效后可能导致元素发生伸缩。\n3. 计算容器内所有 flex 元素的假设尺寸总和。\n4. 将所有元素的假设尺寸总和与容器内可用空间尺寸做比较，来确定 flex 因子，也就是说当假设尺寸总和超过容器内可用空间尺寸时，使用 flex-shrink，否则使用 flex-grow。在同一时间，flex-shrink 和 flex-grow 只有一个生效。\n\n所谓 flex 因子，简单来说就是缩小和放大。浏览器在进行 flexbox 布局时会先确定使用哪种 flex 因子，然后再根据选用的 flex 因子来对元素尺寸进行调整。\n\n在进行调整的时候，就会涉及到一个剩余空间的计算问题。如果 flex 元素明确指定了尺寸大小（[definite size](https://drafts.csswg.org/css-sizing-3/#definite_)，比如设置了 width），那么这个元素就是不可伸缩的。如果没有显式指定尺寸，则会按照上面第2步那样计算假设尺寸。剩余空间的尺寸就是容器内的可用空间尺寸减去这些元素的尺寸之和。\n\n## 例子说明\n\n我们有如下 dom 结构：\n\n```html\n<div id="flex">\n  <div id="a">Antidisestablishmentarianism</div>\n  <div id="b">B</div>\n  <div id="c">Cherries jubilee</div>\n  <div id="d">D</div>\n  <div id="e">E</div>\n</div>\n```\n样式如下：\n```css\n[id=flex] {\n    font-weight: 300;\n    display: flex;\n    outline: 1px dashed #555;\n    width: 1200px;\n    margin: 3rem auto;\n}\n/*其他样式已省略*/\n```\n\n页面展示效果如下：\n\n![flex 布局](/posts/images/how-flexbox-works/flex-c.png)\n\n我们没有设置元素的 `flex` 样式属性，默认值是 `0 1 auto`。`flex` 样式属性是 `flex-grow`、`flex-shrink` 和 `flex-basis` 这三个样式属性的简写形式。`0 1 auto` 分别对应为 `flex-grow`、`flex-shrink` 和 `flex-basis` 的值。\n\n通过取值可以看到，因为我们禁止了放大和收缩，并且 `flex-basis` 的值是 `auto`，浏览器就使用元素的最大内容尺寸来计算所有元素的尺寸总和，比容器的尺寸（1200px）小，所有会有额外的剩余空间。\n\n关于 `flex` 这个样式属性，我们额外做一些说明。`flex` 属性可以接收最少一个、最多三个属性值。\n\n当只有一个属性值的时候，`flex` 的工作模式是这样的 `<number> 1 0`。即 `flex: 2` 最终的结果是 `flex: 2 1 0`。\n\n当有两个属性值的时候，第一个值会被解析为 `flex-grow`，第二个值如果是数字，则会被解析为 `flex-shrink`，如果是一个[合法的宽度值](https://developer.mozilla.org/en-US/docs/Web/CSS/width)则会被解析为 `flex-basis`。即 `flex: 1 0` 解析为 `flex: 1 0 0`，而 `flex: 1 20rem` 则被解析为 `flex: 1 1 20rem`。\n\n当有三个属性值的时候，第一个值被解析为 `flex-grow`，第二个值必须为数字，且会被解析为 `flex-shrink`，第三个值则必须是合法的宽度值，被解析为 `flex-basis`。\n\n### 设置 flex-grow\n\n我们增加如下样式设置:\n```css\n[id=flex] > div {\n  flex: 1;\n}\n```\n实际上等同于 `flex: 1 1 0`，即 `flex-grow: 1`。从前面的例子我们可以看到，所有元素的假设尺寸之和是小于容器剩余空间尺寸的，所以浏览器会使用 `flex-grow` 来作为 flex 因子，因为我们设置了 `flex-grow: 1` ，因此浏览器会等比放大所有的元素。如下图：\n\n![设置了 flex-grow 的 flex 布局](/posts/images/how-flexbox-works/flex-grow-c.png)\n\n\n实际上浏览器会循环通过下面的公式来计算每个元素的最终尺寸：\n\n```\n当前元素伸缩值 = (当前剩余空间 - 所有剩余元素的 flex-grow 值的和) * 当前元素的 flex-grow 值\n```\n\n在上面的例子中，容器的剩余空间为 1200px，因此，通过公式计算：\n\n```\n( 1200 ÷ ( 1 + 1 + 1 + 1 + 1 ) ) × 1 = 240\n```\n元素 A 的最终尺寸为 `240px + flex-basis = 240px + 0 = 240px`。但是，因为 `Antidisestablishmentarianism` 这个单词比较长，实际会占用 `417px` 的空间大小，因此元素 A 的最终尺寸为 `417px`。\n\n此时，在计算元素 B 的尺寸时，剩余空间为 `1200px - 417px = 783px`。元素 B 的伸缩值为：\n\n```\n( 783 ÷ ( 1 + 1 + 1 + 1 ) ) × 1 = 195.75 0 + 195.75 = 195.75\n```\n\n同理，元素 C、D、E 的伸缩值分别为：\n\n```\nC: ( 587 ÷ ( 1 + 1 + 1 ) ) × 1 ) = 195.67\nD: ( 391.33 ÷ ( 1 + 1 ) ) × 1 = 195.665\nE: ( 391 - 195.665 ÷ 1 ) × 1 = 195.335\n```\n\n总结来说，浏览器从剩余空间中减去已经分配的空间，然后计算下一个 flex 元素的伸缩值和最终大小。\n\n### 差异化的 flex-grow\n\n我们修改一下元素的 `flex-grow` 值：\n\n```css\ndiv > :not([id=c]) {\n  flex: 1;\n}\n\n[id=c] {\n  flex: 5;\n}\n```\n\n此时，页面展示效果如下：\n\n![差异化 flex-grow](/posts/images/how-flexbox-works/flex-grow-2-c.png)\n\n各元素的伸缩值计算如下：\n```\nA: 417px\nB: ( 783 ÷ ( 1 + 1 + 5 + 1 ) ) × 1 = 98\nC: ( 685 ÷ ( 5 + 1 + 1 ) ) × 5 = 490\nD: ( 195 ÷ ( 1 + 1 ) ) × 1 = 97.5\nE: ( 97.5 ÷ 1 ) × 1 = 97.5\n```\n\n### 设置 `flex-basis: auto`\n\n前面的例子里，我们都设置了 `flex-basis` 的值为 0，现在我们设置 `flex-basis: auto`，再来看看元素尺寸是如何计算的。\n\n删除其他元素的 flex 指定，修改样式如下：\n\n```css\n[id=c] {\n  flex: 5;\n}\n```\n此时等价于其他元素是 `flex: 0 1 auto`，元素 C 是 `flex: 5 1 0`。展示效果如下：\n\n![flex-basis](/posts/images/how-flexbox-works/flex-basis-c.png)\n\n在前面的例子中，所有元素都是 `flex-basis: 0`，现在设置为 A、B、D、E 都设置成了 `flex-basis: auto`。因此，元素 A、B、D、E 都会使用元素内容的尺寸来计算。\n\n因此，剩余剩余可分配空间大小为：\n\n```\n1200 - ( 417 + 33 + 35 + 30 ) = 685\n```\n\n因为元素 C 是唯一可伸缩的元素，因此它的伸缩值为 685。\n\n### 设置 flex-shrink\n\n现在我们做一些调整，让所有 flex 元素的尺寸总和大于容器的可用空间尺寸，使得 flex-shrink 生效。\n\n样式调整如下：\n\n```css\n:not([id=a]) {\n    flex-shrink: 1;\n}\n[id=a] {\n    flex-shrink: 5;\n}\ndiv > div {\n    flex-basis: 500px;\n}\n```\n可以看到，所有元素 `flex-grow: 0`，元素 A `flex-shrink: 5`，其他元素 `flex-shrink: 1`，所有元素总尺寸 2500px。\n\n显示效果如下：\n![flex-shrink](/posts/images/how-flexbox-works/flex-shrink-c.png)\n\n因为元素尺寸总和超过了容器可用尺寸（1200px），因此 flex-shrink 将会生效。\n\n元素 A 的伸缩值为：\n\n```\n( 1300 ÷  ( 5 + 1 + 1 + 1 + 1 ) ) × 5 = 722.22\n```\n\n则元素 A 的实际尺寸计算为：\n\n```\n500 - 722.22 = -222.22\n```\n\n可以看到得出的是负值。如果元素 A 是空元素，那么最终尺寸会是零。本例中，元素 A 的尺寸就是起内容的尺寸，大概 34px。\n\n确定了元素 A 的尺寸之后，容器剩余空间尺寸为 `1200 - 34 = 1166`。其他元素的伸缩值计算为：\n\n```\nB: ( 1166 ÷ ( 1 + 1 + 1 + 1 ) ) × 1 = 291.5\nC: ( 874.5 ÷ ( 1 + 1 + 1 ) ) × 1 = 291.5\nD: ( 583 ÷ ( 1 + 1 ) ) × 1 = 291.5\nE: ( 291.5 ÷ 1 ) × 1 = 291.5\n```\n\n值得注意的一点是，如果 `flex-grow` 和 `flex-shrink` 的取值都为 0，那么元素即不会放大也不会缩小，当所有元素的尺寸总和超过容器空间之后，就会产生溢出效果。\n\n### 设置 flex-wrap\n\n当所有元素的尺寸总和超过容器空间之后，就会产生溢出效果。我们可以通过设置 `flex-wrap: wrap` 来是超出的元素换行。\n\n我们调整下样式：\n```css\ndiv > div {\n    flex-basis: 500px;\n}\n[id=flex] {\n    flex-wrap: wrap;\n}\n```\n\n显示效果如下：\n\n![flex-wrap](/posts/images/how-flexbox-works/flex-wrap-c.png)\n\n我们可以看到，由于 `flex-basis: 500px` 且默认的 `flex-grow: 0`，因此每一行的末尾有 200px 的剩余空间。\n\n我们可以通过设置 `flex-grow: 1` 来让元素占满剩余空间。\n\n```css\ndiv > div {\n    flex: 1 1 500px;\n}\n```\n\n此时显示效果如下：\n\n![flex-wrap with flex-grow](/posts/images/how-flexbox-works/flex-wrap-with-grow-c.png)\n\n可以看到，每行的剩余空间都被占满了。\n\n## 总结\n\nFlexbox 布局有时候会有一些复杂和难以理解。在实际使用过程中，我们需要牢记如下几点：\n\n* Flexbox 只在单一方向上分配空间，行或者列。\n* flex-basis 定义了元素的最小尺寸，有时候元素的内容尺寸可能会比 flex-basis 定义的尺寸大。\n* 浏览器同时只会使用 flex-grow 或者 flex-shrink 来排列元素，不会同时使用。\n* 实际使用 flex-grow 还是 flex-shrink 取决于元素尺寸总和与容器剩余空间的大小。\n* 浏览器根据 flex 因子以及元素本身设置的系数来分配每个元素的空间。\n',contentRendered:'<p>Flexbox 是一种 CSS 布局机制，可以说是目前浏览器原生支持的最好、使用最广泛的布局机制了。本文通过一些例子来说明 Flexbox 布局的工作原理，可以让我们更好的使用 Flexbox。</p>\n<p>与 CSS Grid 可以同时在横向和纵向两个方向进行布局不同，Flexbox 只能在单一方向上进行布局，即要么横向，要么纵向。所谓布局，其实就是空间的分配过程，也就是说计算元素尺寸和容器剩余空间尺寸的过程。</p>\n<h2 id="flexbox-的布局原理" tabindex="-1"><a class="header-anchor" href="#flexbox-的布局原理" aria-hidden="true">#</a> Flexbox 的布局原理</h2>\n<p>整个布局过程我们可以简单的总结如下：</p>\n<ol>\n<li>计算 flex 容器内的可用空间。整个容器的尺寸减去容器的 border、padding 等所得的剩余空间尺寸。</li>\n<li>计算每个 flex 元素的 flex base 尺寸和元素的假设尺寸。具体计算方法是取 flex-basis、min-width 和 flex 元素内容尺寸的较大者。flex base 尺寸是 flex 元素需要的最小尺寸，这个尺寸不能小于元素内容的尺寸。元素的假设尺寸是指在 flex 因子生效前元素的尺寸，flex 因子生效后可能导致元素发生伸缩。</li>\n<li>计算容器内所有 flex 元素的假设尺寸总和。</li>\n<li>将所有元素的假设尺寸总和与容器内可用空间尺寸做比较，来确定 flex 因子，也就是说当假设尺寸总和超过容器内可用空间尺寸时，使用 flex-shrink，否则使用 flex-grow。在同一时间，flex-shrink 和 flex-grow 只有一个生效。</li>\n</ol>\n<p>所谓 flex 因子，简单来说就是缩小和放大。浏览器在进行 flexbox 布局时会先确定使用哪种 flex 因子，然后再根据选用的 flex 因子来对元素尺寸进行调整。</p>\n<p>在进行调整的时候，就会涉及到一个剩余空间的计算问题。如果 flex 元素明确指定了尺寸大小（<a href="https://drafts.csswg.org/css-sizing-3/#definite_" target="_blank" rel="noopener noreferrer">definite size<OutboundLink/></a>，比如设置了 width），那么这个元素就是不可伸缩的。如果没有显式指定尺寸，则会按照上面第2步那样计算假设尺寸。剩余空间的尺寸就是容器内的可用空间尺寸减去这些元素的尺寸之和。</p>\n<h2 id="例子说明" tabindex="-1"><a class="header-anchor" href="#例子说明" aria-hidden="true">#</a> 例子说明</h2>\n<p>我们有如下 dom 结构：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>flex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Antidisestablishmentarianism<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>c<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Cherries jubilee<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>d<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>D<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>e<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>E<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>样式如下：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">[id=flex]</span> <span class="token punctuation">{</span>\n    <span class="token property">font-weight</span><span class="token punctuation">:</span> 300<span class="token punctuation">;</span>\n    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>\n    <span class="token property">outline</span><span class="token punctuation">:</span> 1px dashed #555<span class="token punctuation">;</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 1200px<span class="token punctuation">;</span>\n    <span class="token property">margin</span><span class="token punctuation">:</span> 3rem auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token comment">/*其他样式已省略*/</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>页面展示效果如下：</p>\n<p><img src="/posts/images/how-flexbox-works/flex-c.png" alt="flex 布局"></p>\n<p>我们没有设置元素的 <code>flex</code> 样式属性，默认值是 <code>0 1 auto</code>。<code>flex</code> 样式属性是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 这三个样式属性的简写形式。<code>0 1 auto</code> 分别对应为 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 的值。</p>\n<p>通过取值可以看到，因为我们禁止了放大和收缩，并且 <code>flex-basis</code> 的值是 <code>auto</code>，浏览器就使用元素的最大内容尺寸来计算所有元素的尺寸总和，比容器的尺寸（1200px）小，所有会有额外的剩余空间。</p>\n<p>关于 <code>flex</code> 这个样式属性，我们额外做一些说明。<code>flex</code> 属性可以接收最少一个、最多三个属性值。</p>\n<p>当只有一个属性值的时候，<code>flex</code> 的工作模式是这样的 <code>&lt;number&gt; 1 0</code>。即 <code>flex: 2</code> 最终的结果是 <code>flex: 2 1 0</code>。</p>\n<p>当有两个属性值的时候，第一个值会被解析为 <code>flex-grow</code>，第二个值如果是数字，则会被解析为 <code>flex-shrink</code>，如果是一个<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/width" target="_blank" rel="noopener noreferrer">合法的宽度值<OutboundLink/></a>则会被解析为 <code>flex-basis</code>。即 <code>flex: 1 0</code> 解析为 <code>flex: 1 0 0</code>，而 <code>flex: 1 20rem</code> 则被解析为 <code>flex: 1 1 20rem</code>。</p>\n<p>当有三个属性值的时候，第一个值被解析为 <code>flex-grow</code>，第二个值必须为数字，且会被解析为 <code>flex-shrink</code>，第三个值则必须是合法的宽度值，被解析为 <code>flex-basis</code>。</p>\n<h3 id="设置-flex-grow" tabindex="-1"><a class="header-anchor" href="#设置-flex-grow" aria-hidden="true">#</a> 设置 flex-grow</h3>\n<p>我们增加如下样式设置:</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">[id=flex] > div</span> <span class="token punctuation">{</span>\n  <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>实际上等同于 <code>flex: 1 1 0</code>，即 <code>flex-grow: 1</code>。从前面的例子我们可以看到，所有元素的假设尺寸之和是小于容器剩余空间尺寸的，所以浏览器会使用 <code>flex-grow</code> 来作为 flex 因子，因为我们设置了 <code>flex-grow: 1</code> ，因此浏览器会等比放大所有的元素。如下图：</p>\n<p><img src="/posts/images/how-flexbox-works/flex-grow-c.png" alt="设置了 flex-grow 的 flex 布局"></p>\n<p>实际上浏览器会循环通过下面的公式来计算每个元素的最终尺寸：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>当前元素伸缩值 = (当前剩余空间 - 所有剩余元素的 flex-grow 值的和) * 当前元素的 flex-grow 值\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在上面的例子中，容器的剩余空间为 1200px，因此，通过公式计算：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>( 1200 ÷ ( 1 + 1 + 1 + 1 + 1 ) ) × 1 = 240\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>元素 A 的最终尺寸为 <code>240px + flex-basis = 240px + 0 = 240px</code>。但是，因为 <code>Antidisestablishmentarianism</code> 这个单词比较长，实际会占用 <code>417px</code> 的空间大小，因此元素 A 的最终尺寸为 <code>417px</code>。</p>\n<p>此时，在计算元素 B 的尺寸时，剩余空间为 <code>1200px - 417px = 783px</code>。元素 B 的伸缩值为：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>( 783 ÷ ( 1 + 1 + 1 + 1 ) ) × 1 = 195.75 0 + 195.75 = 195.75\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>同理，元素 C、D、E 的伸缩值分别为：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>C: ( 587 ÷ ( 1 + 1 + 1 ) ) × 1 ) = 195.67\nD: ( 391.33 ÷ ( 1 + 1 ) ) × 1 = 195.665\nE: ( 391 - 195.665 ÷ 1 ) × 1 = 195.335\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>总结来说，浏览器从剩余空间中减去已经分配的空间，然后计算下一个 flex 元素的伸缩值和最终大小。</p>\n<h3 id="差异化的-flex-grow" tabindex="-1"><a class="header-anchor" href="#差异化的-flex-grow" aria-hidden="true">#</a> 差异化的 flex-grow</h3>\n<p>我们修改一下元素的 <code>flex-grow</code> 值：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">div > :not([id=c])</span> <span class="token punctuation">{</span>\n  <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">[id=c]</span> <span class="token punctuation">{</span>\n  <span class="token property">flex</span><span class="token punctuation">:</span> 5<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>此时，页面展示效果如下：</p>\n<p><img src="/posts/images/how-flexbox-works/flex-grow-2-c.png" alt="差异化 flex-grow"></p>\n<p>各元素的伸缩值计算如下：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>A: 417px\nB: ( 783 ÷ ( 1 + 1 + 5 + 1 ) ) × 1 = 98\nC: ( 685 ÷ ( 5 + 1 + 1 ) ) × 5 = 490\nD: ( 195 ÷ ( 1 + 1 ) ) × 1 = 97.5\nE: ( 97.5 ÷ 1 ) × 1 = 97.5\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="设置-flex-basis-auto" tabindex="-1"><a class="header-anchor" href="#设置-flex-basis-auto" aria-hidden="true">#</a> 设置 <code>flex-basis: auto</code></h3>\n<p>前面的例子里，我们都设置了 <code>flex-basis</code> 的值为 0，现在我们设置 <code>flex-basis: auto</code>，再来看看元素尺寸是如何计算的。</p>\n<p>删除其他元素的 flex 指定，修改样式如下：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">[id=c]</span> <span class="token punctuation">{</span>\n  <span class="token property">flex</span><span class="token punctuation">:</span> 5<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>此时等价于其他元素是 <code>flex: 0 1 auto</code>，元素 C 是 <code>flex: 5 1 0</code>。展示效果如下：</p>\n<p><img src="/posts/images/how-flexbox-works/flex-basis-c.png" alt="flex-basis"></p>\n<p>在前面的例子中，所有元素都是 <code>flex-basis: 0</code>，现在设置为 A、B、D、E 都设置成了 <code>flex-basis: auto</code>。因此，元素 A、B、D、E 都会使用元素内容的尺寸来计算。</p>\n<p>因此，剩余剩余可分配空间大小为：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>1200 - ( 417 + 33 + 35 + 30 ) = 685\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>因为元素 C 是唯一可伸缩的元素，因此它的伸缩值为 685。</p>\n<h3 id="设置-flex-shrink" tabindex="-1"><a class="header-anchor" href="#设置-flex-shrink" aria-hidden="true">#</a> 设置 flex-shrink</h3>\n<p>现在我们做一些调整，让所有 flex 元素的尺寸总和大于容器的可用空间尺寸，使得 flex-shrink 生效。</p>\n<p>样式调整如下：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">:not([id=a])</span> <span class="token punctuation">{</span>\n    <span class="token property">flex-shrink</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">[id=a]</span> <span class="token punctuation">{</span>\n    <span class="token property">flex-shrink</span><span class="token punctuation">:</span> 5<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">div > div</span> <span class="token punctuation">{</span>\n    <span class="token property">flex-basis</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看到，所有元素 <code>flex-grow: 0</code>，元素 A <code>flex-shrink: 5</code>，其他元素 <code>flex-shrink: 1</code>，所有元素总尺寸 2500px。</p>\n<p>显示效果如下：\n<img src="/posts/images/how-flexbox-works/flex-shrink-c.png" alt="flex-shrink"></p>\n<p>因为元素尺寸总和超过了容器可用尺寸（1200px），因此 flex-shrink 将会生效。</p>\n<p>元素 A 的伸缩值为：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>( 1300 ÷  ( 5 + 1 + 1 + 1 + 1 ) ) × 5 = 722.22\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>则元素 A 的实际尺寸计算为：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>500 - 722.22 = -222.22\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>可以看到得出的是负值。如果元素 A 是空元素，那么最终尺寸会是零。本例中，元素 A 的尺寸就是起内容的尺寸，大概 34px。</p>\n<p>确定了元素 A 的尺寸之后，容器剩余空间尺寸为 <code>1200 - 34 = 1166</code>。其他元素的伸缩值计算为：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>B: ( 1166 ÷ ( 1 + 1 + 1 + 1 ) ) × 1 = 291.5\nC: ( 874.5 ÷ ( 1 + 1 + 1 ) ) × 1 = 291.5\nD: ( 583 ÷ ( 1 + 1 ) ) × 1 = 291.5\nE: ( 291.5 ÷ 1 ) × 1 = 291.5\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>值得注意的一点是，如果 <code>flex-grow</code> 和 <code>flex-shrink</code> 的取值都为 0，那么元素即不会放大也不会缩小，当所有元素的尺寸总和超过容器空间之后，就会产生溢出效果。</p>\n<h3 id="设置-flex-wrap" tabindex="-1"><a class="header-anchor" href="#设置-flex-wrap" aria-hidden="true">#</a> 设置 flex-wrap</h3>\n<p>当所有元素的尺寸总和超过容器空间之后，就会产生溢出效果。我们可以通过设置 <code>flex-wrap: wrap</code> 来是超出的元素换行。</p>\n<p>我们调整下样式：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">div > div</span> <span class="token punctuation">{</span>\n    <span class="token property">flex-basis</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">[id=flex]</span> <span class="token punctuation">{</span>\n    <span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>显示效果如下：</p>\n<p><img src="/posts/images/how-flexbox-works/flex-wrap-c.png" alt="flex-wrap"></p>\n<p>我们可以看到，由于 <code>flex-basis: 500px</code> 且默认的 <code>flex-grow: 0</code>，因此每一行的末尾有 200px 的剩余空间。</p>\n<p>我们可以通过设置 <code>flex-grow: 1</code> 来让元素占满剩余空间。</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">div > div</span> <span class="token punctuation">{</span>\n    <span class="token property">flex</span><span class="token punctuation">:</span> 1 1 500px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>此时显示效果如下：</p>\n<p><img src="/posts/images/how-flexbox-works/flex-wrap-with-grow-c.png" alt="flex-wrap with flex-grow"></p>\n<p>可以看到，每行的剩余空间都被占满了。</p>\n<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>\n<p>Flexbox 布局有时候会有一些复杂和难以理解。在实际使用过程中，我们需要牢记如下几点：</p>\n<ul>\n<li>Flexbox 只在单一方向上分配空间，行或者列。</li>\n<li>flex-basis 定义了元素的最小尺寸，有时候元素的内容尺寸可能会比 flex-basis 定义的尺寸大。</li>\n<li>浏览器同时只会使用 flex-grow 或者 flex-shrink 来排列元素，不会同时使用。</li>\n<li>实际使用 flex-grow 还是 flex-shrink 取决于元素尺寸总和与容器剩余空间的大小。</li>\n<li>浏览器根据 flex 因子以及元素本身设置的系数来分配每个元素的空间。</li>\n</ul>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-03-31",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/how-flexbox-works.html",pathLocale:"/",permalink:"/posts/2022/03/31/how-flexbox-works.html",slug:"how-flexbox-works",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/how-flexbox-works.md",filePathRelative:"posts/how-flexbox-works.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/03/31/how-flexbox-works.html.vue",componentFilePathRelative:"pages/posts/2022/03/31/how-flexbox-works.html.vue",componentFileChunkName:"v-50a5c4e0",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/03/31/how-flexbox-works.html.js",dataFilePathRelative:"pages/posts/2022/03/31/how-flexbox-works.html.js",dataFileChunkName:"v-50a5c4e0",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2022/03/31/how-flexbox-works.html",htmlFilePathRelative:"posts/2022/03/31/how-flexbox-works.html"},{key:"v-09649102",path:"/posts/2021/07/06/how-process-exit.html",title:"NodeJS 进程是如何退出的",lang:"zh-CN",frontmatter:{title:"NodeJS 进程是如何退出的",description:"描述导致 NodeJS 进程退出的几种情况，以及如何处理。",keywords:["NodeJS 进程","异常处理"],date:"2021-07-06T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"主动退出",slug:"主动退出",children:[]},{level:2,title:"Exceptions, Rejections 和 Emitted Errors",slug:"exceptions-rejections-和-emitted-errors",children:[]},{level:2,title:"信号",slug:"信号",children:[]},{level:2,title:"小结",slug:"小结",children:[]}],content:'\n有几种因素可以导致 NodeJS 进程退出。在这些因素中，有些是可预防的，比如代码抛出了一个异常；有些是不可预防的，比如内存耗尽。`process` 这个全局变量是一个 Event Emitter 实例，如果进程优雅退出，`process` 会派发一个 `exit` 事件。应用代码可以监听这个事件，来做最后的清理工作。\n\n下面的表格列举了可以导致进程退出的因素。\n\n| 操作                       | 举例                         |\n| :------------------------- | :--------------------------- |\n| 手动退出                   | `process.exit(1)`            |\n| 未捕获的异常               | `throw new Error()`          |\n| 未处理的 promise rejection | `Promise.reject()`           |\n| 未处理的 error 事件        | `EventEmitter#emit(\'error\')` |\n| 未处理的信号               | `kill <PROCESS_ID>`          |\n\n## 主动退出\n\n`process.exit(code)` 是最直接的结束进程的方法。`code` 参数是可选的，可以为 0 ~ 255 之间任何数字，默认为 0。0 表示进程执行成功，非 0 数字表示进程执行失败。\n\n当 `process.exit()` 被使用时，控制台不会有任何输出，如果我们想在进程推出的时候像控制台输出一些错误说明信息，则需要在调用之前显示的输出错误信息。\n\n```bash\nnode -e "process.exit(42)"\necho $?\n```\n\n上面的代码直接退出了 NodeJS 进程，命令行没有任何输出信息。用户在遭遇进程退出的时候，无法获取有效的错误信息。\n\n```js\nfunction checkConfig(config) {\n  if (!config.host) {\n    console.error("Configuration is missing \'host\' parameter!");\n    process.exit(1);\n  }\n}\n```\n\n在上面的代码中，我们在进程退出之前输出的明确的错误信息。\n\n`process.exit()` 的功能非常强大，但是我们不应该在工具库中使用。如果在工具库中遇到的错误，我们应该以异常的形式抛出，从而让应用代码决定如何处理这个错误。\n\n## Exceptions, Rejections 和 Emitted Errors\n\n`process.exit()` 在应用启动配置检查等场景中非常有用，但是在处理运行时异常时，它并不适用，我们需要其他的工具。\n\n比如当应用在处理一个 HTTP 请求时，一个错误不应该导致进程终止，相反，我们应该返回一个含有错误信息的响应。\n\n`Error` 类可以包含描述错误发生的详细信息的数据，比如调用堆栈和错误文本。通常我们会定义特定场景的 XXXError，这些 XXXError 都继承制 `Error` 类。\n\n当我们使用 `throw` 关键字，或者代码逻辑出错时，一个错误就会被抛出。此时，系统调用栈会释放，每个函数会退出，直到遇到一个 包裹了当前调用的 try/catch 语句。如果没有 try/catch 语句，则这个错误会被认为是未捕获的异常。\n\n> 通常，在 NodeJS 应用中，我们会给 Error 类定义一个 `code` 属性，作为用来描述具体错误的错误码，这么做的优点是可以使错误码保持唯一，同时还能使得错误码是可读的。同时，我们也可以配合 `message` 属性来描述具体的错误信息。\n\n当一个未捕获的异常抛出时，控制台会打印调用堆栈，同时进程退出，退出状态码为 1.\n\n```\n/tmp/foo.js:1\nthrow new TypeError(\'invalid foo\');\n^\nError: invalid foo\n    at Object.<anonymous> (/tmp/foo.js:2:11)\n    ... TRUNCATED ...\n    at internal/main/run_main_module.js:17:47\n```\n\n这段控制台输出信息说明，错误发生在 `foo.js` 中的第 2 行第 11 列。\n\n全局变量 `process` 是个 Event Emitter 实例，可以通过监听 `uncaughtException` 事件来处理这些未捕获异常。下面的代码展示了如何使用：\n\n```js\nconst logger = require("./lib/logger.js");\nprocess.on("uncaughtException", (error) => {\n  logger.send("An uncaught exception has occured", error, () => {\n    console.error(error);\n    process.exit(1);\n  });\n});\n```\n\nPromise Rejection 与抛出异常类似。我们可以通过调用 `reject()` 函数或者在 `async` 函数中抛出异常来是的 promise 到达 rejected 状态。下面的两段代码功能是相似的。\n\n```js\nPromise.reject(new Error("oh no"));\n\n(async () => {\n  throw new Error("oh no");\n})();\n```\n\n目前，在 NodeJS 14 中，Promise Rejection 不会导致进程退出，在后续的版本中，Promise Rejection 可能会导致进程退出。\n\n下面是一段未捕获的 Promise Rejection 的控制台输出样例。\n\n```\n(node:52298) UnhandledPromiseRejectionWarning: Error: oh no\n    at Object.<anonymous> (/tmp/reject.js:1:16)\n    ... TRUNCATED ...\n    at internal/main/run_main_module.js:17:47\n(node:52298) UnhandledPromiseRejectionWarning: Unhandled promise\n  rejection. This error originated either by throwing inside of an\n  async function without a catch block, or by rejecting a promise\n  which was not handled with .catch().\n```\n\n我们可以通过监听 `unhandledRejection` 事件来处理未捕获的 Rejection. 样例代码如下：\n\n```js\nprocess.on("unhandledRejection", (reason, promise) => {});\n```\n\nEvent Emitter 是 NodeJS 中的基础模块，应用广泛。当 Event Emitter 的 `error` 事件未被处理时，Event Emitter 就会抛出一个错误，同时会导致进程退出。下面是一个 Event Emitter `error` 的控制台输出。\n\n```\nevents.js:306\n    throw err; // Unhandled \'error\' event\n    ^\nError [ERR_UNHANDLED_ERROR]: Unhandled error. (undefined)\n    at EventEmitter.emit (events.js:304:17)\n    at Object.<anonymous> (/tmp/foo.js:1:40)\n    ... TRUNCATED ...\n    at internal/main/run_main_module.js:17:47 {\n  code: \'ERR_UNHANDLED_ERROR\',\n  context: undefined\n}\n```\n\n因此，我们在使用 Event Emitter 的时候，要确保监听了 `error` 事件，这样在发生错误的时候，可以使得应用能够处理这些错误，避免奔溃。\n\n## 信号\n\n信号是操作信息提供了进程间通信机制。信号通常是一个数字，同时也可以使用一个字符串来标识。比如 `SIGKILL` 标识数字 9。不同的操作系统对信号的定义不同。下面表格里罗列的是基本通用的信号定义。\n\n| 名称      | 数字 | 是否可处理 | NodeJS 默认行为 | 信号的含义                  |\n| :-------- | :--- | :--------- | :-------------- | :-------------------------- |\n| `SIGHUP`  | 1    | Yes        | 退出            | 父命令行被关闭              |\n| `SIGINT`  | 2    | Yes        | 退出            | 命令行尝试中断，即 Ctrl + C |\n| `SIGQUIT` | 3    | Yes        | 退出            | 命令行尝试退出，即 Ctrl + Z |\n| `SIGKILL` | 9    | No         | 退出            | 强制进程退出                |\n| `SIGUSR1` | 10   | Yes        | 启动调试器      | 用户自定义信号              |\n| `SIGUSR2` | 12   | Yes        | 退出            | 用户自定义信号              |\n| `SIGTERM` | 15   | Yes        | 退出            | 进程优雅的退出              |\n| `SIGSTOP` | 19   | No         | 退出            | 进程被强制停止              |\n\n这表格里，是否可处理表示这个信号是否可被进程接收并被处理。NodeJS 默认行为表示进程在接收到这个信号以后默认执行的动作。\n\n我们可以通过如下方式来监听这些信号。\n\n```js\n#!/usr/bin/env node\nconsole.log(`Process ID: ${process.pid}`);\nprocess.on("SIGHUP", () => console.log("Received: SIGHUP"));\nprocess.on("SIGINT", () => console.log("Received: SIGINT"));\nsetTimeout(() => {}, 5 * 60 * 1000); // keep process alive\n```\n\n在一个命令行窗口中运行这段代码，然后按下 Ctrl + C，此时进程不会退出，而是会在控制台打印一行接收到了 `SIGINT` 信号的日志信息。新起一个命令行窗口，执行如下命令，PROCESS_ID 为上面程序输出的进程 ID。\n\n```bash\nkill -s SIGHUP <PROCESS_ID>\n```\n\n通过新起的命令行，我们向原来的那个程序进程发送了一个 `SIGHUP` 信号，原来的命令行窗口中会打印一行接收到了 `SIGHUP` 信号的日志信息。\n\n在 NodeJS 代码中，进程也可以给其他进程发送信号。比如：\n\n```bash\nnode -e "process.kill(<PROCESS_ID>, \'SIGHUP\')"\n```\n\n这段代码同样会在第一个命令行窗口中输出一行接收到了 `SIGHUP` 信号的日志。\n\n如果我们要让第一个命令行窗口的进程退出，则可以通过下面的命令来实现。\n\n```bash\nkill -9 <PROCESS_ID>\n```\n\n在 NodeJS 中，信号通常被用作控制进程优雅的退出。比如，在 [Kubernetes](https://kubernetes.io/) 中，当一个 pod 要退出时，k8s 会像 pod 内的进程发送一个 `SIGTERM` 的信号，同时启动一个 30 秒的定时器。应用程序有 30 秒的时间来关闭连接、保存数据等。如果 30 秒之后进程依然存活，k8s 会再发送一个 `SIGKILL` 来强制关闭进程。\n\n## 小结\n\n本文讲述了可以导致进程退出的几种因素，分别是：\n\n- 主动退出\n- 未捕获的异常、未处理的 promise rejection、未处理的 Event Emitter error 事件\n- 系统信号\n\n我们对每种因素的作用原理和使用方法做了说明。\n',contentRendered:'<p>有几种因素可以导致 NodeJS 进程退出。在这些因素中，有些是可预防的，比如代码抛出了一个异常；有些是不可预防的，比如内存耗尽。<code>process</code> 这个全局变量是一个 Event Emitter 实例，如果进程优雅退出，<code>process</code> 会派发一个 <code>exit</code> 事件。应用代码可以监听这个事件，来做最后的清理工作。</p>\n<p>下面的表格列举了可以导致进程退出的因素。</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">操作</th>\n<th style="text-align:left">举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">手动退出</td>\n<td style="text-align:left"><code>process.exit(1)</code></td>\n</tr>\n<tr>\n<td style="text-align:left">未捕获的异常</td>\n<td style="text-align:left"><code>throw new Error()</code></td>\n</tr>\n<tr>\n<td style="text-align:left">未处理的 promise rejection</td>\n<td style="text-align:left"><code>Promise.reject()</code></td>\n</tr>\n<tr>\n<td style="text-align:left">未处理的 error 事件</td>\n<td style="text-align:left"><code>EventEmitter#emit(\'error\')</code></td>\n</tr>\n<tr>\n<td style="text-align:left">未处理的信号</td>\n<td style="text-align:left"><code>kill &lt;PROCESS_ID&gt;</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id="主动退出" tabindex="-1"><a class="header-anchor" href="#主动退出" aria-hidden="true">#</a> 主动退出</h2>\n<p><code>process.exit(code)</code> 是最直接的结束进程的方法。<code>code</code> 参数是可选的，可以为 0 ~ 255 之间任何数字，默认为 0。0 表示进程执行成功，非 0 数字表示进程执行失败。</p>\n<p>当 <code>process.exit()</code> 被使用时，控制台不会有任何输出，如果我们想在进程推出的时候像控制台输出一些错误说明信息，则需要在调用之前显示的输出错误信息。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>node -e <span class="token string">"process.exit(42)"</span>\n<span class="token builtin class-name">echo</span> <span class="token variable">$?</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面的代码直接退出了 NodeJS 进程，命令行没有任何输出信息。用户在遭遇进程退出的时候，无法获取有效的错误信息。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">checkConfig</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span>host<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Configuration is missing \'host\' parameter!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上面的代码中，我们在进程退出之前输出的明确的错误信息。</p>\n<p><code>process.exit()</code> 的功能非常强大，但是我们不应该在工具库中使用。如果在工具库中遇到的错误，我们应该以异常的形式抛出，从而让应用代码决定如何处理这个错误。</p>\n<h2 id="exceptions-rejections-和-emitted-errors" tabindex="-1"><a class="header-anchor" href="#exceptions-rejections-和-emitted-errors" aria-hidden="true">#</a> Exceptions, Rejections 和 Emitted Errors</h2>\n<p><code>process.exit()</code> 在应用启动配置检查等场景中非常有用，但是在处理运行时异常时，它并不适用，我们需要其他的工具。</p>\n<p>比如当应用在处理一个 HTTP 请求时，一个错误不应该导致进程终止，相反，我们应该返回一个含有错误信息的响应。</p>\n<p><code>Error</code> 类可以包含描述错误发生的详细信息的数据，比如调用堆栈和错误文本。通常我们会定义特定场景的 XXXError，这些 XXXError 都继承制 <code>Error</code> 类。</p>\n<p>当我们使用 <code>throw</code> 关键字，或者代码逻辑出错时，一个错误就会被抛出。此时，系统调用栈会释放，每个函数会退出，直到遇到一个 包裹了当前调用的 try/catch 语句。如果没有 try/catch 语句，则这个错误会被认为是未捕获的异常。</p>\n<blockquote>\n<p>通常，在 NodeJS 应用中，我们会给 Error 类定义一个 <code>code</code> 属性，作为用来描述具体错误的错误码，这么做的优点是可以使错误码保持唯一，同时还能使得错误码是可读的。同时，我们也可以配合 <code>message</code> 属性来描述具体的错误信息。</p>\n</blockquote>\n<p>当一个未捕获的异常抛出时，控制台会打印调用堆栈，同时进程退出，退出状态码为 1.</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>/tmp/foo.js:1\nthrow new TypeError(\'invalid foo\');\n^\nError: invalid foo\n    at Object.&lt;anonymous> (/tmp/foo.js:2:11)\n    ... TRUNCATED ...\n    at internal/main/run_main_module.js:17:47\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这段控制台输出信息说明，错误发生在 <code>foo.js</code> 中的第 2 行第 11 列。</p>\n<p>全局变量 <code>process</code> 是个 Event Emitter 实例，可以通过监听 <code>uncaughtException</code> 事件来处理这些未捕获异常。下面的代码展示了如何使用：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> logger <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./lib/logger.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nprocess<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"uncaughtException"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  logger<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"An uncaught exception has occured"</span><span class="token punctuation">,</span> error<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Promise Rejection 与抛出异常类似。我们可以通过调用 <code>reject()</code> 函数或者在 <code>async</code> 函数中抛出异常来是的 promise 到达 rejected 状态。下面的两段代码功能是相似的。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"oh no"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"oh no"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>目前，在 NodeJS 14 中，Promise Rejection 不会导致进程退出，在后续的版本中，Promise Rejection 可能会导致进程退出。</p>\n<p>下面是一段未捕获的 Promise Rejection 的控制台输出样例。</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>(node:52298) UnhandledPromiseRejectionWarning: Error: oh no\n    at Object.&lt;anonymous> (/tmp/reject.js:1:16)\n    ... TRUNCATED ...\n    at internal/main/run_main_module.js:17:47\n(node:52298) UnhandledPromiseRejectionWarning: Unhandled promise\n  rejection. This error originated either by throwing inside of an\n  async function without a catch block, or by rejecting a promise\n  which was not handled with .catch().\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>我们可以通过监听 <code>unhandledRejection</code> 事件来处理未捕获的 Rejection. 样例代码如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"unhandledRejection"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">reason<span class="token punctuation">,</span> promise</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Event Emitter 是 NodeJS 中的基础模块，应用广泛。当 Event Emitter 的 <code>error</code> 事件未被处理时，Event Emitter 就会抛出一个错误，同时会导致进程退出。下面是一个 Event Emitter <code>error</code> 的控制台输出。</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>events.js:306\n    throw err; // Unhandled \'error\' event\n    ^\nError [ERR_UNHANDLED_ERROR]: Unhandled error. (undefined)\n    at EventEmitter.emit (events.js:304:17)\n    at Object.&lt;anonymous> (/tmp/foo.js:1:40)\n    ... TRUNCATED ...\n    at internal/main/run_main_module.js:17:47 {\n  code: \'ERR_UNHANDLED_ERROR\',\n  context: undefined\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>因此，我们在使用 Event Emitter 的时候，要确保监听了 <code>error</code> 事件，这样在发生错误的时候，可以使得应用能够处理这些错误，避免奔溃。</p>\n<h2 id="信号" tabindex="-1"><a class="header-anchor" href="#信号" aria-hidden="true">#</a> 信号</h2>\n<p>信号是操作信息提供了进程间通信机制。信号通常是一个数字，同时也可以使用一个字符串来标识。比如 <code>SIGKILL</code> 标识数字 9。不同的操作系统对信号的定义不同。下面表格里罗列的是基本通用的信号定义。</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">名称</th>\n<th style="text-align:left">数字</th>\n<th style="text-align:left">是否可处理</th>\n<th style="text-align:left">NodeJS 默认行为</th>\n<th style="text-align:left">信号的含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><code>SIGHUP</code></td>\n<td style="text-align:left">1</td>\n<td style="text-align:left">Yes</td>\n<td style="text-align:left">退出</td>\n<td style="text-align:left">父命令行被关闭</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>SIGINT</code></td>\n<td style="text-align:left">2</td>\n<td style="text-align:left">Yes</td>\n<td style="text-align:left">退出</td>\n<td style="text-align:left">命令行尝试中断，即 Ctrl + C</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>SIGQUIT</code></td>\n<td style="text-align:left">3</td>\n<td style="text-align:left">Yes</td>\n<td style="text-align:left">退出</td>\n<td style="text-align:left">命令行尝试退出，即 Ctrl + Z</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>SIGKILL</code></td>\n<td style="text-align:left">9</td>\n<td style="text-align:left">No</td>\n<td style="text-align:left">退出</td>\n<td style="text-align:left">强制进程退出</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>SIGUSR1</code></td>\n<td style="text-align:left">10</td>\n<td style="text-align:left">Yes</td>\n<td style="text-align:left">启动调试器</td>\n<td style="text-align:left">用户自定义信号</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>SIGUSR2</code></td>\n<td style="text-align:left">12</td>\n<td style="text-align:left">Yes</td>\n<td style="text-align:left">退出</td>\n<td style="text-align:left">用户自定义信号</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>SIGTERM</code></td>\n<td style="text-align:left">15</td>\n<td style="text-align:left">Yes</td>\n<td style="text-align:left">退出</td>\n<td style="text-align:left">进程优雅的退出</td>\n</tr>\n<tr>\n<td style="text-align:left"><code>SIGSTOP</code></td>\n<td style="text-align:left">19</td>\n<td style="text-align:left">No</td>\n<td style="text-align:left">退出</td>\n<td style="text-align:left">进程被强制停止</td>\n</tr>\n</tbody>\n</table>\n<p>这表格里，是否可处理表示这个信号是否可被进程接收并被处理。NodeJS 默认行为表示进程在接收到这个信号以后默认执行的动作。</p>\n<p>我们可以通过如下方式来监听这些信号。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token hashbang comment">#!/usr/bin/env node</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Process ID: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>process<span class="token punctuation">.</span>pid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nprocess<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"SIGHUP"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Received: SIGHUP"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nprocess<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"SIGINT"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Received: SIGINT"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// keep process alive</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在一个命令行窗口中运行这段代码，然后按下 Ctrl + C，此时进程不会退出，而是会在控制台打印一行接收到了 <code>SIGINT</code> 信号的日志信息。新起一个命令行窗口，执行如下命令，PROCESS_ID 为上面程序输出的进程 ID。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">kill</span> -s SIGHUP <span class="token operator">&lt;</span>PROCESS_ID<span class="token operator">></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>通过新起的命令行，我们向原来的那个程序进程发送了一个 <code>SIGHUP</code> 信号，原来的命令行窗口中会打印一行接收到了 <code>SIGHUP</code> 信号的日志信息。</p>\n<p>在 NodeJS 代码中，进程也可以给其他进程发送信号。比如：</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>node -e <span class="token string">"process.kill(&lt;PROCESS_ID>, \'SIGHUP\')"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这段代码同样会在第一个命令行窗口中输出一行接收到了 <code>SIGHUP</code> 信号的日志。</p>\n<p>如果我们要让第一个命令行窗口的进程退出，则可以通过下面的命令来实现。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">kill</span> -9 <span class="token operator">&lt;</span>PROCESS_ID<span class="token operator">></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在 NodeJS 中，信号通常被用作控制进程优雅的退出。比如，在 <a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer">Kubernetes<OutboundLink/></a> 中，当一个 pod 要退出时，k8s 会像 pod 内的进程发送一个 <code>SIGTERM</code> 的信号，同时启动一个 30 秒的定时器。应用程序有 30 秒的时间来关闭连接、保存数据等。如果 30 秒之后进程依然存活，k8s 会再发送一个 <code>SIGKILL</code> 来强制关闭进程。</p>\n<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>本文讲述了可以导致进程退出的几种因素，分别是：</p>\n<ul>\n<li>主动退出</li>\n<li>未捕获的异常、未处理的 promise rejection、未处理的 Event Emitter error 事件</li>\n<li>系统信号</li>\n</ul>\n<p>我们对每种因素的作用原理和使用方法做了说明。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-07-06",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/how-process-exit.html",pathLocale:"/",permalink:"/posts/2021/07/06/how-process-exit.html",slug:"how-process-exit",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/how-process-exit.md",filePathRelative:"posts/how-process-exit.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/06/how-process-exit.html.vue",componentFilePathRelative:"pages/posts/2021/07/06/how-process-exit.html.vue",componentFileChunkName:"v-09649102",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/06/how-process-exit.html.js",dataFilePathRelative:"pages/posts/2021/07/06/how-process-exit.html.js",dataFileChunkName:"v-09649102",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/07/06/how-process-exit.html",htmlFilePathRelative:"posts/2021/07/06/how-process-exit.html"},{key:"v-8c4b41aa",path:"/posts/2021/08/25/how-to-decompose-component.html",title:"介绍一个组件拆分方法",lang:"zh-CN",frontmatter:{title:"介绍一个组件拆分方法",description:"如何将组件分解为子组件有时候是一件非常棘手的事情。今天我们借鉴一篇论文中思路，总结一个组件拆分方法。当需要拆分组件的时候，可以参考这个方法，审视一下组件拆分是否合理。",keywords:["软件设计","组件拆分"],date:"2021-08-25T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"拆分原则",slug:"拆分原则",children:[]},{level:2,title:"好的拆分实践",slug:"好的拆分实践",children:[]},{level:2,title:"不好的拆分实践",slug:"不好的拆分实践",children:[]},{level:2,title:"总结",slug:"总结",children:[]}],content:"\n不管是 React 和 Vue，在开发组件这块，都讲究利用组合来复用组件。但是如何将组件分解成多个子组件，有时候却是一件非常棘手的问题。拆分的不合理，非但不能提高组件的复用性，还会带来额外的维护成本。\n\n在这篇[设计易于扩展和收缩的软件](http://www.cse.msu.edu/~cse870/Materials/Parnas/extension-contraction-TSE-March-1979.pdf)论文中，作者介绍了一种软件设计思路，我们整理了下，发现不失为一种解决组件拆分的方法。今天我们就来讲一讲论文中的思路。\n\n## 拆分原则\n\n论文中的思路，大致可以归纳为一个基本原则，当满足如下四个条件的时候，我们可以从组件 A 中拆分出来组件 B：\n\n1. A 因为使用了 B，而变得更简单，更易于实现。\n2. B 不能使用 A，即不允许 A、B 之间存在循环依赖。\n3. B 可以作为独立单元被其他组件使用。\n4. 去除 B 以后，A 的功能没有实际意义。\n\n现在我们结合样例来看看如何使用这个原则来拆分组件。\n\n假设我们有一个视频播放器组件，有如下几个功能：\n\n1. 支持按照 16:9 的比例播放视频。\n2. 可以随时播放和暂停播放。\n3. 支持随意拖动视频播放进度。\n4. 支持静音。\n5. 支持全屏播放。\n\n![视频播放器](/posts/images/decompose-components/videoplayer-c.png)\n\n\n## 好的拆分实践\n\n![好的拆分实践](/posts/images/decompose-components/valid-split-c.png)\n\n如上图所示，我们拆分出来四个组件：一个[可控制高宽比](https://css-tricks.com/aspect-ratio-boxes/)的展示组件 AspectRatioBox，一个滑动条，按钮和图标。\n\n现在我们来使用上面的拆分原则来考察一下 AspectRatioBox 这个组件。\n\n组件 VideoPlayer 因为使用了 AspectRatioBox 而变得更加简单，否则 VideoPlayer 得自己实现高宽比的功能。\n\n组件 AspectRatioBox 不使用组件 VideoPlayer 的任何功能，也没有任何场景需要使用到组件 VideoPlayer 的功能，满足要求。\n\n除去组件 VideoPlayer，AspectRatioBox 可以单独使用，即组件 AspectRatioBox 可以复用在任何需要控制高宽比的地方。\n\n组件 VideoPlayer 在去除组件 AspectRatioBox 以后，就丧失了视频播放的完整功能。\n\n因此，AspectRatioBox 的拆分是符合原则的，即是一个好的拆分方案。\n\n> 有时候我们在拆分的时候，并不会像这个例子中描述的一样这么明显。这种情况下，我们可以先大致进行拆分，然后在具体实现的时候不断调整。\n\n## 不好的拆分实践\n\n![不好的拆分实践](/posts/images/decompose-components/invalid-split-c.png)\n\n如上图所示，我们从 VideoPlayer 中拆分出一个 ActionsBar 组件。这个 ActionsBar 组件包含所有与用户交互相关的功能。\n\n同样，结合上面的拆分原则，我们考察一下 ActionsBar 这个组件。\n\n首先，在 VideoPlayer 是否因为使用了 ActionsBar 而变得简单这点上就存在讨论空间的。因为 ActionsBar 组件为了响应用户操作，势必需要传入各种回调函数。VideoPlayer 就需要在其内部定义这些回调函数，然后再传递给 ActionsBar。\n\n组件 ActionsBar 不会使用 VideoPlayer 的任何功能，这点是符合要求的。\n\n除去组件 VideoPlayer，ActionsBar 组件就丧失了存在的意义，无法在其他地方复用了。\n\n组件 VideoPlayer 永远需要与组件 ActionsBar 一起使用，否则就没有播放视频的功能了。这点符合要求。\n\n基于以上考察，我们可以认为组件 ActionsBar 的拆分是不合理的。\n\n## 总结\n\n在上面的例子中，我们通过文章开头的指导原则来对 UI 组件进行拆分。其实，这个指导原则还可以用在任何其他地方，比如函数、模块设计等。\n\n组件的拆分不是一层不变的，随着代码的变迁，功能的迭代，最初的拆分方案已经不在符合上述的原则，那么我们就需要重新审视组件的拆分方案，来优化组件。\n",contentRendered:'<p>不管是 React 和 Vue，在开发组件这块，都讲究利用组合来复用组件。但是如何将组件分解成多个子组件，有时候却是一件非常棘手的问题。拆分的不合理，非但不能提高组件的复用性，还会带来额外的维护成本。</p>\n<p>在这篇<a href="http://www.cse.msu.edu/~cse870/Materials/Parnas/extension-contraction-TSE-March-1979.pdf" target="_blank" rel="noopener noreferrer">设计易于扩展和收缩的软件<OutboundLink/></a>论文中，作者介绍了一种软件设计思路，我们整理了下，发现不失为一种解决组件拆分的方法。今天我们就来讲一讲论文中的思路。</p>\n<h2 id="拆分原则" tabindex="-1"><a class="header-anchor" href="#拆分原则" aria-hidden="true">#</a> 拆分原则</h2>\n<p>论文中的思路，大致可以归纳为一个基本原则，当满足如下四个条件的时候，我们可以从组件 A 中拆分出来组件 B：</p>\n<ol>\n<li>A 因为使用了 B，而变得更简单，更易于实现。</li>\n<li>B 不能使用 A，即不允许 A、B 之间存在循环依赖。</li>\n<li>B 可以作为独立单元被其他组件使用。</li>\n<li>去除 B 以后，A 的功能没有实际意义。</li>\n</ol>\n<p>现在我们结合样例来看看如何使用这个原则来拆分组件。</p>\n<p>假设我们有一个视频播放器组件，有如下几个功能：</p>\n<ol>\n<li>支持按照 16:9 的比例播放视频。</li>\n<li>可以随时播放和暂停播放。</li>\n<li>支持随意拖动视频播放进度。</li>\n<li>支持静音。</li>\n<li>支持全屏播放。</li>\n</ol>\n<p><img src="/posts/images/decompose-components/videoplayer-c.png" alt="视频播放器"></p>\n<h2 id="好的拆分实践" tabindex="-1"><a class="header-anchor" href="#好的拆分实践" aria-hidden="true">#</a> 好的拆分实践</h2>\n<p><img src="/posts/images/decompose-components/valid-split-c.png" alt="好的拆分实践"></p>\n<p>如上图所示，我们拆分出来四个组件：一个<a href="https://css-tricks.com/aspect-ratio-boxes/" target="_blank" rel="noopener noreferrer">可控制高宽比<OutboundLink/></a>的展示组件 AspectRatioBox，一个滑动条，按钮和图标。</p>\n<p>现在我们来使用上面的拆分原则来考察一下 AspectRatioBox 这个组件。</p>\n<p>组件 VideoPlayer 因为使用了 AspectRatioBox 而变得更加简单，否则 VideoPlayer 得自己实现高宽比的功能。</p>\n<p>组件 AspectRatioBox 不使用组件 VideoPlayer 的任何功能，也没有任何场景需要使用到组件 VideoPlayer 的功能，满足要求。</p>\n<p>除去组件 VideoPlayer，AspectRatioBox 可以单独使用，即组件 AspectRatioBox 可以复用在任何需要控制高宽比的地方。</p>\n<p>组件 VideoPlayer 在去除组件 AspectRatioBox 以后，就丧失了视频播放的完整功能。</p>\n<p>因此，AspectRatioBox 的拆分是符合原则的，即是一个好的拆分方案。</p>\n<blockquote>\n<p>有时候我们在拆分的时候，并不会像这个例子中描述的一样这么明显。这种情况下，我们可以先大致进行拆分，然后在具体实现的时候不断调整。</p>\n</blockquote>\n<h2 id="不好的拆分实践" tabindex="-1"><a class="header-anchor" href="#不好的拆分实践" aria-hidden="true">#</a> 不好的拆分实践</h2>\n<p><img src="/posts/images/decompose-components/invalid-split-c.png" alt="不好的拆分实践"></p>\n<p>如上图所示，我们从 VideoPlayer 中拆分出一个 ActionsBar 组件。这个 ActionsBar 组件包含所有与用户交互相关的功能。</p>\n<p>同样，结合上面的拆分原则，我们考察一下 ActionsBar 这个组件。</p>\n<p>首先，在 VideoPlayer 是否因为使用了 ActionsBar 而变得简单这点上就存在讨论空间的。因为 ActionsBar 组件为了响应用户操作，势必需要传入各种回调函数。VideoPlayer 就需要在其内部定义这些回调函数，然后再传递给 ActionsBar。</p>\n<p>组件 ActionsBar 不会使用 VideoPlayer 的任何功能，这点是符合要求的。</p>\n<p>除去组件 VideoPlayer，ActionsBar 组件就丧失了存在的意义，无法在其他地方复用了。</p>\n<p>组件 VideoPlayer 永远需要与组件 ActionsBar 一起使用，否则就没有播放视频的功能了。这点符合要求。</p>\n<p>基于以上考察，我们可以认为组件 ActionsBar 的拆分是不合理的。</p>\n<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>\n<p>在上面的例子中，我们通过文章开头的指导原则来对 UI 组件进行拆分。其实，这个指导原则还可以用在任何其他地方，比如函数、模块设计等。</p>\n<p>组件的拆分不是一层不变的，随着代码的变迁，功能的迭代，最初的拆分方案已经不在符合上述的原则，那么我们就需要重新审视组件的拆分方案，来优化组件。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-25",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/how-to-decompose-component.html",pathLocale:"/",permalink:"/posts/2021/08/25/how-to-decompose-component.html",slug:"how-to-decompose-component",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/how-to-decompose-component.md",filePathRelative:"posts/how-to-decompose-component.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/25/how-to-decompose-component.html.vue",componentFilePathRelative:"pages/posts/2021/08/25/how-to-decompose-component.html.vue",componentFileChunkName:"v-8c4b41aa",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/25/how-to-decompose-component.html.js",dataFilePathRelative:"pages/posts/2021/08/25/how-to-decompose-component.html.js",dataFileChunkName:"v-8c4b41aa",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/08/25/how-to-decompose-component.html",htmlFilePathRelative:"posts/2021/08/25/how-to-decompose-component.html"},{key:"v-2ffc1846",path:"/posts/2018/09/10/http-cache.html",title:"HTTP 缓存",lang:"zh-CN",frontmatter:{title:"HTTP 缓存",description:"HTTP 缓存机制",keywords:["http","cache","缓存"],date:"2018-09-10T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"经典 GET 请求过程",slug:"经典-get-请求过程",children:[]},{level:2,title:"缓存机制",slug:"缓存机制",children:[{level:3,title:"文档过期",slug:"文档过期",children:[]},{level:3,title:"服务器再验证",slug:"服务器再验证",children:[]}]},{level:2,title:"服务器控制缓存的能力",slug:"服务器控制缓存的能力",children:[]},{level:2,title:"客户端的新鲜度控制",slug:"客户端的新鲜度控制",children:[]},{level:2,title:"小结",slug:"小结",children:[]}],content:"\n缓存是一个老生常谈的问题，重要性不言而喻，HTTP 协议中规定了很多请求头和响应头来控制缓存。也因为如此，很多人无法分清某个头部的作用和优先级。本文尝试做一下梳理和总结。\n\n## 经典 GET 请求过程\n\n先看一个经典的 GET 请求的处理过程，如下图：\n![IMAGE](/posts/images/http-cache/get-c.jpg)\n当一个请求达到时，浏览器（为方便叙述，已浏览器为例）先检查被访问的资源是否已被缓存，如果未被缓存（缓存未命中 cache miss），则将请求转发给原始服务器。如果被缓存（缓存命中，cache hit），则会检查缓存是否足够新鲜。如果缓存的副本足够新鲜，则直接将副本返回给客户端，否则会向服务端发起新鲜度验证（revalidation）。如果发现与服务端文件一致，则将本地缓存副本返回给客户端，否则将请求转发给原始服务器。\n\n在这个过程中，由缓存提供服务的请求所在的比例称为缓存命中率（cache hit rat）。这种描述方式只能描述请求级别的命中情况，无法体现具体有多少流量来自缓存。比如一个访问频次很低，尺寸很大的文件，如果以该命中率来描述的话，命中率非常低。但是这个文件却占据了绝大多数的访问流量。因此还需要另一个命中率指标来描述，那就是字节命中率（byte hit rate）。字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。下面章节中服务器再验证的两种策略即是这两种命中率的具体使用。\n\n## 缓存机制\n\n上图中，HTTP 通过一些简单的机制在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。这些机制可以分为两个部分，第一部分称为文档过期（document expiration），第二部分称为服务端再验证（server revalidation。\n\n### 文档过期\n\n通过 `Cache-Control:max-age` 首部和 `Expires` 首部，HTTP 让原始服务器向每个文档附加一个“过期日期”。在缓存文档过期之前，缓存可以以任意频次使用这些副本，而无需与服务端联系。\n`Expires` 首部与 `Cache-Control:max-age` 首部本质上是一样的，区别是 `Expires` 是 HTTP/1.0 协议规定的首部，且首部取值为一个绝对时间，在这个时间之后缓存失效；`Cache-Control:max-age` 是 HTTP/1.1 协议规定的首部，且首部取值是一个相对时间，单位为秒。\n\n### 服务器再验证\n\nHTTP 定义了 5 个条件请求首部来完成服务器再验证。\n\n- If-Modified-Since\n- If-None-Match\n- If-Unmodified-Since\n- If-Range\n- If-Match\n\n其中最有用的是 `If-Modified-Since` 和 `If-None-Match` 两个首部。\n\n#### `If-Modified-Since: Date` 再验证\n\n`If-Modified-Since: Date` 再验证请求工作方式如下：\n\n- 如果自指定日期后，文档被修改了，If-Modified-Since 条件为真，GET 请求就会执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息以外，还包含了一个新的过期日期。\n- 入股自指定日期后，文档没有被修改过，条件就为假，会向客户端返回一个小的 304 Not Modified 响应报文，为了提高有效性，一般会发送一个新的过期日期，不会返回文档的主体。\n\nIf-Modified-Since 请求首部通常与 Last-Modified 服务器响应首部配合工作。原始服务器会将最后的修改日期附加到文档上去。当缓存要对已缓存的文档进行再验证时，就会包含一个 If-Modified-SinceIf-Modified-Since 首部，其中携带有最后修改已缓存副本额日期：\n\n```\nIf-Modified-Since: <cached last-modified date>\n```\n\n#### `If-None-Match: etag` 实体标签验证\n\n有些情况下，`If-Modified-Since: Date` 再验证无法很好的解决缓存问题。比如一个被周期性复写的文件，但是文件的内容往往是一样的。这种情况下，就需要借助实体标签（Etag）验证了。实体标签就是“版本标识符”，是附加到文档上的任意标签（引用字符串），可能包含了文档的序列号或版本名，或者是文档内容的校验信息。\n`If-None-Match: etag` 实体标签验证的工作过程与 `If-Modified-Since: Date` 再验证的工作过程基本一致，不同的是，服务器会在响应中附加一个 `Etag` 响应头。当缓存要对已缓存的文档进行再验证时，就会将这个 etag 放到 If-None-Match 请求头中去。\n\n## 服务器控制缓存的能力\n\n服务器也可以通过如下方式控制缓存，优先级一次递减：\n\n- Cache-Control: no-store 禁止缓存对响应进行复制。\n- Cache-Control: no-cache/ Pragma: no-cache 缓存可以复制响应，但是在与原始服务器进行新鲜度再验证之前不能将其提供给客户端。Pramga: no-cache 为了兼容 HTTP/1.0，优先级低于 Cache-Control: no-cache。\n- Cache-Control: must-revalidate 在事前没有跟原始服务器进行再验证的情况下，缓存不能提供缓存副本。\n- Cache-Control: max-age max-age 指定的秒数内有效。max-age 为零时，不可缓存。\n- Expires: Date 在实际的绝对日期之前有效。\n\n## 客户端的新鲜度控制\n\n客户端通过 `Cache-Control` 请求首部来强化或放松对过期时间的限制。\n\n- Cache-Control: max-stale=< s > 缓存可以随意提供副本，如果指定的秒数，那么在这段时间内，文档不能过期。\n- Cache-Control: min-fresh=< s > 至少在未来< s >秒内文档保持新鲜。\n- Cache-Control: max-age=< s > 缓存无法返回缓存时间超过< s >的文档。如果与 max-stale 通用，max-stale 优先级更高。\n- Cache-Control: no-cache/Pragma: no-cache 除非进行了再验证，否则客户端不接受已缓存的资源。\n- Cache-Control: no-store 缓存应该删除本地缓存副本，使用原始服务器响应。\n- Cache-Control: only-if-cache 只有当缓存中有副本存在时，客户端才会获取一份副本。\n\n## 小结\n\n合理的缓存策略可以帮助我们减少冗余数据传输，节省带宽，同时加快响应速度。不当的缓存策略也可能导致客户端一直使用过期的缓存副本，无法得到及时更新。因此，在搞清楚缓存机制后，根据业务需要进行合理配置才是有效使用缓存的正确姿势。\n",contentRendered:'<p>缓存是一个老生常谈的问题，重要性不言而喻，HTTP 协议中规定了很多请求头和响应头来控制缓存。也因为如此，很多人无法分清某个头部的作用和优先级。本文尝试做一下梳理和总结。</p>\n<h2 id="经典-get-请求过程" tabindex="-1"><a class="header-anchor" href="#经典-get-请求过程" aria-hidden="true">#</a> 经典 GET 请求过程</h2>\n<p>先看一个经典的 GET 请求的处理过程，如下图：\n<img src="/posts/images/http-cache/get-c.jpg" alt="IMAGE">\n当一个请求达到时，浏览器（为方便叙述，已浏览器为例）先检查被访问的资源是否已被缓存，如果未被缓存（缓存未命中 cache miss），则将请求转发给原始服务器。如果被缓存（缓存命中，cache hit），则会检查缓存是否足够新鲜。如果缓存的副本足够新鲜，则直接将副本返回给客户端，否则会向服务端发起新鲜度验证（revalidation）。如果发现与服务端文件一致，则将本地缓存副本返回给客户端，否则将请求转发给原始服务器。</p>\n<p>在这个过程中，由缓存提供服务的请求所在的比例称为缓存命中率（cache hit rat）。这种描述方式只能描述请求级别的命中情况，无法体现具体有多少流量来自缓存。比如一个访问频次很低，尺寸很大的文件，如果以该命中率来描述的话，命中率非常低。但是这个文件却占据了绝大多数的访问流量。因此还需要另一个命中率指标来描述，那就是字节命中率（byte hit rate）。字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。下面章节中服务器再验证的两种策略即是这两种命中率的具体使用。</p>\n<h2 id="缓存机制" tabindex="-1"><a class="header-anchor" href="#缓存机制" aria-hidden="true">#</a> 缓存机制</h2>\n<p>上图中，HTTP 通过一些简单的机制在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。这些机制可以分为两个部分，第一部分称为文档过期（document expiration），第二部分称为服务端再验证（server revalidation。</p>\n<h3 id="文档过期" tabindex="-1"><a class="header-anchor" href="#文档过期" aria-hidden="true">#</a> 文档过期</h3>\n<p>通过 <code>Cache-Control:max-age</code> 首部和 <code>Expires</code> 首部，HTTP 让原始服务器向每个文档附加一个“过期日期”。在缓存文档过期之前，缓存可以以任意频次使用这些副本，而无需与服务端联系。\n<code>Expires</code> 首部与 <code>Cache-Control:max-age</code> 首部本质上是一样的，区别是 <code>Expires</code> 是 HTTP/1.0 协议规定的首部，且首部取值为一个绝对时间，在这个时间之后缓存失效；<code>Cache-Control:max-age</code> 是 HTTP/1.1 协议规定的首部，且首部取值是一个相对时间，单位为秒。</p>\n<h3 id="服务器再验证" tabindex="-1"><a class="header-anchor" href="#服务器再验证" aria-hidden="true">#</a> 服务器再验证</h3>\n<p>HTTP 定义了 5 个条件请求首部来完成服务器再验证。</p>\n<ul>\n<li>If-Modified-Since</li>\n<li>If-None-Match</li>\n<li>If-Unmodified-Since</li>\n<li>If-Range</li>\n<li>If-Match</li>\n</ul>\n<p>其中最有用的是 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 两个首部。</p>\n<h4 id="if-modified-since-date-再验证" tabindex="-1"><a class="header-anchor" href="#if-modified-since-date-再验证" aria-hidden="true">#</a> <code>If-Modified-Since: Date</code> 再验证</h4>\n<p><code>If-Modified-Since: Date</code> 再验证请求工作方式如下：</p>\n<ul>\n<li>如果自指定日期后，文档被修改了，If-Modified-Since 条件为真，GET 请求就会执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息以外，还包含了一个新的过期日期。</li>\n<li>入股自指定日期后，文档没有被修改过，条件就为假，会向客户端返回一个小的 304 Not Modified 响应报文，为了提高有效性，一般会发送一个新的过期日期，不会返回文档的主体。</li>\n</ul>\n<p>If-Modified-Since 请求首部通常与 Last-Modified 服务器响应首部配合工作。原始服务器会将最后的修改日期附加到文档上去。当缓存要对已缓存的文档进行再验证时，就会包含一个 If-Modified-SinceIf-Modified-Since 首部，其中携带有最后修改已缓存副本额日期：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>If-Modified-Since: &lt;cached last-modified date>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="if-none-match-etag-实体标签验证" tabindex="-1"><a class="header-anchor" href="#if-none-match-etag-实体标签验证" aria-hidden="true">#</a> <code>If-None-Match: etag</code> 实体标签验证</h4>\n<p>有些情况下，<code>If-Modified-Since: Date</code> 再验证无法很好的解决缓存问题。比如一个被周期性复写的文件，但是文件的内容往往是一样的。这种情况下，就需要借助实体标签（Etag）验证了。实体标签就是“版本标识符”，是附加到文档上的任意标签（引用字符串），可能包含了文档的序列号或版本名，或者是文档内容的校验信息。\n<code>If-None-Match: etag</code> 实体标签验证的工作过程与 <code>If-Modified-Since: Date</code> 再验证的工作过程基本一致，不同的是，服务器会在响应中附加一个 <code>Etag</code> 响应头。当缓存要对已缓存的文档进行再验证时，就会将这个 etag 放到 If-None-Match 请求头中去。</p>\n<h2 id="服务器控制缓存的能力" tabindex="-1"><a class="header-anchor" href="#服务器控制缓存的能力" aria-hidden="true">#</a> 服务器控制缓存的能力</h2>\n<p>服务器也可以通过如下方式控制缓存，优先级一次递减：</p>\n<ul>\n<li>Cache-Control: no-store 禁止缓存对响应进行复制。</li>\n<li>Cache-Control: no-cache/ Pragma: no-cache 缓存可以复制响应，但是在与原始服务器进行新鲜度再验证之前不能将其提供给客户端。Pramga: no-cache 为了兼容 HTTP/1.0，优先级低于 Cache-Control: no-cache。</li>\n<li>Cache-Control: must-revalidate 在事前没有跟原始服务器进行再验证的情况下，缓存不能提供缓存副本。</li>\n<li>Cache-Control: max-age max-age 指定的秒数内有效。max-age 为零时，不可缓存。</li>\n<li>Expires: Date 在实际的绝对日期之前有效。</li>\n</ul>\n<h2 id="客户端的新鲜度控制" tabindex="-1"><a class="header-anchor" href="#客户端的新鲜度控制" aria-hidden="true">#</a> 客户端的新鲜度控制</h2>\n<p>客户端通过 <code>Cache-Control</code> 请求首部来强化或放松对过期时间的限制。</p>\n<ul>\n<li>Cache-Control: max-stale=&lt; s &gt; 缓存可以随意提供副本，如果指定的秒数，那么在这段时间内，文档不能过期。</li>\n<li>Cache-Control: min-fresh=&lt; s &gt; 至少在未来&lt; s &gt;秒内文档保持新鲜。</li>\n<li>Cache-Control: max-age=&lt; s &gt; 缓存无法返回缓存时间超过&lt; s &gt;的文档。如果与 max-stale 通用，max-stale 优先级更高。</li>\n<li>Cache-Control: no-cache/Pragma: no-cache 除非进行了再验证，否则客户端不接受已缓存的资源。</li>\n<li>Cache-Control: no-store 缓存应该删除本地缓存副本，使用原始服务器响应。</li>\n<li>Cache-Control: only-if-cache 只有当缓存中有副本存在时，客户端才会获取一份副本。</li>\n</ul>\n<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>合理的缓存策略可以帮助我们减少冗余数据传输，节省带宽，同时加快响应速度。不当的缓存策略也可能导致客户端一直使用过期的缓存副本，无法得到及时更新。因此，在搞清楚缓存机制后，根据业务需要进行合理配置才是有效使用缓存的正确姿势。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2018-09-10",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/http-cache.html",pathLocale:"/",permalink:"/posts/2018/09/10/http-cache.html",slug:"http-cache",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/http-cache.md",filePathRelative:"posts/http-cache.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2018/09/10/http-cache.html.vue",componentFilePathRelative:"pages/posts/2018/09/10/http-cache.html.vue",componentFileChunkName:"v-2ffc1846",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2018/09/10/http-cache.html.js",dataFilePathRelative:"pages/posts/2018/09/10/http-cache.html.js",dataFileChunkName:"v-2ffc1846",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2018/09/10/http-cache.html",htmlFilePathRelative:"posts/2018/09/10/http-cache.html"},{key:"v-440e3db6",path:"/posts/2021/09/13/memoizing-async-function.html",title:"缓存异步函数",lang:"zh-CN",frontmatter:{title:"缓存异步函数",description:"对函数的运行结果进行缓存可以提高应用的运行性能。但是对于 JavaScript 而言，很多场景都是异步函数，要对异步函数的运行结果进行缓存，我们需要做一些简单的设计。",keywords:["缓存","异步函数"],date:"2021-09-13T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"如何缓存",slug:"如何缓存",children:[]},{level:2,title:"缓存异步函数",slug:"缓存异步函数",children:[]},{level:2,title:"缓存 promise",slug:"缓存-promise",children:[]},{level:2,title:"控制缓存的规模",slug:"控制缓存的规模",children:[]}],content:"\n缓存是一个重要的概念，在面对非常耗时的计算的时候，通过缓存可以有效提高程序的运行性能。对于同步函数来说，缓存其运行结果非常简单。但是对于异步函数来说，我们需要做一些简单的设计。\n\n## 如何缓存\n\n我们先来介绍下缓存的概念和基本设计。假设我们有一个计算平方数的函数：\n\n```js\nfunction getSquare(x){\n    return x * x;\n}\n```\n\n要缓存这个函数，我们可以这么实现：\n\n```js\nconst memo = {};\n\nfunction getSquare(x){\n    if(memo.hasOwnProperty(x)) {\n        return memo[x];\n    }\n    memo[x] = x * x;\n    return memo[x];\n}\n```\n\n整理下代码，我们创建一个 `memoize` 工具函数，这个函数有两个参数，一个是要被缓存的函数，一个是 `key` 生成函数（每个缓存结果在缓存中应该有一个独一无二的 key）。\n\n注意我们的 `getKey` 函数接收的参数与被缓存的函数的参数相同。\n\n```js\nfunction memoize(fn, getKey){\n    const memo = {};\n    return function memoized(...args){\n        const key = getKey(...args);\n        if(memo.hasOwnProperty(key)) {\n            return memo[key];\n        }\n\n        memo[key] = fn.apply(this, args);\n        return memo[key];\n    }\n}\n```\n\n这时候，上面计算平方数的函数可以这么缓存：\n\n```js\nconst memoGetSquare = memoize(getSquare, num => num);\n```\n\n缓存一个多参数函数：\n\n```js\nconst getDivision = (a, b) => a / b;\n\nconst memoGetDivision= memoize(getDivision, (a, b) => `${a}_${b}`);\n\n```\n\n## 缓存异步函数\n\n上面介绍了缓存的概念和基本设计，并展示了如何缓存同步函数。那么如何对异步函数进行缓存呢？\n\n假设我们有一个非常耗时的函数 `expensiveOperation(key)`，该函数有一个回调参数，在函数运行结束后，通过回调函数返回结果。\n\n```js\nexpensiveOperation(key, ( data) => {\n   // Do something\n})\n```\n\n与上面的缓存方法类似，我们可以先这么设计：\n\n```js\nconst memo = {}\n\nfunction memoExpensiveOperation(key, callback){\n    if(memo.hasOwnProperty(key)){\n        callback(memo[key]);\n        return;\n    }\n\n    expensiveOperation(key, data => {\n        memo[key] = data;\n        callback(data);\n    });\n}\n```\n\n非常简单直接，但是有一个问题。假设我们先调用了一次这个函数，在函数返回之前，又用相同的参数再调用一次。这个时候，因为函数是异步的，缓存起不到作用。\n\n我们需要加一个进行中的缓存。\n\n```js\nconst memo = {}, progressQueues = {};\n\nfunction memoExpensiveOperation(key, callback){\n    if(memo.hasOwnProperty(key)){\n        callback(memo[key]);\n        return;\n    }\n\n    // 在 progressQueues 记录一个进行中的调用\n    if(!progressQueues.hasOwnProperty(key)){\n        progressQueues[key] = [callback];\n    } else {\n        progressQueues[key].push(callback);\n        return;\n    }\n\n    expensiveOperation(key, (data) => {\n        // 缓存结果\n        memo[key] = data;\n        // 将进行中队列中的会有回调调用一遍\n        for(let callback of progressQueues[key]) {\n            callback(data);\n        }\n        // 清楚进行中的回调\n        delete progressQueue[key];\n    });\n}\n```\n\n我们做一下简单封装：\n\n```js\nfunction memoizeAsync(fn, getKey){\n   const memo = {}, progressQueues = {};\n\n   return function memoized(...allArgs){\n       const callback = allArgs[allArgs.length-1];\n       const args = allArgs.slice(0, -1);\n       const key = getKey(...args);\n\n        if(memo.hasOwnProperty(key)){\n            callback(memo[key]);\n            return;\n        }\n\n\n        if( !progressQueues.hasOwnProperty(key) ){\n           progressQueues[key] = [callback];\n        } else {\n           progressQueues[key].push(callback);\n           return;\n        }\n\n        fn.call(this, ...args , (data) => {\n           memo[key] = data;\n           for(let callback of progressQueues[key]) {\n                callback(data);\n           }\n           delete progressQueue[key];\n       });\n   }\n}\n\n// 使用样例\nconst memoExpensiveOperation = memoizeAsync(expensiveOperation, key => key);\n```\n\n## 缓存 promise\n\n假设我们有一个函数 `processData(key)`，返回一个 promise。\n\n缓存 promise 本身与缓存一个同步函数相同，这里不再赘述。\n\n如果我们要缓存 promise 返回的值呢？其实与缓存异步函数类似，我们可以这么设计：\n\n```js\nconst memo = {},  progressQueues = {};\n\nfunction memoProcessData(key){\n    return new Promise((resolve, reject) => {\n        // 如果已经缓存，直接 resolve\n        if(memo.hasOwnProperty(key)){\n            resolve(memo[key]);\n            return;\n        }\n\n        // 缓存进行中的状态\n        if( !progressQueues.hasOwnProperty(key) ){\n            progressQueues[key] = [[resolve, reject]];\n        } else {\n           progressQueues[key].push([resolve, reject]);\n            return;\n        }\n\n        processData(key)\n        .then(data => {\n            memo[key] = data; // 缓存结果\n            // 处理所有进行中的\n            for(let [resolver, ] of progressQueues[key]) {\n                resolver(data);\n            }\n\n        })\n        .catch(error => {\n            // 失败了，处理所有进行中的回调\n            for(let [, rejector] of progressQueues[key]) {\n                rejector(error);\n            }\n        })\n        .finally(() => {\n            // 清理进行中的回调\n            delete progressQueues[key];\n        })\n    })\n}\n\n```\n\n## 控制缓存的规模\n\n上面介绍的缓存方法中，我们没有控制缓存规模。也就是说，每用一个不同的 key 调用一次缓存的函数，都会记录一次缓存结果。慢慢的缓存将会越来越大，最终可能导致严重的后果。\n\n我们需要对缓存的规模进行简单的控制，我们可以使用一些缓存驱逐策略来处理这样的问题。比如 [LRU（Least Recently Used）](https://en.wikipedia.org/wiki/LRU)。\n",contentRendered:'<p>缓存是一个重要的概念，在面对非常耗时的计算的时候，通过缓存可以有效提高程序的运行性能。对于同步函数来说，缓存其运行结果非常简单。但是对于异步函数来说，我们需要做一些简单的设计。</p>\n<h2 id="如何缓存" tabindex="-1"><a class="header-anchor" href="#如何缓存" aria-hidden="true">#</a> 如何缓存</h2>\n<p>我们先来介绍下缓存的概念和基本设计。假设我们有一个计算平方数的函数：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getSquare</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>要缓存这个函数，我们可以这么实现：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">getSquare</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    memo<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>整理下代码，我们创建一个 <code>memoize</code> 工具函数，这个函数有两个参数，一个是要被缓存的函数，一个是 <code>key</code> 生成函数（每个缓存结果在缓存中应该有一个独一无二的 key）。</p>\n<p>注意我们的 <code>getKey</code> 函数接收的参数与被缓存的函数的参数相同。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">memoize</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> getKey</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">memoized</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这时候，上面计算平方数的函数可以这么缓存：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> memoGetSquare <span class="token operator">=</span> <span class="token function">memoize</span><span class="token punctuation">(</span>getSquare<span class="token punctuation">,</span> <span class="token parameter">num</span> <span class="token operator">=></span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>缓存一个多参数函数：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">getDivision</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> memoGetDivision<span class="token operator">=</span> <span class="token function">memoize</span><span class="token punctuation">(</span>getDivision<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">_</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="缓存异步函数" tabindex="-1"><a class="header-anchor" href="#缓存异步函数" aria-hidden="true">#</a> 缓存异步函数</h2>\n<p>上面介绍了缓存的概念和基本设计，并展示了如何缓存同步函数。那么如何对异步函数进行缓存呢？</p>\n<p>假设我们有一个非常耗时的函数 <code>expensiveOperation(key)</code>，该函数有一个回调参数，在函数运行结束后，通过回调函数返回结果。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">expensiveOperation</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span> <span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n   <span class="token comment">// Do something</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>与上面的缓存方法类似，我们可以先这么设计：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">memoExpensiveOperation</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">callback</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token function">expensiveOperation</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>\n        <span class="token function">callback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>非常简单直接，但是有一个问题。假设我们先调用了一次这个函数，在函数返回之前，又用相同的参数再调用一次。这个时候，因为函数是异步的，缓存起不到作用。</p>\n<p>我们需要加一个进行中的缓存。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> progressQueues <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">memoExpensiveOperation</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">callback</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 在 progressQueues 记录一个进行中的调用</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>progressQueues<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>callback<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token function">expensiveOperation</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token comment">// 缓存结果</span>\n        memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>\n        <span class="token comment">// 将进行中队列中的会有回调调用一遍</span>\n        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> callback <span class="token keyword">of</span> progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token function">callback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">// 清楚进行中的回调</span>\n        <span class="token keyword">delete</span> progressQueue<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>我们做一下简单封装：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">memoizeAsync</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> getKey</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n   <span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> progressQueues <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n   <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">memoized</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>allArgs</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n       <span class="token keyword">const</span> callback <span class="token operator">=</span> allArgs<span class="token punctuation">[</span>allArgs<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n       <span class="token keyword">const</span> args <span class="token operator">=</span> allArgs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n       <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token function">callback</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n\n        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>progressQueues<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>\n           progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>callback<span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n           progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>\n           <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n           memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>\n           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> callback <span class="token keyword">of</span> progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">callback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n           <span class="token punctuation">}</span>\n           <span class="token keyword">delete</span> progressQueue<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n       <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 使用样例</span>\n<span class="token keyword">const</span> memoExpensiveOperation <span class="token operator">=</span> <span class="token function">memoizeAsync</span><span class="token punctuation">(</span>expensiveOperation<span class="token punctuation">,</span> <span class="token parameter">key</span> <span class="token operator">=></span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h2 id="缓存-promise" tabindex="-1"><a class="header-anchor" href="#缓存-promise" aria-hidden="true">#</a> 缓存 promise</h2>\n<p>假设我们有一个函数 <code>processData(key)</code>，返回一个 promise。</p>\n<p>缓存 promise 本身与缓存一个同步函数相同，这里不再赘述。</p>\n<p>如果我们要缓存 promise 返回的值呢？其实与缓存异步函数类似，我们可以这么设计：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  progressQueues <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">memoProcessData</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token comment">// 如果已经缓存，直接 resolve</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token function">resolve</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token comment">// 缓存进行中的状态</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>progressQueues<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>\n            progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n           progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n\n        <span class="token function">processData</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n            memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token comment">// 缓存结果</span>\n            <span class="token comment">// 处理所有进行中的</span>\n            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>resolver<span class="token punctuation">,</span> <span class="token punctuation">]</span> <span class="token keyword">of</span> progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">resolver</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n\n        <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n            <span class="token comment">// 失败了，处理所有进行中的回调</span>\n            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> rejector<span class="token punctuation">]</span> <span class="token keyword">of</span> progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">rejector</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n            <span class="token comment">// 清理进行中的回调</span>\n            <span class="token keyword">delete</span> progressQueues<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><h2 id="控制缓存的规模" tabindex="-1"><a class="header-anchor" href="#控制缓存的规模" aria-hidden="true">#</a> 控制缓存的规模</h2>\n<p>上面介绍的缓存方法中，我们没有控制缓存规模。也就是说，每用一个不同的 key 调用一次缓存的函数，都会记录一次缓存结果。慢慢的缓存将会越来越大，最终可能导致严重的后果。</p>\n<p>我们需要对缓存的规模进行简单的控制，我们可以使用一些缓存驱逐策略来处理这样的问题。比如 <a href="https://en.wikipedia.org/wiki/LRU" target="_blank" rel="noopener noreferrer">LRU（Least Recently Used）<OutboundLink/></a>。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-09-13",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/memoizing-async-function.html",pathLocale:"/",permalink:"/posts/2021/09/13/memoizing-async-function.html",slug:"memoizing-async-function",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/memoizing-async-function.md",filePathRelative:"posts/memoizing-async-function.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/09/13/memoizing-async-function.html.vue",componentFilePathRelative:"pages/posts/2021/09/13/memoizing-async-function.html.vue",componentFileChunkName:"v-440e3db6",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/09/13/memoizing-async-function.html.js",dataFilePathRelative:"pages/posts/2021/09/13/memoizing-async-function.html.js",dataFileChunkName:"v-440e3db6",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/09/13/memoizing-async-function.html",htmlFilePathRelative:"posts/2021/09/13/memoizing-async-function.html"},{key:"v-f03ab8ea",path:"/posts/2021/08/01/new-mac-setup.html",title:"快速初始化工作环境（Mac 篇）",lang:"zh-CN",frontmatter:{title:"快速初始化工作环境（Mac 篇）",description:"初始化工作环境所需的系统设置、软件包安装等。",keywords:["开发环境","初始化电脑"],date:"2021-08-01T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html"},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"系统软件设置",slug:"系统软件设置",children:[{level:3,title:"系统设置",slug:"系统设置",children:[]},{level:3,title:"访达（Finder）设置",slug:"访达-finder-设置",children:[]},{level:3,title:"程序坞（Dock）设置",slug:"程序坞-dock-设置",children:[]}]},{level:2,title:"工作软件安装",slug:"工作软件安装",children:[{level:3,title:"Chrome 浏览器",slug:"chrome-浏览器",children:[]},{level:3,title:"浏览器插件",slug:"浏览器插件",children:[]},{level:3,title:"BeyondCompare 文件、目录比较神器",slug:"beyondcompare-文件、目录比较神器",children:[]},{level:3,title:"Iterm2 命令行工具",slug:"iterm2-命令行工具",children:[]},{level:3,title:"HomeBrew",slug:"homebrew",children:[]},{level:3,title:"FZF (fuzzy finder)",slug:"fzf-fuzzy-finder",children:[]},{level:3,title:"NodeJS",slug:"nodejs",children:[]},{level:3,title:"Yarn 包管理工具",slug:"yarn-包管理工具",children:[]},{level:3,title:"Licecap 录屏生成 GIF",slug:"licecap-录屏生成-gif",children:[]},{level:3,title:"Kap 录屏生成 GIF",slug:"kap-录屏生成-gif",children:[]},{level:3,title:"VSCode",slug:"vscode",children:[]},{level:3,title:"Charles 代理工具",slug:"charles-代理工具",children:[]},{level:3,title:"PostMan 请求客户端",slug:"postman-请求客户端",children:[]},{level:3,title:"Sketch 设计工具",slug:"sketch-设计工具",children:[]},{level:3,title:"Quiver 笔记软件",slug:"quiver-笔记软件",children:[]}]}],content:'\n最近换了一个新的工作电脑，在配置开发环境的时候，发现有很多系统设置、应用软件自己已经使用了多年，对平时的工作帮助很大。今天借机整理了一下，发出来，希望对大家也有一些帮助。\n\n## 系统软件设置\n\n### 系统设置\n\n- 关闭聚焦搜索（Spotlight）的无意义索引，只保留应用和系统设置。\n\n操作路径：“系统偏好设置” -> “聚焦”。\n\n![聚焦设置](/posts/images/new-mac-setup/spotlight-c.png)\n\n- 关闭“询问 Siri”\n\n操作路径：“系统偏好设置” -> “Siri” -> 去勾选“询问 Siri”。\n\n- 如果习惯使用鼠标，可以调整触控板方向设置\n\n操作路径：“系统偏好设置” -> “触控板” -> 去勾选“滚动方向：自然”\n\n### 访达（Finder）设置\n\n- 显示文件扩展名\n\n操作路径：“访达偏好设置” -> “高级” -> “显示所有扩展名”\n\n- 显示点文件\n\n操作路径：在打开的访达窗口中同时按下 “Command” + “Shift” + “.” 键。\n\n- 在访达窗口中显示文件具体路径\n\n操作路径 1：“访达窗口” -> “显示（View）菜单” -> “显示路径栏”\n操作路径 2：命令行输入 `defaults write com.apple.finder _FXShowPosixPathInTitle -bool true; killall Finder`，会将访达的窗口名称换成路径。关闭将 true 改为 false。\n\n- 整理访达边栏\n\n操作路径：“访达偏好设置” -> “边栏” -> 勾选自己需要展示的目录\n\n### 程序坞（Dock）设置\n\n- 设置程序坞大小为最小，程序坞位置为左边，并自动隐藏\n\n操作路径：“系统偏好设置” -> “程序坞”\n\n![程序坞](/posts/images/new-mac-setup/dock-c.png)\n\n## 工作软件安装\n\n### Chrome 浏览器\n\n下载安装 Chrome 浏览器或者最新 Edge 浏览器。\n\n### 浏览器插件\n\n- [SwitchyOmega](https://github.com/FelisCatus/SwitchyOmega) 浏览器代理管理\n- [Google 翻译](https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb)\n- [Momentum](https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca) 空白页背景更改\n- [octotree](https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc) 在线看代码神器\n- [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n- [Vue.js Devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)\n\n### BeyondCompare 文件、目录比较神器\n\n可以在[官方网站](https://www.scootersoftware.com/download.php)下载正版软件。然后使用如下命令一直使用试用版。\n\n```bash\nrm "/Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat”\n```\n\n或者直接 [xclient](https://xclient.info) 大法。\n\n### Iterm2 命令行工具\n\nMac 自带的命令行工具 Terminal.app 功能比较弱。可以使用 Iterm2 作为替代。\n\n直接从[官网](https://iterm2.com/downloads.html)下载安装即可。\n\n- 安装 [OhMyZSH](https://ohmyz.sh/#install)\n- 选择[主题](https://github.com/ohmyzsh/ohmyzsh/wiki/Themes)，个人偏好 `af-magic`\n- 安装插件\n  - [autosuggestions](https://github.com/zsh-users/zsh-autosuggestions)\n  - [命令行语法高亮](https://github.com/zsh-users/zsh-syntax-highlighting)\n\n### HomeBrew\n\nHomeBrew 是 MacOS 的软件包管理工具。很多包都可以通过 homebrew 来安装。\n\n通过下面的命令来安装 homebrew.\n\n```bash\n/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"\n```\n\n### FZF (fuzzy finder)\n\n基于 Go 语言开发的模糊查询工具，类似于 `find` 命令，性能很快。\n\n```bash\nbrew install fzf\n```\n\n### NodeJS\n\n```bash\nbrew install node\n```\n\n### Yarn 包管理工具\n\n```bash\nbrew install yarn --ignore-dependencies\n```\n\n### Licecap 录屏生成 GIF\n\n可以直接从[官网](https://www.cockos.com/licecap/)下载安装。\n\n### Kap 录屏生成 GIF\n\n另一款录屏软件，可以直接从[官网](https://getkap.co/)下载安装。\n\n### VSCode\n\n从[官网](https://code.visualstudio.com/) 下载安装。\n\nvscode 中有很多插件非常实用，罗列如下：\n\n- Auto Close Tag (formulahendry.auto-close-tag)\n- Auto Rename Tag (formulahendry.auto-rename-tag)\n- Babel JavaScript (mgmcdermott.vscode-language-babel) 语法高亮\n- Bracket Pair Colorizer (coenraads.bracket-pair-colorizer) 大括号着色\n- Import Cost (wix.vscode-import-cost) 计算导入包的大小\n- CSS Modules (clinyong.vscode-css-modules) CSS Module 辅助工具\n- ESLint (dbaeumer.vscode-eslint)\n- GitLens (eamodio.gitlens)\n- GraphQL (graphql.vscode-graphql) .graphql 编写插件\n- Prettier (esbenp.prettier-vscode) 代码格式化工具\n- Vetur (octref.vetur) Vue 组件开发工具\n- Setting Sync (shan.code-settings-sync) VSCode 设置同步\n- Bookmarks (alefragnani.bookmarks)\n- VSCode Great Icons (emmanuelbeziat.vscode-great-icons)\n\n### Charles 代理工具\n\nCharles 是一款强大的代理工具，在 APP 或者 H5 开发中经常需要代理。\n\n可以直接从[官网](https://www.charlesproxy.com/) 下载，或者 xclient 大法。\n\n### PostMan 请求客户端\n\n接口调用工具，直接对接口发起请求，不用前端代码。直接从[官网](https://www.postman.com/downloads/)下载。\n\n### Sketch 设计工具\n\n卓越的设计工具，通常用来查看设计给的设计稿。直接从[官网](https://www.sketch.com/) 下载，或者 xclient 大法。\n\n- [Sketch Measure](https://github.com/utom/sketch-measure) 查看元素尺寸的插件\n\n### Quiver 笔记软件\n\n一款不错的笔记软件，支持 Markdown 和 LaTeX 语法。可以通过笔记本对笔记进行管理。\n\n可以在 [App Store](https://apps.apple.com/app/quiver-programmers-notebook/id866773894?mt=12) 安装或者 xclient 大法。\n',contentRendered:'<p>最近换了一个新的工作电脑，在配置开发环境的时候，发现有很多系统设置、应用软件自己已经使用了多年，对平时的工作帮助很大。今天借机整理了一下，发出来，希望对大家也有一些帮助。</p>\n<h2 id="系统软件设置" tabindex="-1"><a class="header-anchor" href="#系统软件设置" aria-hidden="true">#</a> 系统软件设置</h2>\n<h3 id="系统设置" tabindex="-1"><a class="header-anchor" href="#系统设置" aria-hidden="true">#</a> 系统设置</h3>\n<ul>\n<li>关闭聚焦搜索（Spotlight）的无意义索引，只保留应用和系统设置。</li>\n</ul>\n<p>操作路径：“系统偏好设置” -&gt; “聚焦”。</p>\n<p><img src="/posts/images/new-mac-setup/spotlight-c.png" alt="聚焦设置"></p>\n<ul>\n<li>关闭“询问 Siri”</li>\n</ul>\n<p>操作路径：“系统偏好设置” -&gt; “Siri” -&gt; 去勾选“询问 Siri”。</p>\n<ul>\n<li>如果习惯使用鼠标，可以调整触控板方向设置</li>\n</ul>\n<p>操作路径：“系统偏好设置” -&gt; “触控板” -&gt; 去勾选“滚动方向：自然”</p>\n<h3 id="访达-finder-设置" tabindex="-1"><a class="header-anchor" href="#访达-finder-设置" aria-hidden="true">#</a> 访达（Finder）设置</h3>\n<ul>\n<li>显示文件扩展名</li>\n</ul>\n<p>操作路径：“访达偏好设置” -&gt; “高级” -&gt; “显示所有扩展名”</p>\n<ul>\n<li>显示点文件</li>\n</ul>\n<p>操作路径：在打开的访达窗口中同时按下 “Command” + “Shift” + “.” 键。</p>\n<ul>\n<li>在访达窗口中显示文件具体路径</li>\n</ul>\n<p>操作路径 1：“访达窗口” -&gt; “显示（View）菜单” -&gt; “显示路径栏”\n操作路径 2：命令行输入 <code>defaults write com.apple.finder _FXShowPosixPathInTitle -bool true; killall Finder</code>，会将访达的窗口名称换成路径。关闭将 true 改为 false。</p>\n<ul>\n<li>整理访达边栏</li>\n</ul>\n<p>操作路径：“访达偏好设置” -&gt; “边栏” -&gt; 勾选自己需要展示的目录</p>\n<h3 id="程序坞-dock-设置" tabindex="-1"><a class="header-anchor" href="#程序坞-dock-设置" aria-hidden="true">#</a> 程序坞（Dock）设置</h3>\n<ul>\n<li>设置程序坞大小为最小，程序坞位置为左边，并自动隐藏</li>\n</ul>\n<p>操作路径：“系统偏好设置” -&gt; “程序坞”</p>\n<p><img src="/posts/images/new-mac-setup/dock-c.png" alt="程序坞"></p>\n<h2 id="工作软件安装" tabindex="-1"><a class="header-anchor" href="#工作软件安装" aria-hidden="true">#</a> 工作软件安装</h2>\n<h3 id="chrome-浏览器" tabindex="-1"><a class="header-anchor" href="#chrome-浏览器" aria-hidden="true">#</a> Chrome 浏览器</h3>\n<p>下载安装 Chrome 浏览器或者最新 Edge 浏览器。</p>\n<h3 id="浏览器插件" tabindex="-1"><a class="header-anchor" href="#浏览器插件" aria-hidden="true">#</a> 浏览器插件</h3>\n<ul>\n<li><a href="https://github.com/FelisCatus/SwitchyOmega" target="_blank" rel="noopener noreferrer">SwitchyOmega<OutboundLink/></a> 浏览器代理管理</li>\n<li><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="noopener noreferrer">Google 翻译<OutboundLink/></a></li>\n<li><a href="https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca" target="_blank" rel="noopener noreferrer">Momentum<OutboundLink/></a> 空白页背景更改</li>\n<li><a href="https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="noopener noreferrer">octotree<OutboundLink/></a> 在线看代码神器</li>\n<li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener noreferrer">React Developer Tools<OutboundLink/></a></li>\n<li><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener noreferrer">Vue.js Devtools<OutboundLink/></a></li>\n</ul>\n<h3 id="beyondcompare-文件、目录比较神器" tabindex="-1"><a class="header-anchor" href="#beyondcompare-文件、目录比较神器" aria-hidden="true">#</a> BeyondCompare 文件、目录比较神器</h3>\n<p>可以在<a href="https://www.scootersoftware.com/download.php" target="_blank" rel="noopener noreferrer">官方网站<OutboundLink/></a>下载正版软件。然后使用如下命令一直使用试用版。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">rm</span> "/Users/<span class="token variable"><span class="token variable">$(</span><span class="token function">whoami</span><span class="token variable">)</span></span>/Library/Application Support/Beyond Compare/registry.dat”\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>或者直接 <a href="https://xclient.info" target="_blank" rel="noopener noreferrer">xclient<OutboundLink/></a> 大法。</p>\n<h3 id="iterm2-命令行工具" tabindex="-1"><a class="header-anchor" href="#iterm2-命令行工具" aria-hidden="true">#</a> Iterm2 命令行工具</h3>\n<p>Mac 自带的命令行工具 Terminal.app 功能比较弱。可以使用 Iterm2 作为替代。</p>\n<p>直接从<a href="https://iterm2.com/downloads.html" target="_blank" rel="noopener noreferrer">官网<OutboundLink/></a>下载安装即可。</p>\n<ul>\n<li>安装 <a href="https://ohmyz.sh/#install" target="_blank" rel="noopener noreferrer">OhMyZSH<OutboundLink/></a></li>\n<li>选择<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" target="_blank" rel="noopener noreferrer">主题<OutboundLink/></a>，个人偏好 <code>af-magic</code></li>\n<li>安装插件\n<ul>\n<li><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener noreferrer">autosuggestions<OutboundLink/></a></li>\n<li><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener noreferrer">命令行语法高亮<OutboundLink/></a></li>\n</ul>\n</li>\n</ul>\n<h3 id="homebrew" tabindex="-1"><a class="header-anchor" href="#homebrew" aria-hidden="true">#</a> HomeBrew</h3>\n<p>HomeBrew 是 MacOS 的软件包管理工具。很多包都可以通过 homebrew 来安装。</p>\n<p>通过下面的命令来安装 homebrew.</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>/bin/bash -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh<span class="token variable">)</span></span>"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="fzf-fuzzy-finder" tabindex="-1"><a class="header-anchor" href="#fzf-fuzzy-finder" aria-hidden="true">#</a> FZF (fuzzy finder)</h3>\n<p>基于 Go 语言开发的模糊查询工具，类似于 <code>find</code> 命令，性能很快。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>brew <span class="token function">install</span> fzf\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="nodejs" tabindex="-1"><a class="header-anchor" href="#nodejs" aria-hidden="true">#</a> NodeJS</h3>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>brew <span class="token function">install</span> node\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="yarn-包管理工具" tabindex="-1"><a class="header-anchor" href="#yarn-包管理工具" aria-hidden="true">#</a> Yarn 包管理工具</h3>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>brew <span class="token function">install</span> <span class="token function">yarn</span> --ignore-dependencies\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="licecap-录屏生成-gif" tabindex="-1"><a class="header-anchor" href="#licecap-录屏生成-gif" aria-hidden="true">#</a> Licecap 录屏生成 GIF</h3>\n<p>可以直接从<a href="https://www.cockos.com/licecap/" target="_blank" rel="noopener noreferrer">官网<OutboundLink/></a>下载安装。</p>\n<h3 id="kap-录屏生成-gif" tabindex="-1"><a class="header-anchor" href="#kap-录屏生成-gif" aria-hidden="true">#</a> Kap 录屏生成 GIF</h3>\n<p>另一款录屏软件，可以直接从<a href="https://getkap.co/" target="_blank" rel="noopener noreferrer">官网<OutboundLink/></a>下载安装。</p>\n<h3 id="vscode" tabindex="-1"><a class="header-anchor" href="#vscode" aria-hidden="true">#</a> VSCode</h3>\n<p>从<a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">官网<OutboundLink/></a> 下载安装。</p>\n<p>vscode 中有很多插件非常实用，罗列如下：</p>\n<ul>\n<li>Auto Close Tag (formulahendry.auto-close-tag)</li>\n<li>Auto Rename Tag (formulahendry.auto-rename-tag)</li>\n<li>Babel JavaScript (mgmcdermott.vscode-language-babel) 语法高亮</li>\n<li>Bracket Pair Colorizer (coenraads.bracket-pair-colorizer) 大括号着色</li>\n<li>Import Cost (wix.vscode-import-cost) 计算导入包的大小</li>\n<li>CSS Modules (clinyong.vscode-css-modules) CSS Module 辅助工具</li>\n<li>ESLint (dbaeumer.vscode-eslint)</li>\n<li>GitLens (eamodio.gitlens)</li>\n<li>GraphQL (graphql.vscode-graphql) .graphql 编写插件</li>\n<li>Prettier (esbenp.prettier-vscode) 代码格式化工具</li>\n<li>Vetur (octref.vetur) Vue 组件开发工具</li>\n<li>Setting Sync (shan.code-settings-sync) VSCode 设置同步</li>\n<li>Bookmarks (alefragnani.bookmarks)</li>\n<li>VSCode Great Icons (emmanuelbeziat.vscode-great-icons)</li>\n</ul>\n<h3 id="charles-代理工具" tabindex="-1"><a class="header-anchor" href="#charles-代理工具" aria-hidden="true">#</a> Charles 代理工具</h3>\n<p>Charles 是一款强大的代理工具，在 APP 或者 H5 开发中经常需要代理。</p>\n<p>可以直接从<a href="https://www.charlesproxy.com/" target="_blank" rel="noopener noreferrer">官网<OutboundLink/></a> 下载，或者 xclient 大法。</p>\n<h3 id="postman-请求客户端" tabindex="-1"><a class="header-anchor" href="#postman-请求客户端" aria-hidden="true">#</a> PostMan 请求客户端</h3>\n<p>接口调用工具，直接对接口发起请求，不用前端代码。直接从<a href="https://www.postman.com/downloads/" target="_blank" rel="noopener noreferrer">官网<OutboundLink/></a>下载。</p>\n<h3 id="sketch-设计工具" tabindex="-1"><a class="header-anchor" href="#sketch-设计工具" aria-hidden="true">#</a> Sketch 设计工具</h3>\n<p>卓越的设计工具，通常用来查看设计给的设计稿。直接从<a href="https://www.sketch.com/" target="_blank" rel="noopener noreferrer">官网<OutboundLink/></a> 下载，或者 xclient 大法。</p>\n<ul>\n<li><a href="https://github.com/utom/sketch-measure" target="_blank" rel="noopener noreferrer">Sketch Measure<OutboundLink/></a> 查看元素尺寸的插件</li>\n</ul>\n<h3 id="quiver-笔记软件" tabindex="-1"><a class="header-anchor" href="#quiver-笔记软件" aria-hidden="true">#</a> Quiver 笔记软件</h3>\n<p>一款不错的笔记软件，支持 Markdown 和 LaTeX 语法。可以通过笔记本对笔记进行管理。</p>\n<p>可以在 <a href="https://apps.apple.com/app/quiver-programmers-notebook/id866773894?mt=12" target="_blank" rel="noopener noreferrer">App Store<OutboundLink/></a> 安装或者 xclient 大法。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-01",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/new-mac-setup.html",pathLocale:"/",permalink:"/posts/2021/08/01/new-mac-setup.html",slug:"new-mac-setup",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/new-mac-setup.md",filePathRelative:"posts/new-mac-setup.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/01/new-mac-setup.html.vue",componentFilePathRelative:"pages/posts/2021/08/01/new-mac-setup.html.vue",componentFileChunkName:"v-f03ab8ea",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/01/new-mac-setup.html.js",dataFilePathRelative:"pages/posts/2021/08/01/new-mac-setup.html.js",dataFileChunkName:"v-f03ab8ea",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/08/01/new-mac-setup.html",htmlFilePathRelative:"posts/2021/08/01/new-mac-setup.html"},{key:"v-32a7a778",path:"/posts/2021/09/26/nodejs-debug-tools.html",title:"如何调试 NodeJS 程序?",lang:"zh-CN",frontmatter:{title:"如何调试 NodeJS 程序?",description:"代码调试在开发阶段非常重要，本文介绍几个 NodeJS 的代码调试工具，帮助提高开发效率。",keywords:["调试","debug"],date:"2021-09-26T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"日志",slug:"日志",children:[{level:3,title:"debug 模块",slug:"debug-模块",children:[]},{level:3,title:"记录日志到文件",slug:"记录日志到文件",children:[]}]},{level:2,title:"调试",slug:"调试",children:[{level:3,title:"NodeJS 内置调试模块",slug:"nodejs-内置调试模块",children:[]},{level:3,title:"V8 Inspector",slug:"v8-inspector",children:[]},{level:3,title:"VSCode",slug:"vscode",children:[]}]}],content:'\n代码调试有时候是一种充满挑战的工作，如果有一个趁手的调试工具的话，往往可以做到事半功倍的效果。得益于这些年的快速发展，在 NodeJS 生态中已经有了多种调试工具可以使用。我们今年就来分享几个常用的调试工具。\n\n在 NodeJS 的代码调试中，通常又两大类调试方法，一种是打印日志，另一种是直接调试代码。我们现在来分别说明。\n\n## 日志\n\n日志可以帮助我们记录在程序运行过程中的一些状态和错误信息。通过日志，我们可以快速的找到出问题的代码。比如借助于异常日志，我们可以快速的定位到具体的代码行。\n\n### debug 模块\n\n[debug](https://www.npmjs.com/package/debug) 是很多 NodeJS 包和框架使用的日志工具。这个包的优点是可以通过环境变量的形式细粒度的控制打印哪些日志。\n\n比如在下面的代码中，假设我们先发送了一些请求，然后又接受到了响应数据。\n\n```js\n// index.js\nconst debugHttpIncoming = require(\'debug\')(\'http:incoming\')\nconst debugHttpOutgoing = require(\'debug\')(\'http:outgoing\')\n\nlet outgoingRequest = {\n  url: \'https://google.com\'\n}\n\n// sending some request\ndebugHttpOutgoing(\'sending request to %s\', outgoingRequest.url)\n\nlet incomingRequest = {\n  body: \'{"status": "ok"}\'\n}\n\n// serving some request\ndebugHttpOutgoing(\'got JSON body %s\', incomingRequest.body)\n```\n\n当我们通过如下方式启动程序的时候:\n\n```bash\nDEBUG=http:incoming,http:outgoing node index.js\n```\n\n日志展示如下：\n\n![debug 日志输出](/posts/images/nodejs-debug-tools/debug-c.png)\n\n同时，debug 模块还支持 `*` 通配符，我们可以通过 `DEBUG=http:* node index.js` 获得上面相同的日志输出。\n\n### 记录日志到文件\n\n通常，我们需要将应用运行的日志做持久化处理，最简单的方式就是记录到文件。\n\n[pino](https://www.npmjs.com/package/pino) 是一个高性能的日志模块，与 [bunyan](https://www.npmjs.com/package/bunyan) 类似，但是性能更好。\n\n以下是几种日志模块的性能数据对比：\n\n```txt\nbenchWinston*10000:     2226.117ms\nbenchBunyan*10000:      1355.229ms\nbenchDebug*10000:       445.291ms\nbenchLogLevel*10000:    322.181ms\nbenchBole*10000:        291.727ms\nbenchPino*10000:        269.109ms\nbenchPinoExtreme*10000: 102.239ms\n```\n\npino 使用非常简单：\n\n```js\nconst pino = require(\'pino\')()\n\npino.info(\'hello pino\')\npino.info(\'the answer is %d\', 42)\npino.error(new Error(\'an error\'))\n```\n\n上面的代码，日志输出如下：\n\n```txt\n{"level":30,"time":1632626946507,"pid":77749,"hostname":"everfind-MacBook-Pro.local","msg":"hello pino"}\n{"level":30,"time":1632626946508,"pid":77749,"hostname":"everfind-MacBook-Pro.local","msg":"the answer is 42"}\n{"level":50,"time":1632626946508,"pid":77749,"hostname":"everfind-MacBook-Pro.local","stack":"Error: an error\\n    at Object.<anonymous> (/Users/everfind/workspace/ztest/test/pino.js:5:12)\\n    at Module._compile (internal/modules/cjs/loader.js:1072:14)\\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1101:10)\\n    at Module.load (internal/modules/cjs/loader.js:937:32)\\n    at Function.Module._load (internal/modules/cjs/loader.js:778:12)\\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12)\\n    at internal/main/run_main_module.js:17:47","type":"Error","msg":"an error"}\n```\n\n## 调试\n\n### NodeJS 内置调试模块\n\nNodeJS 提供了内置的调试模块。使用起来非常简单直接，缺点是没有 UI 页面，纯命令行操作。\n\n```bash\n$ node debug index.js\n```\n\n我们通过 `debugger` 语句来设置断点。\n\n```js\nconst express = require(\'express\');\nconst app = express();\n\napp.get(\'/\', (req, res) => {\n  debugger;\n  res.send(\'ok\');\n});\n\napp.listen(3000);\n```\n\n内置的调试模块支持如下命令：\n\n* cont 或 c –- 继续执行\n* next 或 n –- 往下一步\n* step 或 s –- 进入函数\n* out 或 o –- 退出函数\n* repl –- 刷新上下文信息\n\n\n![nodejs debug](/posts/images/nodejs-debug-tools/nodejs-debug-c.gif)\n\n### V8 Inspector\n\n我们还可以通过 V8 inspector，使用 Chrome 的 DevTools 来调试 NodeJS 代码。\n\n```bash\n$ node --inspect index.js\n```\n\n上面这条命令，通过 `--inspect` 参数告诉 NodeJS 启用 V8 Inspector。之后我们在 Chrome 中输入 `chrome://inspect/`，然后找到我们要调试的那个文件，就可以使用 Chrome DevTools 调试代码了。\n\n有时候，我们需要在代码的入口处开始调试，则可以通过 `--inspect-brk` 来在起始地点开始调试。\n\n```bash\n$ node --inspect-brk index.js\n```\n\n![node --inspect](/posts/images/nodejs-debug-tools/inspector-c.gif)\n\n### VSCode\n\n最后我们介绍如何在 VSCode 中调试代码，这也是最高频使用的。\n\n![vscode](/posts/images/nodejs-debug-tools/vscode-c.gif)\n\n通常我们可以直接通过菜单启动调试，就像上面的演示效果那样。\n\n如果我们需要一些高级设置，VSCode 允许我们配置一个 `.vscode/launch.json` 文件，来告诉 VSCode 如何启动调试器。\n\n默认的配置项如下：\n\n```json\n{\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "type": "node",\n            "request": "launch",\n            "name": "Launch Program",\n            "program": "${workspaceRoot}/index.js"\n        },\n        {\n            "type": "node",\n            "request": "attach",\n            "name": "Attach to Port",\n            "address": "localhost",\n            "port": 5858\n        }\n    ]\n}\n```\n\n关于每个配置项的作用和具体用法，可以在 [VSCode 的文档](https://code.visualstudio.com/docs/editor/debugging#_launchjson-attributes)中查询。\n\n\n另外，如果我们在 VSCode 的内置命令行通过 `node --inspect` 启动程序的话，会自动激活 VSCode 的调试功能。\n',contentRendered:'<p>代码调试有时候是一种充满挑战的工作，如果有一个趁手的调试工具的话，往往可以做到事半功倍的效果。得益于这些年的快速发展，在 NodeJS 生态中已经有了多种调试工具可以使用。我们今年就来分享几个常用的调试工具。</p>\n<p>在 NodeJS 的代码调试中，通常又两大类调试方法，一种是打印日志，另一种是直接调试代码。我们现在来分别说明。</p>\n<h2 id="日志" tabindex="-1"><a class="header-anchor" href="#日志" aria-hidden="true">#</a> 日志</h2>\n<p>日志可以帮助我们记录在程序运行过程中的一些状态和错误信息。通过日志，我们可以快速的找到出问题的代码。比如借助于异常日志，我们可以快速的定位到具体的代码行。</p>\n<h3 id="debug-模块" tabindex="-1"><a class="header-anchor" href="#debug-模块" aria-hidden="true">#</a> debug 模块</h3>\n<p><a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener noreferrer">debug<OutboundLink/></a> 是很多 NodeJS 包和框架使用的日志工具。这个包的优点是可以通过环境变量的形式细粒度的控制打印哪些日志。</p>\n<p>比如在下面的代码中，假设我们先发送了一些请求，然后又接受到了响应数据。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// index.js</span>\n<span class="token keyword">const</span> debugHttpIncoming <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'debug\'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">\'http:incoming\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> debugHttpOutgoing <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'debug\'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">\'http:outgoing\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> outgoingRequest <span class="token operator">=</span> <span class="token punctuation">{</span>\n  url<span class="token operator">:</span> <span class="token string">\'https://google.com\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// sending some request</span>\n<span class="token function">debugHttpOutgoing</span><span class="token punctuation">(</span><span class="token string">\'sending request to %s\'</span><span class="token punctuation">,</span> outgoingRequest<span class="token punctuation">.</span>url<span class="token punctuation">)</span>\n\n<span class="token keyword">let</span> incomingRequest <span class="token operator">=</span> <span class="token punctuation">{</span>\n  body<span class="token operator">:</span> <span class="token string">\'{"status": "ok"}\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// serving some request</span>\n<span class="token function">debugHttpOutgoing</span><span class="token punctuation">(</span><span class="token string">\'got JSON body %s\'</span><span class="token punctuation">,</span> incomingRequest<span class="token punctuation">.</span>body<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>当我们通过如下方式启动程序的时候:</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token assign-left variable">DEBUG</span><span class="token operator">=</span>http:incoming,http:outgoing node index.js\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>日志展示如下：</p>\n<p><img src="/posts/images/nodejs-debug-tools/debug-c.png" alt="debug 日志输出"></p>\n<p>同时，debug 模块还支持 <code>*</code> 通配符，我们可以通过 <code>DEBUG=http:* node index.js</code> 获得上面相同的日志输出。</p>\n<h3 id="记录日志到文件" tabindex="-1"><a class="header-anchor" href="#记录日志到文件" aria-hidden="true">#</a> 记录日志到文件</h3>\n<p>通常，我们需要将应用运行的日志做持久化处理，最简单的方式就是记录到文件。</p>\n<p><a href="https://www.npmjs.com/package/pino" target="_blank" rel="noopener noreferrer">pino<OutboundLink/></a> 是一个高性能的日志模块，与 <a href="https://www.npmjs.com/package/bunyan" target="_blank" rel="noopener noreferrer">bunyan<OutboundLink/></a> 类似，但是性能更好。</p>\n<p>以下是几种日志模块的性能数据对比：</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>benchWinston*10000:     2226.117ms\nbenchBunyan*10000:      1355.229ms\nbenchDebug*10000:       445.291ms\nbenchLogLevel*10000:    322.181ms\nbenchBole*10000:        291.727ms\nbenchPino*10000:        269.109ms\nbenchPinoExtreme*10000: 102.239ms\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>pino 使用非常简单：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> pino <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'pino\'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\npino<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">\'hello pino\'</span><span class="token punctuation">)</span>\npino<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">\'the answer is %d\'</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span>\npino<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">\'an error\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面的代码，日志输出如下：</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>{"level":30,"time":1632626946507,"pid":77749,"hostname":"everfind-MacBook-Pro.local","msg":"hello pino"}\n{"level":30,"time":1632626946508,"pid":77749,"hostname":"everfind-MacBook-Pro.local","msg":"the answer is 42"}\n{"level":50,"time":1632626946508,"pid":77749,"hostname":"everfind-MacBook-Pro.local","stack":"Error: an error\\n    at Object.&lt;anonymous> (/Users/everfind/workspace/ztest/test/pino.js:5:12)\\n    at Module._compile (internal/modules/cjs/loader.js:1072:14)\\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1101:10)\\n    at Module.load (internal/modules/cjs/loader.js:937:32)\\n    at Function.Module._load (internal/modules/cjs/loader.js:778:12)\\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12)\\n    at internal/main/run_main_module.js:17:47","type":"Error","msg":"an error"}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="调试" tabindex="-1"><a class="header-anchor" href="#调试" aria-hidden="true">#</a> 调试</h2>\n<h3 id="nodejs-内置调试模块" tabindex="-1"><a class="header-anchor" href="#nodejs-内置调试模块" aria-hidden="true">#</a> NodeJS 内置调试模块</h3>\n<p>NodeJS 提供了内置的调试模块。使用起来非常简单直接，缺点是没有 UI 页面，纯命令行操作。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>$ node debug index.js\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>我们通过 <code>debugger</code> 语句来设置断点。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'express\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\napp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">debugger</span><span class="token punctuation">;</span>\n  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">\'ok\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\napp<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>内置的调试模块支持如下命令：</p>\n<ul>\n<li>cont 或 c –- 继续执行</li>\n<li>next 或 n –- 往下一步</li>\n<li>step 或 s –- 进入函数</li>\n<li>out 或 o –- 退出函数</li>\n<li>repl –- 刷新上下文信息</li>\n</ul>\n<p><img src="/posts/images/nodejs-debug-tools/nodejs-debug-c.gif" alt="nodejs debug"></p>\n<h3 id="v8-inspector" tabindex="-1"><a class="header-anchor" href="#v8-inspector" aria-hidden="true">#</a> V8 Inspector</h3>\n<p>我们还可以通过 V8 inspector，使用 Chrome 的 DevTools 来调试 NodeJS 代码。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>$ node --inspect index.js\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>上面这条命令，通过 <code>--inspect</code> 参数告诉 NodeJS 启用 V8 Inspector。之后我们在 Chrome 中输入 <code>chrome://inspect/</code>，然后找到我们要调试的那个文件，就可以使用 Chrome DevTools 调试代码了。</p>\n<p>有时候，我们需要在代码的入口处开始调试，则可以通过 <code>--inspect-brk</code> 来在起始地点开始调试。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>$ node --inspect-brk index.js\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><img src="/posts/images/nodejs-debug-tools/inspector-c.gif" alt="node --inspect"></p>\n<h3 id="vscode" tabindex="-1"><a class="header-anchor" href="#vscode" aria-hidden="true">#</a> VSCode</h3>\n<p>最后我们介绍如何在 VSCode 中调试代码，这也是最高频使用的。</p>\n<p><img src="/posts/images/nodejs-debug-tools/vscode-c.gif" alt="vscode"></p>\n<p>通常我们可以直接通过菜单启动调试，就像上面的演示效果那样。</p>\n<p>如果我们需要一些高级设置，VSCode 允许我们配置一个 <code>.vscode/launch.json</code> 文件，来告诉 VSCode 如何启动调试器。</p>\n<p>默认的配置项如下：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>\n    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"node"</span><span class="token punctuation">,</span>\n            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>\n            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Launch Program"</span><span class="token punctuation">,</span>\n            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"${workspaceRoot}/index.js"</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token punctuation">{</span>\n            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"node"</span><span class="token punctuation">,</span>\n            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"attach"</span><span class="token punctuation">,</span>\n            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Attach to Port"</span><span class="token punctuation">,</span>\n            <span class="token property">"address"</span><span class="token operator">:</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span>\n            <span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">5858</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>关于每个配置项的作用和具体用法，可以在 <a href="https://code.visualstudio.com/docs/editor/debugging#_launchjson-attributes" target="_blank" rel="noopener noreferrer">VSCode 的文档<OutboundLink/></a>中查询。</p>\n<p>另外，如果我们在 VSCode 的内置命令行通过 <code>node --inspect</code> 启动程序的话，会自动激活 VSCode 的调试功能。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-09-26",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/nodejs-debug-tools.html",pathLocale:"/",permalink:"/posts/2021/09/26/nodejs-debug-tools.html",slug:"nodejs-debug-tools",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/nodejs-debug-tools.md",filePathRelative:"posts/nodejs-debug-tools.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/09/26/nodejs-debug-tools.html.vue",componentFilePathRelative:"pages/posts/2021/09/26/nodejs-debug-tools.html.vue",componentFileChunkName:"v-32a7a778",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/09/26/nodejs-debug-tools.html.js",dataFilePathRelative:"pages/posts/2021/09/26/nodejs-debug-tools.html.js",dataFileChunkName:"v-32a7a778",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/09/26/nodejs-debug-tools.html",htmlFilePathRelative:"posts/2021/09/26/nodejs-debug-tools.html"},{key:"v-b8462e7e",path:"/posts/2021/08/15/nodejs-event-loop.html",title:"NodeJS 的事件循环详解",lang:"zh-CN",frontmatter:{title:"NodeJS 的事件循环详解",description:"什么是 NodeJS 的事件循环？事件循环是如何工作的？setTimeout 和 setImmediate 如何工作？",keywords:["事件循环","任务队列"],date:"2021-08-15T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"libuv 的事件循环",slug:"libuv-的事件循环",children:[]},{level:2,title:"NodeJS 的事件循环",slug:"nodejs-的事件循环",children:[]},{level:2,title:"setImmediate、setTimeout 和 process.nextTick",slug:"setimmediate、settimeout-和-process-nexttick",children:[]},{level:2,title:"Promise",slug:"promise",children:[]},{level:2,title:"总结",slug:"总结",children:[]}],content:"\n事件循环是 NodeJS 处理非阻塞 I/O 操作的和核心机制。NodeJS 的事件循环脱胎于 [libuv](http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop) 的事件循环，因此，要搞清楚 NodeJS 的事件循环，还需要先了解 libuv 的事件循环是如何工作的。\n\n## libuv 的事件循环\n\n我们先来了解两个基本概念：句柄（handle）和请求（request）.\n\n- 句柄是指在整个事件循环活跃时间内能够执行某些操作的长期对象。比如一个 TCP 服务句柄，每当有新的联接建立时，这个句柄的 `connected` 回调就会被调用。\n- 请求是通常指短期操作。比如向某个句柄中写入数据的操作。\n\n了解了这两个概念以后，我们来看看 libuv 的事件循环是如何工作的。\n\n下面这张图可以清楚的展示事件循环的执行过程：\n\n![libuv 的事件循环](/posts/images/nodejs-event-loop/libuv-loop-c.png)\n\n结合这张图我们简单描述一下一次循环过程中各个步骤做了什么。\n\n1. 首先更新循环内的当前时间（now），避免在循环过程中多次发生与时间相关的系统调用。\n2. 检查当前事件循环是否还是活跃（active）的。检查的表示是当前事件循环是否还有活跃的句柄、活跃的请求操作，或者还有“关闭”回调的话，就视为是活跃的。如果判断当前循环不是活跃的，则直接退出。\n3. 执行所有的到期回调。即所有的到期时间在循环当前时间之前的回调都会被执行。\n4. 执行所有的挂起回调（pending callbacks）。所谓挂起回调，就是在上一个循环周期中设置的到下一循环周期在执行的回调。\n5. 执行空闲句柄回调（idle handle callbacks）。虽然名字中包含空闲二字，实际上每个循环周期都会执行。\n6. 执行准备句柄回调（prepare handle callbacks）。\n7. 在这一步会暂停循环，轮询等待 I/O 事件一段时间。这个时间长度是根据一个算法算出，这里不做详细说明。在轮询期间，所有 I/O 相关的回调会被执行（前提是系统通知到 libuv）。\n8. 执行检查句柄回调（check handle callbacks）。检查句柄回调往往与准备句柄回调相对应。这两个回调可以方便我们在 I/O 之前做一些准备工作，然后在 I/O 之后做相应的检查。\n9. 执行关闭回调（close callbacks）。比如通过 `uv_close()` 设置的回调。\n\n整个事件循环就是 1 - 9 的循环执行。\n\n值得说明的是，libuv 会在轮询阶段中断事件循环，等待系统通知。比如某个文件 I/O 已经完成，或者接收到一个网络连接等。在接收到系统通知后，事件循环会调用相关的回调执行操作。\n\n不同的平台（windows\\linux 等），异步 I/O 的机制不同，libuv 底层会根据不同平台，采用不同的 I/O 轮询机制，比如 epoll（linux）、kqueue（OSX）、IOCP（windows）等，上层不需要关注异步 I/O 的实现机制。\n\n## NodeJS 的事件循环\n\n现在我们来看 NodeJS 的事件循环。同样，我们放一张 NodeJS 事件循环的过程图。\n\n![NodeJS 的事件循环](/posts/images/nodejs-event-loop/nodejs-loop-c.png)\n\n在 NodeJS 中，事件循环的每一步成为一个阶段，每个阶段都有一个 FIFO 队列来执行回调。通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列清空或达到最大回调数限制。当队列清空或者达到最大限制，事件循环进入下一阶段。\n\n对比两个事件循环的图，我们可以看到，具体过程基本相同。因此，NodeJS 的事件循环过程我们简述如下：\n\n1. 定时器阶段，执行已经被 `setTimeout()` 和 `setInterval()` 调度的回调函数。\n2. 挂起的回调，执行（在上一个循环中被设置）延迟到下一个循环迭代的 I/O 回调。\n3. idle, prepare 阶段，仅 NodeJS 系统内部使用。\n4. 轮询阶段，检索新的 I/O 事件，执行与 I/O 相关的回调。与 libuv 一样，NodeJS 还在这个阶段暂停循环一段时间。\n5. 检测阶段，执行被 `setImmediate()` 调度的回调函数。\n6. 关闭的回调函数，执行一些关闭的回调函数，如：`socket.on('close', ...)`。\n\n我们对轮询阶段做个详细说明。\n\n轮询阶段有两个重要的功能：\n\n- 计算应该阻塞和轮询 I/O 的时间。\n- 处理轮询队列里的事件。\n\n一旦事件循环进入轮询阶段并且没有到期的定时器回调时，事件循环将做如下判断：\n\n- 如果轮询队列不是空的，那么事件循环将循环访问回调队列并同步执行它们，直到清空队列，或者达到了最大限制。\n- 如果轮询队列是空的，则再做如下判断：\n  - 如果有代码是被 `setImmediate()` 调度的，那么事件循环将结束轮询阶段，并到检查阶段以执行那些被调度的代码。\n  - 如果没有代码被 `setImmediate()` 调度，那么事件循环将等待回调被添加到队列中，然后立即执行。\n\n在轮询阶段的执行过程中，一旦轮询队列为空，事件循环将检查是否有到期的定制器。如果一个或多个定时器已准备就绪，则事件循环将绕回定时器阶段以执行这些定时器的回调。\n\n这里要特别对 `setImmediate()` 进行一些说明。\n\n在 libuv 的事件循环中，允许开发人员在轮询阶段之前做些准备操作，然后在轮询阶段之后立即对这些操作进行检查。NodeJS 中 `setImmediate()` 实际上是一个在事件循环的单独阶段运行的特殊定时器。它使用一个 libuv API 来安排回调在轮询阶段完成后执行。\n\n## `setImmediate`、`setTimeout` 和 `process.nextTick`\n\n- `setImmediate()` 被设计为一旦在当前轮询阶段完成，就执行代码。\n- `setTimeout()` 是在最小阈值（ms 单位）过后执行代码。\n- `process.nextTick()` 严格意义上讲并不属于事件循环的一部分。它不管事件循环的当前阶段如何，它都将在当前操作完成后处理 `nextTickQueue` 中排队的代码。\n\n`setImmediate()` 和 `setTimeout()` 很类似，但是基于被调用的时机，他们也有不同表现。\n\n我们看下面这段代码：\n\n```js\nsetTimeout(() => {\n  console.log('timeout');\n}, 0);\n\nsetImmediate(() => {\n  console.log('immediate');\n});\n```\n\n这两个函数调用都在主模块中被调用，则他们的回调执行顺序是不定的，受进程的性能影响很大(进程会受到系统中运行其他应用程序影响)。\n\n但是一旦将这两个函数放到 I/O 轮询调用内，那么 `setImmediate()` 一定会在 `setTimeout()` 之前被执行，不管有多个定制器已经到期。比如下面这段代码，总是会先输出 \"immediate\"。\n\n```js\nconst fs = require('fs');\n\nfs.readFile(__filename, () => {\n  setTimeout(() => {\n    console.log('timeout');\n  }, 0);\n  setImmediate(() => {\n    console.log('immediate');\n  });\n});\n```\n\n`process.nextTick()` 和 `setImmediate()` 严格意义上来说，应该将名称互换。因为 `process.nextTick()` 比 `setImmediate()` 触发得更快。\n\n任何时候在给定的阶段中调用 `process.nextTick()`，所有传递到 `process.nextTick()` 的回调将在事件循环继续之前解析。之所以这么设计，是考虑到这些使用场景：\n\n- 允许开发者处理错误，清理任何不需要的资源，或者在事件循环继续之前重试请求。\n- 有时有让回调在栈展开后，但在事件循环继续之前运行的必要。\n\n比如下面这段代码：\n\n```js\nconst server = net.createServer(() => {}).listen(8080);\n\nserver.on('listening', () => {});\n```\n\n只有传递端口时，端口才会立即被绑定，然后立即调用 `'listening'` 回调。问题是 `.on('listening')` 的回调在那个时间点尚未被设置。\n\n为了绕过这个问题，`'listening'` 事件被排在 `nextTick()` 中，以允许脚本运行完成。这让用户设置所想设置的任何事件处理器。\n\n## Promise\n\n这里在补充说明一下 NodeJS 中 Promise 是如何处理的。我们之前说过，在浏览器的事件循环里，会有一个微任务的队列来防止所有的微任务，并且在每个操作之后，都尝试清空微任务队列。\n\n在 NodeJS 中，做法类似，NodeJS 的事件循环中也有一个微任务队列，工作机制与 `process.nextTick()` 类似，在每个操作之后，事件循环都会尝试清空微任务队列。\n\n## 总结\n\n我们结合 libuv 的事件循环，详细说明了 NodeJS 事件循环的每一阶段的具体职能。同时，我们还分析了常用的几个异步代码函数的原理。\n\n我们用一张图归纳如下：\n\n![事件循环](/posts/images/nodejs-event-loop/event-loop-c.png)\n",contentRendered:'<p>事件循环是 NodeJS 处理非阻塞 I/O 操作的和核心机制。NodeJS 的事件循环脱胎于 <a href="http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop" target="_blank" rel="noopener noreferrer">libuv<OutboundLink/></a> 的事件循环，因此，要搞清楚 NodeJS 的事件循环，还需要先了解 libuv 的事件循环是如何工作的。</p>\n<h2 id="libuv-的事件循环" tabindex="-1"><a class="header-anchor" href="#libuv-的事件循环" aria-hidden="true">#</a> libuv 的事件循环</h2>\n<p>我们先来了解两个基本概念：句柄（handle）和请求（request）.</p>\n<ul>\n<li>句柄是指在整个事件循环活跃时间内能够执行某些操作的长期对象。比如一个 TCP 服务句柄，每当有新的联接建立时，这个句柄的 <code>connected</code> 回调就会被调用。</li>\n<li>请求是通常指短期操作。比如向某个句柄中写入数据的操作。</li>\n</ul>\n<p>了解了这两个概念以后，我们来看看 libuv 的事件循环是如何工作的。</p>\n<p>下面这张图可以清楚的展示事件循环的执行过程：</p>\n<p><img src="/posts/images/nodejs-event-loop/libuv-loop-c.png" alt="libuv 的事件循环"></p>\n<p>结合这张图我们简单描述一下一次循环过程中各个步骤做了什么。</p>\n<ol>\n<li>首先更新循环内的当前时间（now），避免在循环过程中多次发生与时间相关的系统调用。</li>\n<li>检查当前事件循环是否还是活跃（active）的。检查的表示是当前事件循环是否还有活跃的句柄、活跃的请求操作，或者还有“关闭”回调的话，就视为是活跃的。如果判断当前循环不是活跃的，则直接退出。</li>\n<li>执行所有的到期回调。即所有的到期时间在循环当前时间之前的回调都会被执行。</li>\n<li>执行所有的挂起回调（pending callbacks）。所谓挂起回调，就是在上一个循环周期中设置的到下一循环周期在执行的回调。</li>\n<li>执行空闲句柄回调（idle handle callbacks）。虽然名字中包含空闲二字，实际上每个循环周期都会执行。</li>\n<li>执行准备句柄回调（prepare handle callbacks）。</li>\n<li>在这一步会暂停循环，轮询等待 I/O 事件一段时间。这个时间长度是根据一个算法算出，这里不做详细说明。在轮询期间，所有 I/O 相关的回调会被执行（前提是系统通知到 libuv）。</li>\n<li>执行检查句柄回调（check handle callbacks）。检查句柄回调往往与准备句柄回调相对应。这两个回调可以方便我们在 I/O 之前做一些准备工作，然后在 I/O 之后做相应的检查。</li>\n<li>执行关闭回调（close callbacks）。比如通过 <code>uv_close()</code> 设置的回调。</li>\n</ol>\n<p>整个事件循环就是 1 - 9 的循环执行。</p>\n<p>值得说明的是，libuv 会在轮询阶段中断事件循环，等待系统通知。比如某个文件 I/O 已经完成，或者接收到一个网络连接等。在接收到系统通知后，事件循环会调用相关的回调执行操作。</p>\n<p>不同的平台（windows\\linux 等），异步 I/O 的机制不同，libuv 底层会根据不同平台，采用不同的 I/O 轮询机制，比如 epoll（linux）、kqueue（OSX）、IOCP（windows）等，上层不需要关注异步 I/O 的实现机制。</p>\n<h2 id="nodejs-的事件循环" tabindex="-1"><a class="header-anchor" href="#nodejs-的事件循环" aria-hidden="true">#</a> NodeJS 的事件循环</h2>\n<p>现在我们来看 NodeJS 的事件循环。同样，我们放一张 NodeJS 事件循环的过程图。</p>\n<p><img src="/posts/images/nodejs-event-loop/nodejs-loop-c.png" alt="NodeJS 的事件循环"></p>\n<p>在 NodeJS 中，事件循环的每一步成为一个阶段，每个阶段都有一个 FIFO 队列来执行回调。通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列清空或达到最大回调数限制。当队列清空或者达到最大限制，事件循环进入下一阶段。</p>\n<p>对比两个事件循环的图，我们可以看到，具体过程基本相同。因此，NodeJS 的事件循环过程我们简述如下：</p>\n<ol>\n<li>定时器阶段，执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 调度的回调函数。</li>\n<li>挂起的回调，执行（在上一个循环中被设置）延迟到下一个循环迭代的 I/O 回调。</li>\n<li>idle, prepare 阶段，仅 NodeJS 系统内部使用。</li>\n<li>轮询阶段，检索新的 I/O 事件，执行与 I/O 相关的回调。与 libuv 一样，NodeJS 还在这个阶段暂停循环一段时间。</li>\n<li>检测阶段，执行被 <code>setImmediate()</code> 调度的回调函数。</li>\n<li>关闭的回调函数，执行一些关闭的回调函数，如：<code>socket.on(\'close\', ...)</code>。</li>\n</ol>\n<p>我们对轮询阶段做个详细说明。</p>\n<p>轮询阶段有两个重要的功能：</p>\n<ul>\n<li>计算应该阻塞和轮询 I/O 的时间。</li>\n<li>处理轮询队列里的事件。</li>\n</ul>\n<p>一旦事件循环进入轮询阶段并且没有到期的定时器回调时，事件循环将做如下判断：</p>\n<ul>\n<li>如果轮询队列不是空的，那么事件循环将循环访问回调队列并同步执行它们，直到清空队列，或者达到了最大限制。</li>\n<li>如果轮询队列是空的，则再做如下判断：\n<ul>\n<li>如果有代码是被 <code>setImmediate()</code> 调度的，那么事件循环将结束轮询阶段，并到检查阶段以执行那些被调度的代码。</li>\n<li>如果没有代码被 <code>setImmediate()</code> 调度，那么事件循环将等待回调被添加到队列中，然后立即执行。</li>\n</ul>\n</li>\n</ul>\n<p>在轮询阶段的执行过程中，一旦轮询队列为空，事件循环将检查是否有到期的定制器。如果一个或多个定时器已准备就绪，则事件循环将绕回定时器阶段以执行这些定时器的回调。</p>\n<p>这里要特别对 <code>setImmediate()</code> 进行一些说明。</p>\n<p>在 libuv 的事件循环中，允许开发人员在轮询阶段之前做些准备操作，然后在轮询阶段之后立即对这些操作进行检查。NodeJS 中 <code>setImmediate()</code> 实际上是一个在事件循环的单独阶段运行的特殊定时器。它使用一个 libuv API 来安排回调在轮询阶段完成后执行。</p>\n<h2 id="setimmediate、settimeout-和-process-nexttick" tabindex="-1"><a class="header-anchor" href="#setimmediate、settimeout-和-process-nexttick" aria-hidden="true">#</a> <code>setImmediate</code>、<code>setTimeout</code> 和 <code>process.nextTick</code></h2>\n<ul>\n<li><code>setImmediate()</code> 被设计为一旦在当前轮询阶段完成，就执行代码。</li>\n<li><code>setTimeout()</code> 是在最小阈值（ms 单位）过后执行代码。</li>\n<li><code>process.nextTick()</code> 严格意义上讲并不属于事件循环的一部分。它不管事件循环的当前阶段如何，它都将在当前操作完成后处理 <code>nextTickQueue</code> 中排队的代码。</li>\n</ul>\n<p><code>setImmediate()</code> 和 <code>setTimeout()</code> 很类似，但是基于被调用的时机，他们也有不同表现。</p>\n<p>我们看下面这段代码：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'timeout\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'immediate\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这两个函数调用都在主模块中被调用，则他们的回调执行顺序是不定的，受进程的性能影响很大(进程会受到系统中运行其他应用程序影响)。</p>\n<p>但是一旦将这两个函数放到 I/O 轮询调用内，那么 <code>setImmediate()</code> 一定会在 <code>setTimeout()</code> 之前被执行，不管有多个定制器已经到期。比如下面这段代码，总是会先输出 &quot;immediate&quot;。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'fs\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nfs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'timeout\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'immediate\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>process.nextTick()</code> 和 <code>setImmediate()</code> 严格意义上来说，应该将名称互换。因为 <code>process.nextTick()</code> 比 <code>setImmediate()</code> 触发得更快。</p>\n<p>任何时候在给定的阶段中调用 <code>process.nextTick()</code>，所有传递到 <code>process.nextTick()</code> 的回调将在事件循环继续之前解析。之所以这么设计，是考虑到这些使用场景：</p>\n<ul>\n<li>允许开发者处理错误，清理任何不需要的资源，或者在事件循环继续之前重试请求。</li>\n<li>有时有让回调在栈展开后，但在事件循环继续之前运行的必要。</li>\n</ul>\n<p>比如下面这段代码：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nserver<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">\'listening\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>只有传递端口时，端口才会立即被绑定，然后立即调用 <code>\'listening\'</code> 回调。问题是 <code>.on(\'listening\')</code> 的回调在那个时间点尚未被设置。</p>\n<p>为了绕过这个问题，<code>\'listening\'</code> 事件被排在 <code>nextTick()</code> 中，以允许脚本运行完成。这让用户设置所想设置的任何事件处理器。</p>\n<h2 id="promise" tabindex="-1"><a class="header-anchor" href="#promise" aria-hidden="true">#</a> Promise</h2>\n<p>这里在补充说明一下 NodeJS 中 Promise 是如何处理的。我们之前说过，在浏览器的事件循环里，会有一个微任务的队列来防止所有的微任务，并且在每个操作之后，都尝试清空微任务队列。</p>\n<p>在 NodeJS 中，做法类似，NodeJS 的事件循环中也有一个微任务队列，工作机制与 <code>process.nextTick()</code> 类似，在每个操作之后，事件循环都会尝试清空微任务队列。</p>\n<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>\n<p>我们结合 libuv 的事件循环，详细说明了 NodeJS 事件循环的每一阶段的具体职能。同时，我们还分析了常用的几个异步代码函数的原理。</p>\n<p>我们用一张图归纳如下：</p>\n<p><img src="/posts/images/nodejs-event-loop/event-loop-c.png" alt="事件循环"></p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-15",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/nodejs-event-loop.html",pathLocale:"/",permalink:"/posts/2021/08/15/nodejs-event-loop.html",slug:"nodejs-event-loop",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/nodejs-event-loop.md",filePathRelative:"posts/nodejs-event-loop.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/15/nodejs-event-loop.html.vue",componentFilePathRelative:"pages/posts/2021/08/15/nodejs-event-loop.html.vue",componentFileChunkName:"v-b8462e7e",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/15/nodejs-event-loop.html.js",dataFilePathRelative:"pages/posts/2021/08/15/nodejs-event-loop.html.js",dataFileChunkName:"v-b8462e7e",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/08/15/nodejs-event-loop.html",htmlFilePathRelative:"posts/2021/08/15/nodejs-event-loop.html"},{key:"v-41b58876",path:"/posts/2021/09/24/nodejs-garbage-collection.html",title:"NodeJS 的垃圾回收",lang:"zh-CN",frontmatter:{title:"NodeJS 的垃圾回收",description:"什么是垃圾回收？NodeJS 中的垃圾回收是如何实现的？",keywords:["垃圾回收","garbage collection"],date:"2021-09-24T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"垃圾回收",slug:"垃圾回收",children:[{level:3,title:"垃圾回收之前的内存",slug:"垃圾回收之前的内存",children:[]},{level:3,title:"垃圾回收之后的内存",slug:"垃圾回收之后的内存",children:[]}]},{level:2,title:"垃圾回收是如何工作的",slug:"垃圾回收是如何工作的",children:[{level:3,title:"基本概念",slug:"基本概念",children:[]},{level:3,title:"垃圾回收器是如何工作的",slug:"垃圾回收器是如何工作的",children:[]}]}],content:"\n通常来说，内存管理有两种方式，一种是手动管理，一种是自动管理。\n\n手动管理需要开发者自己管理内存，什么时候申请内存空间，什么时候释放都需要小心处理，否则容易形成内存泄漏和指针乱飞的局面。C 语言开发是典型的需要手动管理内存的例子。\n\n自动管理通常通过垃圾回收的机制来实现内存管理。NodeJS 中的内存管理是自动管理的。\n\n## 垃圾回收\n\n垃圾回收器（garbage collector，GC）通过判断对象是否还在被其他对象引用来决定是否回收该对象的内存空间。\n\n### 垃圾回收之前的内存\n\n在下面的图中，有一些对象还在被其他对象使用，而有一些对象已经是完全孤立状态，没有其他对象使用它了。这些已经完全孤立状态的对象是可以被垃圾回收器回收的。\n\n![垃圾回收之前的内存](/posts/images/nodejs-garbage-collection/memory-state-before-node-js-garbage-collection-c.png)\n\n\n### 垃圾回收之后的内存\n\n垃圾回收一旦开始运行，内存中的那些完全孤立（不可到达）的对象会被删除，内存空间会被释放。\n\n![垃圾回收之后的内存](/posts/images/nodejs-garbage-collection/memory-state-after-node-js-garbage-collection-c.png)\n\n## 垃圾回收是如何工作的\n\n要搞清楚垃圾回收是如何工作的，需要先了解一些基本概念。\n\n### 基本概念\n\n* **常驻集大小（resident set size）**：NodeJS 进程运行时占据的内存大小，通常包含：代码、栈和堆。\n* **栈（stack）**：包含原始类型数据和指向对象的引用数据。\n\n    栈中保存着局部变量和指向堆上对象的指针或定义应用程序控制流的指针（比如函数调用等）。\n\n    下面代码中，`a` 和 `b` 都保存在栈中。\n    ```js\n    function add (a, b) {\n      return a + b\n    }\n    add(4, 5)\n    ```\n\n* **堆（heap）**：存放引用类型数据，比如对象、字符串、闭包等。\n\n    下面代码中，创建的 `Car` 对象会被保存在堆中。\n\n    ```js\n    function Car (opts) {\n    this.name = opts.name\n    }\n\n    const LightningMcQueen = new Car({name: 'Lightning McQueen'})\n    ```\n\n    对象创建后，堆内存状态如下：\n\n    ![堆内存](/posts/images/nodejs-garbage-collection/node-js-garbage-collection-first-step-object-placed-in-memory-heap-c.png)\n\n    现在我们添加更多的对象：\n\n    ```js\n    const SallyCarrera = new Car({name: 'Sally Carrera'})\n    const Mater = new Car({name: 'Mater'})\n    ```\n\n    堆内存状态如下：\n\n    ![堆内存](/posts/images/nodejs-garbage-collection/node-js-garbage-collection-second-step-more-elements-added-to-the-heap-c.png)\n\n    如果现在执行垃圾回收，没有任何内存会被释放，因为每个对象都在被使用（可到达）。\n\n    现在我们修改代码，如下：\n\n    ```js\n    function Engine (power) {\n    this.power = power\n    }\n\n    function Car (opts) {\n    this.name = opts.name\n    this.engine = new Engine(opts.power)\n    }\n\n    let LightningMcQueen = new Car({name: 'Lightning McQueen', power: 900})\n    let SallyCarrera = new Car({name: 'Sally Carrera', power: 500})\n    let Mater = new Car({name: 'Mater', power: 100})\n    ```\n\n    堆内存状态变成：\n\n    ![堆内存](/posts/images/nodejs-garbage-collection/node-js-garbage-collection-assigning-values-to-the-objects-in-heap-c.png)\n\n    如果我们不在使用 `Mater` 的话，通过 `Mater = undefined` 删除了对内存中对象的引用，则内存状态变化为：\n\n    ![堆内存](/posts/images/nodejs-garbage-collection/node-js-garbage-collection-redefining-values-c.png)\n\n    此时内存中的 `Mater` 不再被其他对象使用了（不可达），当垃圾回收运行的时候，`Mater` 对象会被回收，其占据的内存会被释放。\n\n    ![堆内存](/posts/images/nodejs-garbage-collection/node-js-garbage-collection-freeing-up-unreachable-object-c.png)\n\n* **对象的浅层大小（shallow size of an object）**：对象本身占据的内存大小。\n* **对象的保留大小（retained size of an object）**：删除对象及其依赖对象后释放的内存大小\n\n### 垃圾回收器是如何工作的\n\nNodeJS 的垃圾回收通过 V8 实现。大多数对象的生命周期都很短，而少数对象的寿命往往更长。为了利用这种行为，V8 将堆分成两个部分，**年轻代（Young Generation）**和**老年代（Old Generation）**。\n\n#### 年轻代\n\n新的内存需求都在年轻代中分配。年轻代的大小很小，在 1 到 8 MB 之间。在年轻代中内存分配非常便宜，V8 在内存中会逐个为对象分配空间，当到达年轻代的边界时，会触发一次垃圾回收。\n\nV8 在年轻代会采用 Scavenge 回收策略。Scavenge 采用复制的方式进行垃圾回收。它将内存一分为二，每一部分空间称为 semispace。这两个空间，只有一个空间处于使用中，另一个则处于闲置。使用中的 semispace 称为 「From 空间」，闲置的 semispace 称为 「To 空间」。\n\n年轻代的内存分配过程如下：\n\n1. 从 From 空间分配对象，若 semispace 被分配满，则执行 Scavenge 算法进行垃圾回收。\n2. 检查 From 空间中的对象，若对象可到达，则检查对象是否符合提升条件，若符合条件则提升到老生代，否则将对象从 From 空间复制到 To 空间。\n3. 若对象不可到达，则释放不可到达对象的空间。\n4. 完成复制后，将 From 空间与 To 空间进行角色翻转（flip）。\n\n\n在年轻代中幸存的对象会被提升到老年代。\n\n#### 老年代\n\n老年代中的对象有两个特点，第一是存活对象多，第二个存活时间长。若在老年代中使用 Scavenge 算法进行垃圾回收，将会导致复制存活对象的效率不高，且还会浪费一半的空间。因此在老年代中，V8 通常采用 Mark-Sweep 和 Mark-Compact 策略回收。\n\nMark-Sweep 就是标记清除，它主要分为标记和清除两个阶段。\n\n* 标记阶段，将遍历堆中所有对象，并对存活的对象进行标记；\n* 清除阶段，对未标记对象的空间进行回收。\n\n与 Scavenge 策略不同，Mark-Sweep 不会对内存一分为二，因此不会浪费空间。但是，经历过一次 Mark-Sweep 之后，内存的空间将会变得不连续，这样会对后续内存分配造成问题。比如，当需要分配一个比较大的对象时，没有任何一个碎片内支持分配，这将提前触发一次垃圾回收，尽管这次垃圾回收是没有必要的。\n\n![标记清除](/posts/images/nodejs-garbage-collection/mark-sweep-c.png)\n\n为了解决内存碎片的问题，提高对内存的利用，引入了 Mark-Compact （标记整理）策略。Mark-Compact 是在 Mark-Sweep 算法上进行了改进，标记阶段与 Mark-Sweep 相同，但是对未标记的对象处理方式不同。与Mark-Sweep是对未标记的对象立即进行回收，Mark-Compact则是将存活的对象移动到一边，然后再清理端边界外的内存。\n\n![标记整理](/posts/images/nodejs-garbage-collection/mark-compact-c.png)\n\n由于 Mark-Compact 需要移动对象，所以执行速度上，比 Mark-Sweep 要慢。所以，V8 主要使用 Mark-Sweep 算法，然后在当空间内存分配不足时，采用 Mark-Compact 算法。\n",contentRendered:'<p>通常来说，内存管理有两种方式，一种是手动管理，一种是自动管理。</p>\n<p>手动管理需要开发者自己管理内存，什么时候申请内存空间，什么时候释放都需要小心处理，否则容易形成内存泄漏和指针乱飞的局面。C 语言开发是典型的需要手动管理内存的例子。</p>\n<p>自动管理通常通过垃圾回收的机制来实现内存管理。NodeJS 中的内存管理是自动管理的。</p>\n<h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2>\n<p>垃圾回收器（garbage collector，GC）通过判断对象是否还在被其他对象引用来决定是否回收该对象的内存空间。</p>\n<h3 id="垃圾回收之前的内存" tabindex="-1"><a class="header-anchor" href="#垃圾回收之前的内存" aria-hidden="true">#</a> 垃圾回收之前的内存</h3>\n<p>在下面的图中，有一些对象还在被其他对象使用，而有一些对象已经是完全孤立状态，没有其他对象使用它了。这些已经完全孤立状态的对象是可以被垃圾回收器回收的。</p>\n<p><img src="/posts/images/nodejs-garbage-collection/memory-state-before-node-js-garbage-collection-c.png" alt="垃圾回收之前的内存"></p>\n<h3 id="垃圾回收之后的内存" tabindex="-1"><a class="header-anchor" href="#垃圾回收之后的内存" aria-hidden="true">#</a> 垃圾回收之后的内存</h3>\n<p>垃圾回收一旦开始运行，内存中的那些完全孤立（不可到达）的对象会被删除，内存空间会被释放。</p>\n<p><img src="/posts/images/nodejs-garbage-collection/memory-state-after-node-js-garbage-collection-c.png" alt="垃圾回收之后的内存"></p>\n<h2 id="垃圾回收是如何工作的" tabindex="-1"><a class="header-anchor" href="#垃圾回收是如何工作的" aria-hidden="true">#</a> 垃圾回收是如何工作的</h2>\n<p>要搞清楚垃圾回收是如何工作的，需要先了解一些基本概念。</p>\n<h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3>\n<ul>\n<li>\n<p><strong>常驻集大小（resident set size）</strong>：NodeJS 进程运行时占据的内存大小，通常包含：代码、栈和堆。</p>\n</li>\n<li>\n<p><strong>栈（stack）</strong>：包含原始类型数据和指向对象的引用数据。</p>\n<p>栈中保存着局部变量和指向堆上对象的指针或定义应用程序控制流的指针（比如函数调用等）。</p>\n<p>下面代码中，<code>a</code> 和 <code>b</code> 都保存在栈中。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> a <span class="token operator">+</span> b\n<span class="token punctuation">}</span>\n<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li>\n<li>\n<p><strong>堆（heap）</strong>：存放引用类型数据，比如对象、字符串、闭包等。</p>\n<p>下面代码中，创建的 <code>Car</code> 对象会被保存在堆中。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Car</span> <span class="token punctuation">(</span><span class="token parameter">opts</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> opts<span class="token punctuation">.</span>name\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> LightningMcQueen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">\'Lightning McQueen\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>对象创建后，堆内存状态如下：</p>\n<p><img src="/posts/images/nodejs-garbage-collection/node-js-garbage-collection-first-step-object-placed-in-memory-heap-c.png" alt="堆内存"></p>\n<p>现在我们添加更多的对象：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> SallyCarrera <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">\'Sally Carrera\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> Mater <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">\'Mater\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>堆内存状态如下：</p>\n<p><img src="/posts/images/nodejs-garbage-collection/node-js-garbage-collection-second-step-more-elements-added-to-the-heap-c.png" alt="堆内存"></p>\n<p>如果现在执行垃圾回收，没有任何内存会被释放，因为每个对象都在被使用（可到达）。</p>\n<p>现在我们修改代码，如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Engine</span> <span class="token punctuation">(</span><span class="token parameter">power</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>power <span class="token operator">=</span> power\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">Car</span> <span class="token punctuation">(</span><span class="token parameter">opts</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> opts<span class="token punctuation">.</span>name\n<span class="token keyword">this</span><span class="token punctuation">.</span>engine <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Engine</span><span class="token punctuation">(</span>opts<span class="token punctuation">.</span>power<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> LightningMcQueen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">\'Lightning McQueen\'</span><span class="token punctuation">,</span> power<span class="token operator">:</span> <span class="token number">900</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> SallyCarrera <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">\'Sally Carrera\'</span><span class="token punctuation">,</span> power<span class="token operator">:</span> <span class="token number">500</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> Mater <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">\'Mater\'</span><span class="token punctuation">,</span> power<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>堆内存状态变成：</p>\n<p><img src="/posts/images/nodejs-garbage-collection/node-js-garbage-collection-assigning-values-to-the-objects-in-heap-c.png" alt="堆内存"></p>\n<p>如果我们不在使用 <code>Mater</code> 的话，通过 <code>Mater = undefined</code> 删除了对内存中对象的引用，则内存状态变化为：</p>\n<p><img src="/posts/images/nodejs-garbage-collection/node-js-garbage-collection-redefining-values-c.png" alt="堆内存"></p>\n<p>此时内存中的 <code>Mater</code> 不再被其他对象使用了（不可达），当垃圾回收运行的时候，<code>Mater</code> 对象会被回收，其占据的内存会被释放。</p>\n<p><img src="/posts/images/nodejs-garbage-collection/node-js-garbage-collection-freeing-up-unreachable-object-c.png" alt="堆内存"></p>\n</li>\n<li>\n<p><strong>对象的浅层大小（shallow size of an object）</strong>：对象本身占据的内存大小。</p>\n</li>\n<li>\n<p><strong>对象的保留大小（retained size of an object）</strong>：删除对象及其依赖对象后释放的内存大小</p>\n</li>\n</ul>\n<h3 id="垃圾回收器是如何工作的" tabindex="-1"><a class="header-anchor" href="#垃圾回收器是如何工作的" aria-hidden="true">#</a> 垃圾回收器是如何工作的</h3>\n<p>NodeJS 的垃圾回收通过 V8 实现。大多数对象的生命周期都很短，而少数对象的寿命往往更长。为了利用这种行为，V8 将堆分成两个部分，<strong>年轻代（Young Generation）<strong>和</strong>老年代（Old Generation）</strong>。</p>\n<h4 id="年轻代" tabindex="-1"><a class="header-anchor" href="#年轻代" aria-hidden="true">#</a> 年轻代</h4>\n<p>新的内存需求都在年轻代中分配。年轻代的大小很小，在 1 到 8 MB 之间。在年轻代中内存分配非常便宜，V8 在内存中会逐个为对象分配空间，当到达年轻代的边界时，会触发一次垃圾回收。</p>\n<p>V8 在年轻代会采用 Scavenge 回收策略。Scavenge 采用复制的方式进行垃圾回收。它将内存一分为二，每一部分空间称为 semispace。这两个空间，只有一个空间处于使用中，另一个则处于闲置。使用中的 semispace 称为 「From 空间」，闲置的 semispace 称为 「To 空间」。</p>\n<p>年轻代的内存分配过程如下：</p>\n<ol>\n<li>从 From 空间分配对象，若 semispace 被分配满，则执行 Scavenge 算法进行垃圾回收。</li>\n<li>检查 From 空间中的对象，若对象可到达，则检查对象是否符合提升条件，若符合条件则提升到老生代，否则将对象从 From 空间复制到 To 空间。</li>\n<li>若对象不可到达，则释放不可到达对象的空间。</li>\n<li>完成复制后，将 From 空间与 To 空间进行角色翻转（flip）。</li>\n</ol>\n<p>在年轻代中幸存的对象会被提升到老年代。</p>\n<h4 id="老年代" tabindex="-1"><a class="header-anchor" href="#老年代" aria-hidden="true">#</a> 老年代</h4>\n<p>老年代中的对象有两个特点，第一是存活对象多，第二个存活时间长。若在老年代中使用 Scavenge 算法进行垃圾回收，将会导致复制存活对象的效率不高，且还会浪费一半的空间。因此在老年代中，V8 通常采用 Mark-Sweep 和 Mark-Compact 策略回收。</p>\n<p>Mark-Sweep 就是标记清除，它主要分为标记和清除两个阶段。</p>\n<ul>\n<li>标记阶段，将遍历堆中所有对象，并对存活的对象进行标记；</li>\n<li>清除阶段，对未标记对象的空间进行回收。</li>\n</ul>\n<p>与 Scavenge 策略不同，Mark-Sweep 不会对内存一分为二，因此不会浪费空间。但是，经历过一次 Mark-Sweep 之后，内存的空间将会变得不连续，这样会对后续内存分配造成问题。比如，当需要分配一个比较大的对象时，没有任何一个碎片内支持分配，这将提前触发一次垃圾回收，尽管这次垃圾回收是没有必要的。</p>\n<p><img src="/posts/images/nodejs-garbage-collection/mark-sweep-c.png" alt="标记清除"></p>\n<p>为了解决内存碎片的问题，提高对内存的利用，引入了 Mark-Compact （标记整理）策略。Mark-Compact 是在 Mark-Sweep 算法上进行了改进，标记阶段与 Mark-Sweep 相同，但是对未标记的对象处理方式不同。与Mark-Sweep是对未标记的对象立即进行回收，Mark-Compact则是将存活的对象移动到一边，然后再清理端边界外的内存。</p>\n<p><img src="/posts/images/nodejs-garbage-collection/mark-compact-c.png" alt="标记整理"></p>\n<p>由于 Mark-Compact 需要移动对象，所以执行速度上，比 Mark-Sweep 要慢。所以，V8 主要使用 Mark-Sweep 算法，然后在当空间内存分配不足时，采用 Mark-Compact 算法。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-09-24",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/nodejs-garbage-collection.html",pathLocale:"/",permalink:"/posts/2021/09/24/nodejs-garbage-collection.html",slug:"nodejs-garbage-collection",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/nodejs-garbage-collection.md",filePathRelative:"posts/nodejs-garbage-collection.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/09/24/nodejs-garbage-collection.html.vue",componentFilePathRelative:"pages/posts/2021/09/24/nodejs-garbage-collection.html.vue",componentFileChunkName:"v-41b58876",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/09/24/nodejs-garbage-collection.html.js",dataFilePathRelative:"pages/posts/2021/09/24/nodejs-garbage-collection.html.js",dataFileChunkName:"v-41b58876",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/09/24/nodejs-garbage-collection.html",htmlFilePathRelative:"posts/2021/09/24/nodejs-garbage-collection.html"},{key:"v-5e3eb789",path:"/posts/2021/08/06/nodejs-streams.html",title:"图解 NodeJS 流",lang:"zh-CN",frontmatter:{title:"图解 NodeJS 流",description:"以图形化的形式，介绍 NodeJS 中流的类型、工作原理，以及如何使用流。",keywords:["NodeJS","流","stream"],date:"2021-08-06T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"水流，信息流",slug:"水流-信息流",children:[]},{level:2,title:"可读流（Readable Stream）",slug:"可读流-readable-stream",children:[]},{level:2,title:"可写流（Writable Stream）",slug:"可写流-writable-stream",children:[]},{level:2,title:"双工流（Duplex Streams）",slug:"双工流-duplex-streams",children:[]},{level:2,title:"转换流（Transform Stream）",slug:"转换流-transform-stream",children:[]},{level:2,title:"管道（Pipe）",slug:"管道-pipe",children:[{level:3,title:"使用流复制数据",slug:"使用流复制数据",children:[]}]},{level:2,title:"高水位线控制（highWaterMark）",slug:"高水位线控制-highwatermark",children:[]},{level:2,title:"流的应用",slug:"流的应用",children:[]}],content:"\n假设我们现在要盖一座房子，我们买了一些砖块，厂家正在送货。现在我们有两个选择，一是等所有砖块都到了以后再开始动工；二是到一批砖块就开始动工，砖块到多少我们就用多少。\n\n这两种方式哪种效率更高呢？显然是第二种。这就是流（stream）的理念。在计算机科学中，流是随时间可用的一系列数据元素。就像传送带运输物品一样，使用流可以实现一次处理一个数据元素。\n\n在 NodeJS 中，[stream](https://nodejs.org/api/stream.html) 模块实现了流的功能。即使我们没有直接使用过这个模块，我们也间接使用过流，比如读写文件、网络等。\n\n## 水流，信息流\n\n信息就像水流一样，以比特流（strem of bits）的形式从一个地方流到另一个地方。比如读取文件，信息就从磁盘流向了应用程序。\n\n但是，流的两端处理信息的速度是不同的，通常流的一端会比另一端要慢，因此就需要一个缓存来作为缓冲（buffer）。\n\n如下图所示，上面的水龙头水流较大，下面的水龙头水流较小，因此需要一个容器来暂时存储下面的水龙头来不及处理的水。\n\n![流与缓存](/posts/images/node-streams/stream-c.png)\n\nNodeJS 中流的基本原理也是这样的，stream 模块实现了这些能力。\n\n在 NodeJS 中有两种基本的流可以使用：\n\n* 可读流（Readable Streams）\n* 可写流（Writable Streams）\n\n同时还有两种读写混合的流：\n\n* 双工流（Duplex Streams）-- 可读可写的流\n* 转换流（Transform Streams）-- 可以转换数据的双工流\n\n## 可读流（Readable Stream）\n\n可读流可以从一个地方读取数据，比如从文件中读取信息。读取的数据可以暂时存放在可读流中的[缓存（Buffer）](https://nodejs.org/api/stream.html#stream_buffering)里，防止应用程序无法及时处理。\n\n![可读流](/posts/images/node-streams/readable-c.png)\n\n常见的可读流有 [`process.stdin`](https://nodejs.org/api/process.html#process_process_stdin)、[`fs.createReadStream`](https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options) 以及 HTTP 服务中的 [`IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage) 对象。\n\n## 可写流（Writable Stream）\n\n可写流可以将数据写到一个地方，比如将数据写入文件中。为了防止因为写入目标处理速度太慢导致数据丢失，写入的数据可以暂存在可写流内部的缓存（Buffer）中。\n\n![可写流](/posts/images/node-streams/writable-c.png)\n\n常用的可写流有 [`process.stdout`](https://nodejs.org/api/process.html#process_process_stdout)、[`process.stderr`](https://nodejs.org/api/process.html#process_process_stderr) 和 [`fs.createWriteStream`](https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options).\n\n## 双工流（Duplex Streams）\n\n双工流是可读流和可写流的混合体。连接到双工流之后，应用程序既可以从流中读取数据，也可以向流中写入数据。在双工流中，可读流和可写流有各自独立的缓存（Buffer）。\n\n![双工流](/posts/images/node-streams/duplex-c.png)\n\n最常用的双工流就是 [`net.Socket`](https://nodejs.org/api/net.html#net_class_net_socket)。\n\n## 转换流（Transform Stream）\n\n转换流是更加特殊的混合流，在转换流中，可读流是通过某种方式连接到可写流上的。\n\n![转换流](/posts/images/node-streams/transform-c.png)\n\n最常见的转换流是有 [`Cipher`](https://nodejs.org/api/stream.html#stream_buffering) 创建的流。在这个流中，应用程序写入数据，然后再从流中读取加密后的数据。\n\n## 管道（Pipe）\n\n通常流在连接到一起之后才能发挥更大的作用。我们通过管道来连接流。\n\n比如我们可以将一个可读流连接到一个可写流或者双工流上，仅仅使用可读流的 `pipe()` 方法即可。\n\n常见的管道场景就是复制文件。将 `fs.createReadStream()` 创建的流通过 `pipe()` 方法连接到 `fs.createWriteStream()` 创建的流上去。\n\n### 使用流复制数据\n\n我们可以将流连接到多个其他流上。这在一些需要重复读取原始数据的场景中非常有用。因为可读流只能读取一次数据，因此我们可以通过 `pipe()` 方法将可读流连接到多个流上，这样这些被连接的流就可以直接消费数据，不需要创建多个可读流。\n\n```js\nconst fs = require('fs')\n\nconst original = fs.createReadStream('./original.txt')\nconst copy1 = fs.createWriteStream('./copy1.txt')\nconst copy2 = fs.createWriteStream('./copy2.txt')\n\noriginal.pipe(copy1)\noriginal.pipe(copy2)\n```\n\n![使用流复制数据](/posts/images/node-streams/copy-file-c.png)\n\n\n## 高水位线控制（highWaterMark）\n\n在最开始的例子中，我们通过水箱蓄水的例子描述了流的缓存特性。因为上方的水流始终比下方的水流快，水箱中的水越来越多，终究会超过水箱的容积而溢出。\n\n因此我们需要一个高水位警戒线，当水箱中的水位高于这个警戒线的时候，就需要通知上方的水龙头暂时停止放水了。\n\n![高水位线控制](/posts/images/node-streams/high-water-mark-c.png)\n\n在流中也是同样的原理，可读流和可写流内部都有缓存，这些缓存的最大可存储量是系统的可用内存量。NodeJS 流通过 `highWaterMark` 这个配置项来控制缓存中的水位线。\n\n举个例子，如下图，可读流连接到可写流之后，可写流通过 `highWaterMark` 来检测缓存中的水位是否过高，高于这条线之后，可写流会通知可读流暂停写入数据。\n\n![高水位线控制](/posts/images/node-streams/read-write-high-water-mark-c.png)\n\n需要注意的是，`highWaterMark` 只是一个警示线，并不是一个硬性约束条件。也就是说，如果自定义的流没有正确处理这个警示线的话，可能会导致数据丢失。\n\n## 流的应用\n\n我们来举个例子综合说明如何使用流。\n\n假设我们有一个裁减图片的应用程序。用户将图片的地址告诉应用程序，应用程序从网络上读取原始图片，裁减之后再返回给用户。那么我们可以借助于流来实现这个应用程序的功能，如下图。\n\n\n![裁减图片的应用](/posts/images/node-streams/stream-usage-c.png)\n",contentRendered:'<p>假设我们现在要盖一座房子，我们买了一些砖块，厂家正在送货。现在我们有两个选择，一是等所有砖块都到了以后再开始动工；二是到一批砖块就开始动工，砖块到多少我们就用多少。</p>\n<p>这两种方式哪种效率更高呢？显然是第二种。这就是流（stream）的理念。在计算机科学中，流是随时间可用的一系列数据元素。就像传送带运输物品一样，使用流可以实现一次处理一个数据元素。</p>\n<p>在 NodeJS 中，<a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener noreferrer">stream<OutboundLink/></a> 模块实现了流的功能。即使我们没有直接使用过这个模块，我们也间接使用过流，比如读写文件、网络等。</p>\n<h2 id="水流-信息流" tabindex="-1"><a class="header-anchor" href="#水流-信息流" aria-hidden="true">#</a> 水流，信息流</h2>\n<p>信息就像水流一样，以比特流（strem of bits）的形式从一个地方流到另一个地方。比如读取文件，信息就从磁盘流向了应用程序。</p>\n<p>但是，流的两端处理信息的速度是不同的，通常流的一端会比另一端要慢，因此就需要一个缓存来作为缓冲（buffer）。</p>\n<p>如下图所示，上面的水龙头水流较大，下面的水龙头水流较小，因此需要一个容器来暂时存储下面的水龙头来不及处理的水。</p>\n<p><img src="/posts/images/node-streams/stream-c.png" alt="流与缓存"></p>\n<p>NodeJS 中流的基本原理也是这样的，stream 模块实现了这些能力。</p>\n<p>在 NodeJS 中有两种基本的流可以使用：</p>\n<ul>\n<li>可读流（Readable Streams）</li>\n<li>可写流（Writable Streams）</li>\n</ul>\n<p>同时还有两种读写混合的流：</p>\n<ul>\n<li>双工流（Duplex Streams）-- 可读可写的流</li>\n<li>转换流（Transform Streams）-- 可以转换数据的双工流</li>\n</ul>\n<h2 id="可读流-readable-stream" tabindex="-1"><a class="header-anchor" href="#可读流-readable-stream" aria-hidden="true">#</a> 可读流（Readable Stream）</h2>\n<p>可读流可以从一个地方读取数据，比如从文件中读取信息。读取的数据可以暂时存放在可读流中的<a href="https://nodejs.org/api/stream.html#stream_buffering" target="_blank" rel="noopener noreferrer">缓存（Buffer）<OutboundLink/></a>里，防止应用程序无法及时处理。</p>\n<p><img src="/posts/images/node-streams/readable-c.png" alt="可读流"></p>\n<p>常见的可读流有 <a href="https://nodejs.org/api/process.html#process_process_stdin" target="_blank" rel="noopener noreferrer"><code>process.stdin</code><OutboundLink/></a>、<a href="https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options" target="_blank" rel="noopener noreferrer"><code>fs.createReadStream</code><OutboundLink/></a> 以及 HTTP 服务中的 <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage" target="_blank" rel="noopener noreferrer"><code>IncomingMessage</code><OutboundLink/></a> 对象。</p>\n<h2 id="可写流-writable-stream" tabindex="-1"><a class="header-anchor" href="#可写流-writable-stream" aria-hidden="true">#</a> 可写流（Writable Stream）</h2>\n<p>可写流可以将数据写到一个地方，比如将数据写入文件中。为了防止因为写入目标处理速度太慢导致数据丢失，写入的数据可以暂存在可写流内部的缓存（Buffer）中。</p>\n<p><img src="/posts/images/node-streams/writable-c.png" alt="可写流"></p>\n<p>常用的可写流有 <a href="https://nodejs.org/api/process.html#process_process_stdout" target="_blank" rel="noopener noreferrer"><code>process.stdout</code><OutboundLink/></a>、<a href="https://nodejs.org/api/process.html#process_process_stderr" target="_blank" rel="noopener noreferrer"><code>process.stderr</code><OutboundLink/></a> 和 <a href="https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options" target="_blank" rel="noopener noreferrer"><code>fs.createWriteStream</code><OutboundLink/></a>.</p>\n<h2 id="双工流-duplex-streams" tabindex="-1"><a class="header-anchor" href="#双工流-duplex-streams" aria-hidden="true">#</a> 双工流（Duplex Streams）</h2>\n<p>双工流是可读流和可写流的混合体。连接到双工流之后，应用程序既可以从流中读取数据，也可以向流中写入数据。在双工流中，可读流和可写流有各自独立的缓存（Buffer）。</p>\n<p><img src="/posts/images/node-streams/duplex-c.png" alt="双工流"></p>\n<p>最常用的双工流就是 <a href="https://nodejs.org/api/net.html#net_class_net_socket" target="_blank" rel="noopener noreferrer"><code>net.Socket</code><OutboundLink/></a>。</p>\n<h2 id="转换流-transform-stream" tabindex="-1"><a class="header-anchor" href="#转换流-transform-stream" aria-hidden="true">#</a> 转换流（Transform Stream）</h2>\n<p>转换流是更加特殊的混合流，在转换流中，可读流是通过某种方式连接到可写流上的。</p>\n<p><img src="/posts/images/node-streams/transform-c.png" alt="转换流"></p>\n<p>最常见的转换流是有 <a href="https://nodejs.org/api/stream.html#stream_buffering" target="_blank" rel="noopener noreferrer"><code>Cipher</code><OutboundLink/></a> 创建的流。在这个流中，应用程序写入数据，然后再从流中读取加密后的数据。</p>\n<h2 id="管道-pipe" tabindex="-1"><a class="header-anchor" href="#管道-pipe" aria-hidden="true">#</a> 管道（Pipe）</h2>\n<p>通常流在连接到一起之后才能发挥更大的作用。我们通过管道来连接流。</p>\n<p>比如我们可以将一个可读流连接到一个可写流或者双工流上，仅仅使用可读流的 <code>pipe()</code> 方法即可。</p>\n<p>常见的管道场景就是复制文件。将 <code>fs.createReadStream()</code> 创建的流通过 <code>pipe()</code> 方法连接到 <code>fs.createWriteStream()</code> 创建的流上去。</p>\n<h3 id="使用流复制数据" tabindex="-1"><a class="header-anchor" href="#使用流复制数据" aria-hidden="true">#</a> 使用流复制数据</h3>\n<p>我们可以将流连接到多个其他流上。这在一些需要重复读取原始数据的场景中非常有用。因为可读流只能读取一次数据，因此我们可以通过 <code>pipe()</code> 方法将可读流连接到多个流上，这样这些被连接的流就可以直接消费数据，不需要创建多个可读流。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'fs\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> original <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">\'./original.txt\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> copy1 <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">\'./copy1.txt\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> copy2 <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">\'./copy2.txt\'</span><span class="token punctuation">)</span>\n\noriginal<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>copy1<span class="token punctuation">)</span>\noriginal<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>copy2<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><img src="/posts/images/node-streams/copy-file-c.png" alt="使用流复制数据"></p>\n<h2 id="高水位线控制-highwatermark" tabindex="-1"><a class="header-anchor" href="#高水位线控制-highwatermark" aria-hidden="true">#</a> 高水位线控制（highWaterMark）</h2>\n<p>在最开始的例子中，我们通过水箱蓄水的例子描述了流的缓存特性。因为上方的水流始终比下方的水流快，水箱中的水越来越多，终究会超过水箱的容积而溢出。</p>\n<p>因此我们需要一个高水位警戒线，当水箱中的水位高于这个警戒线的时候，就需要通知上方的水龙头暂时停止放水了。</p>\n<p><img src="/posts/images/node-streams/high-water-mark-c.png" alt="高水位线控制"></p>\n<p>在流中也是同样的原理，可读流和可写流内部都有缓存，这些缓存的最大可存储量是系统的可用内存量。NodeJS 流通过 <code>highWaterMark</code> 这个配置项来控制缓存中的水位线。</p>\n<p>举个例子，如下图，可读流连接到可写流之后，可写流通过 <code>highWaterMark</code> 来检测缓存中的水位是否过高，高于这条线之后，可写流会通知可读流暂停写入数据。</p>\n<p><img src="/posts/images/node-streams/read-write-high-water-mark-c.png" alt="高水位线控制"></p>\n<p>需要注意的是，<code>highWaterMark</code> 只是一个警示线，并不是一个硬性约束条件。也就是说，如果自定义的流没有正确处理这个警示线的话，可能会导致数据丢失。</p>\n<h2 id="流的应用" tabindex="-1"><a class="header-anchor" href="#流的应用" aria-hidden="true">#</a> 流的应用</h2>\n<p>我们来举个例子综合说明如何使用流。</p>\n<p>假设我们有一个裁减图片的应用程序。用户将图片的地址告诉应用程序，应用程序从网络上读取原始图片，裁减之后再返回给用户。那么我们可以借助于流来实现这个应用程序的功能，如下图。</p>\n<p><img src="/posts/images/node-streams/stream-usage-c.png" alt="裁减图片的应用"></p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-08-06",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/nodejs-streams.html",pathLocale:"/",permalink:"/posts/2021/08/06/nodejs-streams.html",slug:"nodejs-streams",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/nodejs-streams.md",filePathRelative:"posts/nodejs-streams.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/06/nodejs-streams.html.vue",componentFilePathRelative:"pages/posts/2021/08/06/nodejs-streams.html.vue",componentFileChunkName:"v-5e3eb789",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/08/06/nodejs-streams.html.js",dataFilePathRelative:"pages/posts/2021/08/06/nodejs-streams.html.js",dataFileChunkName:"v-5e3eb789",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/08/06/nodejs-streams.html",htmlFilePathRelative:"posts/2021/08/06/nodejs-streams.html"},{key:"v-228ea995",path:"/posts/2019/02/20/regexp-handbook.html",title:"正则表达式备查手册",lang:"zh-CN",frontmatter:{title:"正则表达式备查手册",description:"正则表达式高频知识点",keywords:["regular expression","正则表达式","regexp"],date:"2019-02-20T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"常用元字符",slug:"常用元字符",children:[]},{level:2,title:"常用限定符（重复）",slug:"常用限定符-重复",children:[]},{level:2,title:"常用反义码",slug:"常用反义码",children:[]},{level:2,title:"分支条件",slug:"分支条件",children:[]},{level:2,title:"分组（重复多个字符）",slug:"分组-重复多个字符",children:[]},{level:2,title:"后向引用",slug:"后向引用",children:[]},{level:2,title:"零宽断言",slug:"零宽断言",children:[]},{level:2,title:"负向零宽断言",slug:"负向零宽断言",children:[]},{level:2,title:"注释",slug:"注释",children:[]}],content:"\n## 常用元字符\n\n- `.` 匹配除换行符以外的任意字符\n- `\\w` 匹配字母或数字或下划线或汉字\n- `\\s` 匹配任意的空白符\n- `\\d` 匹配数字\n- `\\b` 匹配单词的开始或结束\n- `^` 匹配字符串的开始\n- `$` 匹配字符串的结束\n\n## 常用限定符（重复）\n\n- `*` 重复零次或更多次\n- `*?` 重复任意次，但尽可能少重复\n- `+` 重复一次或更多次\n- `+?` 重复 1 次或更多次，但尽可能少重复\n- `?` 重复零次或一次\n- `??` 重复 0 次或 1 次，但尽可能少重复\n- `{n}` 重复 n 次\n- `{n,}` 重复 n 次或更多次\n- `{n,}?` 重复 n 次以上，但尽可能少重复\n- `{n,m}` 重复 n 到 m 次\n- `{n,m}?` 重复 n 到 m 次，但尽可能少重复\n\n## 常用反义码\n\n- `\\W` 匹配任意不是字母，数字，下划线，汉字的字符\n- `\\S` 匹配任意不是空白符的字符\n- `\\D` 匹配任意非数字的字符\n- `\\B` 匹配不是单词开头或结束的位置\n- `[^x]` 匹配除了 x 以外的任意字符\n- `[^aeiou]` 匹配除了 aeiou 这几个字母以外的任意字符\n\n## 分支条件\n\n正则表达式中通过 `|` 来表示分支条件。\n\n> 例如，我们通过 `\\(?0\\d{2}[\\) -]?\\d{8}` 从文本中查找电话号码，我们可以成功查找出如 (010)88886666，或 022-22334455，或 02912345678 等格式的号码，也可以查找出 010)12345678 或 (022-87654321 等格式不正确的号码。为了解决这个问题，我们需要引入分支判断。修正后的正则表达式为 `\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}`。\n\n## 分组（重复多个字符）\n\n通过限定符可以重复单个字符，通过小括号指定的子表达式（也叫做分组）可以重复多个字符。\n\n> 比如，可以通过 `(\\d{1,3}\\.){3}\\d{1,3}` 完成 IP 地址匹配。当然，这个规则有些缺陷，像 300.999.888.666 这样不可能存在的 IP 也会被匹配到，因此需要修正表达式为：`^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$`。\n> 笔者发现一个有趣的问题，`((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)` 测试 111.111.111.999 这样的字符串可以通过，但是测试 111.111.999.999 却无法通过。此中原因是 `[01]?\\d\\d?` 只能匹配 99 不能匹配 999。这也就是为什么上面修正后的正则表达式要严格限制开头和结尾匹配的原因。\n\n## 后向引用\n\n分组捕获的内容（子表达式匹配的内容）有时候需要进一步处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左到右，以分组的左括号为标志，第一个出现的分组的组号为 1，第二个为 2，以此类推（注意，命名分组的组号要大于未命名分组的组号）。\n反向引用用于重复搜索前面某个分组匹配的文本。\n\n> 例如，`\\b(\\w+)\\b\\s+\\1\\b` 可以用来匹配重复的单词，像 go go, 或者 kitty kitty。\n\n也可以通过 `(?<Name>\\w+)` 或者 `(?'Name'\\w+)` 的方式为分组指定组名，前面的 Name 就是分组的名称。要反向引用这个分组捕获的内容，可以使用 `\\k<Name>` 来完成。\n\n> 上面的例子可以改写为： `\\b(?<Word>\\w+)\\b\\s+\\k<Word>\\b`。\n\n也可以不指定分组的组号，不捕获分组匹配的文本，语法形式为： `(?:exp)`。\n\n## 零宽断言\n\n断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。零宽断言用来指定一个位置，这个位置应该满足一定的条件（即断言）。\n\n- `(?=exp)` 断言自身出现的位置的后面能匹配表达式 exp。\n\n> 比如 `\\b\\w+(?=ing\\b)`，匹配以 ing 结尾的单词的前面部分(除了 ing 以外的部分)，如查找 I'm singing while you're dancing. 时，它会匹配 sing 和 danc。\n\n- `(?<=exp)` 断言自身出现的位置的前面能匹配表达式 exp。\n\n> 比如 `(?<=\\bre)\\w+\\b` 会匹配以 re 开头的单词的后半部分(除了 re 以外的部分)，例如在查找 reading a book 时，它匹配 ading。\n\n## 负向零宽断言\n\n负向零宽断言与零宽断言类似，也指定一个位置，这个位置满足断言条件（与零宽断言条件相反，即不能满足表达式）。\n\n- `(?!exp)` 断言此位置的后面不能匹配表达式 exp。\n\n> 例如：`\\d{3}(?!\\d)` 匹配三位数字，而且这三位数字的后面不能是数字；`\\b((?!abc)\\w)+\\b` 匹配不包含字符串 abc 的单词。\n\n- `(?<!exp)` 断言此位置的前面不能匹配表达式 exp。\n\n> 例如：`(?<![a-z])\\d{7}` 匹配前面不是小写字母的七位数字；`(?<=<(\\w+)>).*(?=<\\/\\1>)` 匹配不包含属性的简单 HTML 标签内里的内容。\n\n## 注释\n\n有时候正则表达式写的很复杂，可以通过 `(?#comment)` 添加一些注释，来增加可读性。\n\n> 比如，前面 IP 地址匹配的正则表达式添加如下注释： `2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)`。\n",contentRendered:'<h2 id="常用元字符" tabindex="-1"><a class="header-anchor" href="#常用元字符" aria-hidden="true">#</a> 常用元字符</h2>\n<ul>\n<li><code>.</code> 匹配除换行符以外的任意字符</li>\n<li><code>\\w</code> 匹配字母或数字或下划线或汉字</li>\n<li><code>\\s</code> 匹配任意的空白符</li>\n<li><code>\\d</code> 匹配数字</li>\n<li><code>\\b</code> 匹配单词的开始或结束</li>\n<li><code>^</code> 匹配字符串的开始</li>\n<li><code>$</code> 匹配字符串的结束</li>\n</ul>\n<h2 id="常用限定符-重复" tabindex="-1"><a class="header-anchor" href="#常用限定符-重复" aria-hidden="true">#</a> 常用限定符（重复）</h2>\n<ul>\n<li><code>*</code> 重复零次或更多次</li>\n<li><code>*?</code> 重复任意次，但尽可能少重复</li>\n<li><code>+</code> 重复一次或更多次</li>\n<li><code>+?</code> 重复 1 次或更多次，但尽可能少重复</li>\n<li><code>?</code> 重复零次或一次</li>\n<li><code>??</code> 重复 0 次或 1 次，但尽可能少重复</li>\n<li><code>{n}</code> 重复 n 次</li>\n<li><code>{n,}</code> 重复 n 次或更多次</li>\n<li><code>{n,}?</code> 重复 n 次以上，但尽可能少重复</li>\n<li><code>{n,m}</code> 重复 n 到 m 次</li>\n<li><code>{n,m}?</code> 重复 n 到 m 次，但尽可能少重复</li>\n</ul>\n<h2 id="常用反义码" tabindex="-1"><a class="header-anchor" href="#常用反义码" aria-hidden="true">#</a> 常用反义码</h2>\n<ul>\n<li><code>\\W</code> 匹配任意不是字母，数字，下划线，汉字的字符</li>\n<li><code>\\S</code> 匹配任意不是空白符的字符</li>\n<li><code>\\D</code> 匹配任意非数字的字符</li>\n<li><code>\\B</code> 匹配不是单词开头或结束的位置</li>\n<li><code>[^x]</code> 匹配除了 x 以外的任意字符</li>\n<li><code>[^aeiou]</code> 匹配除了 aeiou 这几个字母以外的任意字符</li>\n</ul>\n<h2 id="分支条件" tabindex="-1"><a class="header-anchor" href="#分支条件" aria-hidden="true">#</a> 分支条件</h2>\n<p>正则表达式中通过 <code>|</code> 来表示分支条件。</p>\n<blockquote>\n<p>例如，我们通过 <code>\\(?0\\d{2}[\\) -]?\\d{8}</code> 从文本中查找电话号码，我们可以成功查找出如 (010)88886666，或 022-22334455，或 02912345678 等格式的号码，也可以查找出 010)12345678 或 (022-87654321 等格式不正确的号码。为了解决这个问题，我们需要引入分支判断。修正后的正则表达式为 <code>\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}</code>。</p>\n</blockquote>\n<h2 id="分组-重复多个字符" tabindex="-1"><a class="header-anchor" href="#分组-重复多个字符" aria-hidden="true">#</a> 分组（重复多个字符）</h2>\n<p>通过限定符可以重复单个字符，通过小括号指定的子表达式（也叫做分组）可以重复多个字符。</p>\n<blockquote>\n<p>比如，可以通过 <code>(\\d{1,3}\\.){3}\\d{1,3}</code> 完成 IP 地址匹配。当然，这个规则有些缺陷，像 300.999.888.666 这样不可能存在的 IP 也会被匹配到，因此需要修正表达式为：<code>^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$</code>。\n笔者发现一个有趣的问题，<code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code> 测试 111.111.111.999 这样的字符串可以通过，但是测试 111.111.999.999 却无法通过。此中原因是 <code>[01]?\\d\\d?</code> 只能匹配 99 不能匹配 999。这也就是为什么上面修正后的正则表达式要严格限制开头和结尾匹配的原因。</p>\n</blockquote>\n<h2 id="后向引用" tabindex="-1"><a class="header-anchor" href="#后向引用" aria-hidden="true">#</a> 后向引用</h2>\n<p>分组捕获的内容（子表达式匹配的内容）有时候需要进一步处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左到右，以分组的左括号为标志，第一个出现的分组的组号为 1，第二个为 2，以此类推（注意，命名分组的组号要大于未命名分组的组号）。\n反向引用用于重复搜索前面某个分组匹配的文本。</p>\n<blockquote>\n<p>例如，<code>\\b(\\w+)\\b\\s+\\1\\b</code> 可以用来匹配重复的单词，像 go go, 或者 kitty kitty。</p>\n</blockquote>\n<p>也可以通过 <code>(?&lt;Name&gt;\\w+)</code> 或者 <code>(?\'Name\'\\w+)</code> 的方式为分组指定组名，前面的 Name 就是分组的名称。要反向引用这个分组捕获的内容，可以使用 <code>\\k&lt;Name&gt;</code> 来完成。</p>\n<blockquote>\n<p>上面的例子可以改写为： <code>\\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Word&gt;\\b</code>。</p>\n</blockquote>\n<p>也可以不指定分组的组号，不捕获分组匹配的文本，语法形式为： <code>(?:exp)</code>。</p>\n<h2 id="零宽断言" tabindex="-1"><a class="header-anchor" href="#零宽断言" aria-hidden="true">#</a> 零宽断言</h2>\n<p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。零宽断言用来指定一个位置，这个位置应该满足一定的条件（即断言）。</p>\n<ul>\n<li><code>(?=exp)</code> 断言自身出现的位置的后面能匹配表达式 exp。</li>\n</ul>\n<blockquote>\n<p>比如 <code>\\b\\w+(?=ing\\b)</code>，匹配以 ing 结尾的单词的前面部分(除了 ing 以外的部分)，如查找 I\'m singing while you\'re dancing. 时，它会匹配 sing 和 danc。</p>\n</blockquote>\n<ul>\n<li><code>(?&lt;=exp)</code> 断言自身出现的位置的前面能匹配表达式 exp。</li>\n</ul>\n<blockquote>\n<p>比如 <code>(?&lt;=\\bre)\\w+\\b</code> 会匹配以 re 开头的单词的后半部分(除了 re 以外的部分)，例如在查找 reading a book 时，它匹配 ading。</p>\n</blockquote>\n<h2 id="负向零宽断言" tabindex="-1"><a class="header-anchor" href="#负向零宽断言" aria-hidden="true">#</a> 负向零宽断言</h2>\n<p>负向零宽断言与零宽断言类似，也指定一个位置，这个位置满足断言条件（与零宽断言条件相反，即不能满足表达式）。</p>\n<ul>\n<li><code>(?!exp)</code> 断言此位置的后面不能匹配表达式 exp。</li>\n</ul>\n<blockquote>\n<p>例如：<code>\\d{3}(?!\\d)</code> 匹配三位数字，而且这三位数字的后面不能是数字；<code>\\b((?!abc)\\w)+\\b</code> 匹配不包含字符串 abc 的单词。</p>\n</blockquote>\n<ul>\n<li><code>(?&lt;!exp)</code> 断言此位置的前面不能匹配表达式 exp。</li>\n</ul>\n<blockquote>\n<p>例如：<code>(?&lt;![a-z])\\d{7}</code> 匹配前面不是小写字母的七位数字；<code>(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)</code> 匹配不包含属性的简单 HTML 标签内里的内容。</p>\n</blockquote>\n<h2 id="注释" tabindex="-1"><a class="header-anchor" href="#注释" aria-hidden="true">#</a> 注释</h2>\n<p>有时候正则表达式写的很复杂，可以通过 <code>(?#comment)</code> 添加一些注释，来增加可读性。</p>\n<blockquote>\n<p>比如，前面 IP 地址匹配的正则表达式添加如下注释： <code>2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)</code>。</p>\n</blockquote>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2019-02-20",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/regexp-handbook.html",pathLocale:"/",permalink:"/posts/2019/02/20/regexp-handbook.html",slug:"regexp-handbook",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/regexp-handbook.md",filePathRelative:"posts/regexp-handbook.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2019/02/20/regexp-handbook.html.vue",componentFilePathRelative:"pages/posts/2019/02/20/regexp-handbook.html.vue",componentFileChunkName:"v-228ea995",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2019/02/20/regexp-handbook.html.js",dataFilePathRelative:"pages/posts/2019/02/20/regexp-handbook.html.js",dataFileChunkName:"v-228ea995",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2019/02/20/regexp-handbook.html",htmlFilePathRelative:"posts/2019/02/20/regexp-handbook.html"},{key:"v-9d4f619e",path:"/posts/2019/06/10/same-origin-cors.html",title:"同源策略与跨域",lang:"zh-CN",frontmatter:{title:"同源策略与跨域",description:"浏览器的同源策略是什么？跨域的各种方法。",keywords:["same-origin policy","cross origin","cross site","同源策略","跨域"],date:"2019-06-10T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"什么是同源策略",slug:"什么是同源策略",children:[]},{level:2,title:"跨域访问",slug:"跨域访问",children:[{level:3,title:"修改源（origin）",slug:"修改源-origin",children:[]},{level:3,title:"JSONP",slug:"jsonp",children:[]},{level:3,title:"CORS",slug:"cors",children:[]}]},{level:2,title:"参考链接",slug:"参考链接",children:[]}],content:'\n## 什么是同源策略\n\n同源策略（Same-Origin Policy）并不是单单指某一种策略，而是浏览器的一种安全机制的统称，用来限制不同域名之间文档、脚本的互相访问。所谓同源，就是两个 URL 的协议头（protocol）、域名（host）与端口号（port）相同，否则就是不同源。比如 `http://store.company.com/dir2/other.html` 与 `http://store.company.com/dir/inner/another.html` 同源，与 `https://store.company.com/page.html` 和 `http://store.company.com:81/dir/page.html` 都不同源。\n尽管不同 API 的同源策略可能有些许不同，但是总体上都是为了防止用户在访问不可信网站时，阻止这些不可信网站访问可信网站的用户会话等数据。\n举个例子，用户浏览器可能同时打开了银行、淘宝、微博等网站，浏览器本地保存了用户在这些网站的会话信息，此时当用户访问一个不可信网站时，同源策略会阻止这个不可信网站读取浏览器本地保存的这些可信网站的数据，以减少攻击可能。\n\n在网络请求中，同源策略在发送数据和接收数据时表现有所不同。一般来说，一个源（one origin）可以给另一个源（another origin）发送数据，但是一个源不可以从另一个源读取数据。这样做是为了防止恶意网站读取可信网站的数据，但是同时这也阻止了两个可信网站之间的数据读取。即使在同源策略下，跨站（cross-site）发送数据也不是完全安全的，因为这可能导致跨站请求伪造（csrf）和点击劫持（clickjacking）。\n\n## 跨域访问\n\n同源策略一定程度上减少了恶意网站的攻击，但是也限制了不同源的可信站点之间的数据交流。以下介绍几种常见的跨域访问形式。\n\n### 修改源（origin）\n\n一个页面可以通过 `document.domain` 修改自身的源，但是只能修改为该页面的当前域名或者当前域名的父级域名。如果 `document.domain` 被修改成父级域名，那么浏览器在进行同源检测时会使用父级域名进行检测。比如，位于 `http://store.company.com/dir/other.html` 页面的脚本，通过\n\n```js\ndocument.domain = "company.com";\n```\n\n的方式修改了当前域名之后，就可以通过与页面 `http://company.com/dir/page.html` 之间的同源检测。\n\n> 这种做法有一个前提条件，就是父级域名的页面也通过相同的方式设置了相同的域名。因为通过 `document.domain` 修改源时，浏览器会将端口号设置为 null，因此如果单独将 other.html 的 `document.domain` 设置为 `company.com` 的话，此时页面的端口号为 null，而 page.html 的端口号为 80，依然无法通过同源检测。\n\n### JSONP\n\nJSONP 是常用方法跨域方法，最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。JSONP 的原理是网页通过添加一个 `<script>` 元素，向服务器请求 JSON 数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n比如，客户端通过如下代码请求 `company.com` 域下的服务，\n\n```js\nfunction loadCrossSiteData(src) {\n  var script = document.createElement("script");\n  script.setAttribute("type", "text/javascript");\n  script.src = src;\n  document.body.appendChild(script);\n}\n\nwindow.onload = function () {\n  loadCrossSiteData("http://company.com/item?callback=logDetail");\n};\n\nfunction logDetail(data) {\n  console.log("Item detail is: " + data);\n}\n```\n\n在服务端，返回如下代码。因为 `<script>` 标签请求的脚本，直接作为代码运行，因此只要页面中定义了 `logDetail` 函数，该函数就会被立即调用，打印相关数据。\n\n```js\nlogDetail({ name: "itemName" });\n```\n\n> JSONP 由于是通过 `<script>` 标签的方式实现跨域，因此只能完成 GET 方法的跨域，无法实现 POST 等方法的跨域。\n\n### CORS\n\nCORS 是跨域资源共享（Cross-origin resource sharing）的缩写，它允许浏览器向跨域服务发送 AJAX 请求，从而克服了同源限制。\n\n下图是 CORS 各个浏览器的支持情况。\n![IMAGE](/posts/images/same-origin-cors/cors-c.jpg)\n\nCORS 需要浏览器和服务器同时支持。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，再根据服务端响应的结果判断是否完成请求，请求期间用户不会有任何感觉。因此，实现 CORS 通信的关键是服务器，一般来说，只要服务器实现了 CORS 接口，就可以跨域通信。\n\n简单来说，当浏览器发现需要向跨域服务发送请求时，会先发一个预检请求（preflight）。该请求是一个 OPTIONS 请求，用来询问服务端是否可跨域，请求头中会携带 `Origin`、`Access-Control-Request-Method` 等字段。服务器收到预检请求以后，检查了 Origin、Access-Control-Request-Method 字段以后，确认允许跨源请求，就可以做出响应，响应中包含如下请求头，`Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`，`Access-Control-Allow-Origin` 表明允许哪些域跨域访问，如果为 `*` 号则表示允许任何域访问。预检请求通过后，浏览器就会向普通 AJAX 请求一样请求数据，但是会携带上 `Origin` 请求头，同时服务器的响应也会带上 `Access-Control-Allow-Origin`响应头。\n\n> CORS 相对于 JSONP 来说更加彻底，可以实现任何 HTTP 方法的跨域访问，是浏览器原生支持的跨域方法。但是比 JSONP 多一次请求，对服务器性能有轻微影响，同时对浏览器版本也有一定的要求。\n\n## 参考链接\n\n- [MDN：HTTP CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)\n- [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)。\n',contentRendered:'<h2 id="什么是同源策略" tabindex="-1"><a class="header-anchor" href="#什么是同源策略" aria-hidden="true">#</a> 什么是同源策略</h2>\n<p>同源策略（Same-Origin Policy）并不是单单指某一种策略，而是浏览器的一种安全机制的统称，用来限制不同域名之间文档、脚本的互相访问。所谓同源，就是两个 URL 的协议头（protocol）、域名（host）与端口号（port）相同，否则就是不同源。比如 <code>http://store.company.com/dir2/other.html</code> 与 <code>http://store.company.com/dir/inner/another.html</code> 同源，与 <code>https://store.company.com/page.html</code> 和 <code>http://store.company.com:81/dir/page.html</code> 都不同源。\n尽管不同 API 的同源策略可能有些许不同，但是总体上都是为了防止用户在访问不可信网站时，阻止这些不可信网站访问可信网站的用户会话等数据。\n举个例子，用户浏览器可能同时打开了银行、淘宝、微博等网站，浏览器本地保存了用户在这些网站的会话信息，此时当用户访问一个不可信网站时，同源策略会阻止这个不可信网站读取浏览器本地保存的这些可信网站的数据，以减少攻击可能。</p>\n<p>在网络请求中，同源策略在发送数据和接收数据时表现有所不同。一般来说，一个源（one origin）可以给另一个源（another origin）发送数据，但是一个源不可以从另一个源读取数据。这样做是为了防止恶意网站读取可信网站的数据，但是同时这也阻止了两个可信网站之间的数据读取。即使在同源策略下，跨站（cross-site）发送数据也不是完全安全的，因为这可能导致跨站请求伪造（csrf）和点击劫持（clickjacking）。</p>\n<h2 id="跨域访问" tabindex="-1"><a class="header-anchor" href="#跨域访问" aria-hidden="true">#</a> 跨域访问</h2>\n<p>同源策略一定程度上减少了恶意网站的攻击，但是也限制了不同源的可信站点之间的数据交流。以下介绍几种常见的跨域访问形式。</p>\n<h3 id="修改源-origin" tabindex="-1"><a class="header-anchor" href="#修改源-origin" aria-hidden="true">#</a> 修改源（origin）</h3>\n<p>一个页面可以通过 <code>document.domain</code> 修改自身的源，但是只能修改为该页面的当前域名或者当前域名的父级域名。如果 <code>document.domain</code> 被修改成父级域名，那么浏览器在进行同源检测时会使用父级域名进行检测。比如，位于 <code>http://store.company.com/dir/other.html</code> 页面的脚本，通过</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">"company.com"</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>的方式修改了当前域名之后，就可以通过与页面 <code>http://company.com/dir/page.html</code> 之间的同源检测。</p>\n<blockquote>\n<p>这种做法有一个前提条件，就是父级域名的页面也通过相同的方式设置了相同的域名。因为通过 <code>document.domain</code> 修改源时，浏览器会将端口号设置为 null，因此如果单独将 other.html 的 <code>document.domain</code> 设置为 <code>company.com</code> 的话，此时页面的端口号为 null，而 page.html 的端口号为 80，依然无法通过同源检测。</p>\n</blockquote>\n<h3 id="jsonp" tabindex="-1"><a class="header-anchor" href="#jsonp" aria-hidden="true">#</a> JSONP</h3>\n<p>JSONP 是常用方法跨域方法，最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。JSONP 的原理是网页通过添加一个 <code>&lt;script&gt;</code> 元素，向服务器请求 JSON 数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n比如，客户端通过如下代码请求 <code>company.com</code> 域下的服务，</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">loadCrossSiteData</span><span class="token punctuation">(</span><span class="token parameter">src</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> <span class="token string">"text/javascript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  script<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>\n  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nwindow<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">loadCrossSiteData</span><span class="token punctuation">(</span><span class="token string">"http://company.com/item?callback=logDetail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">logDetail</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Item detail is: "</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在服务端，返回如下代码。因为 <code>&lt;script&gt;</code> 标签请求的脚本，直接作为代码运行，因此只要页面中定义了 <code>logDetail</code> 函数，该函数就会被立即调用，打印相关数据。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">logDetail</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"itemName"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><blockquote>\n<p>JSONP 由于是通过 <code>&lt;script&gt;</code> 标签的方式实现跨域，因此只能完成 GET 方法的跨域，无法实现 POST 等方法的跨域。</p>\n</blockquote>\n<h3 id="cors" tabindex="-1"><a class="header-anchor" href="#cors" aria-hidden="true">#</a> CORS</h3>\n<p>CORS 是跨域资源共享（Cross-origin resource sharing）的缩写，它允许浏览器向跨域服务发送 AJAX 请求，从而克服了同源限制。</p>\n<p>下图是 CORS 各个浏览器的支持情况。\n<img src="/posts/images/same-origin-cors/cors-c.jpg" alt="IMAGE"></p>\n<p>CORS 需要浏览器和服务器同时支持。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，再根据服务端响应的结果判断是否完成请求，请求期间用户不会有任何感觉。因此，实现 CORS 通信的关键是服务器，一般来说，只要服务器实现了 CORS 接口，就可以跨域通信。</p>\n<p>简单来说，当浏览器发现需要向跨域服务发送请求时，会先发一个预检请求（preflight）。该请求是一个 OPTIONS 请求，用来询问服务端是否可跨域，请求头中会携带 <code>Origin</code>、<code>Access-Control-Request-Method</code> 等字段。服务器收到预检请求以后，检查了 Origin、Access-Control-Request-Method 字段以后，确认允许跨源请求，就可以做出响应，响应中包含如下请求头，<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>，<code>Access-Control-Allow-Origin</code> 表明允许哪些域跨域访问，如果为 <code>*</code> 号则表示允许任何域访问。预检请求通过后，浏览器就会向普通 AJAX 请求一样请求数据，但是会携带上 <code>Origin</code> 请求头，同时服务器的响应也会带上 <code>Access-Control-Allow-Origin</code>响应头。</p>\n<blockquote>\n<p>CORS 相对于 JSONP 来说更加彻底，可以实现任何 HTTP 方法的跨域访问，是浏览器原生支持的跨域方法。但是比 JSONP 多一次请求，对服务器性能有轻微影响，同时对浏览器版本也有一定的要求。</p>\n</blockquote>\n<h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>\n<ul>\n<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank" rel="noopener noreferrer">MDN：HTTP CORS<OutboundLink/></a></li>\n<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener noreferrer">跨域资源共享 CORS 详解<OutboundLink/></a>。</li>\n</ul>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2019-06-10",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/same-origin-cors.html",pathLocale:"/",permalink:"/posts/2019/06/10/same-origin-cors.html",slug:"same-origin-cors",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/same-origin-cors.md",filePathRelative:"posts/same-origin-cors.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2019/06/10/same-origin-cors.html.vue",componentFilePathRelative:"pages/posts/2019/06/10/same-origin-cors.html.vue",componentFileChunkName:"v-9d4f619e",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2019/06/10/same-origin-cors.html.js",dataFilePathRelative:"pages/posts/2019/06/10/same-origin-cors.html.js",dataFileChunkName:"v-9d4f619e",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2019/06/10/same-origin-cors.html",htmlFilePathRelative:"posts/2019/06/10/same-origin-cors.html"},{key:"v-09002744",path:"/posts/2021/12/09/shell-regexp.html",title:"快速学会 shell 中的正则表达式",lang:"zh-CN",frontmatter:{title:"快速学会 shell 中的正则表达式",description:"5 分钟快速掌握 shell 中的正则表达式",keywords:["regular expression","shell","regexp"],date:"2021-12-09T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"分类",slug:"分类",children:[]},{level:2,title:"组成部分",slug:"组成部分",children:[{level:3,title:"基本组成部分",slug:"基本组成部分",children:[]},{level:3,title:"POSIX 字符类",slug:"posix-字符类",children:[]},{level:3,title:"元字符",slug:"元字符",children:[]}]},{level:2,title:"常见命令中的使用",slug:"常见命令中的使用",children:[]}],content:"\n我经常会在命令行使用 `grep` 等命令处理一些文本查找的问题。在使用正则表达式的时候经常会碰到一些令人困惑的问题，比如同样的正则表达式在一个命令中可以用，在另一个命令中却不可以用。\n\n今天我们来好好整理下 shell 中的正则表达式，这样在使用的时候能够轻车熟路。\n\n## 分类\n\n[正则表达式](https://en.wikipedia.org/wiki/Regular_expression)最早在 1950 年代由美国数学家 Stephen Cole Kleene 提出，后来被 Unix 操作系统的文本处理工具广泛使用。\n\n经过多年的发展和实践，最终形成两大标准，一个是 POSIX 标准，另一个是 Perl 标准。后者本是为 Perl 语言实现的，由于其功能非常强大，被 Java、JavaScript 等语言广泛借鉴，从而被广泛使用。\n\n我们这里将正则表达式分为三类：\n\n* 基本正则表达式（Basic Regular Expression 简称 BRE），由 POSIX 标准定义。\n* 扩展正则表达式（Extended Regular Expression 简称 ERE），也由 POSIX 标准定义。\n* Perl 的正则表达式（Perl Regular Expression 简称 PRE），由 Perl 语言定义。\n\n## 组成部分\n\n### 基本组成部分\n下表展示了正则表达式的基本组成部分。\n\n|正则表达式|描述|示例|Basic RegEx|Extended RegEx|Perl regEx|\n|:--|:--|:--|:--|:--|:--|\n|`\\`|转义符，将特殊字符进行转义，忽略其特殊意义|a\\.b匹配a.b，但不能匹配ajb，.被转义为特殊意义|`\\`|`\\`|`\\`|\n|^|匹配行首|^tux匹配以tux开头的行|^|^|^|\n|$|匹配行尾|tux$匹配以tux结尾的行|$|$|$|\n|.|匹配除换行符\\n之外的任意单个字符|ab.匹配abc或bad，不可匹配abcd或abde，只能匹配单字符|.|.|.|\n|[]|匹配包含在[字符]之中的任意一个字符|coo[kl]可以匹配cook或cool|[]|[]|[]|\n|[^]|匹配[^字符]之外的任意一个字符|123[^45]不可以匹配1234或1235，1236、1237都可以|[^]|[^]|[^]|\n|[-]|匹配[]中指定范围内的任意一个字符，要写成递增|[0-9]可以匹配1、2或3等其中任意一个数字|[-]|[-]|[-]|\n|?|匹配之前的项1次或者0次|colou?r可以匹配color或者colour，不能匹配colouur|不支持|?|?|\n|+|匹配之前的项1次或者多次|sa-6+匹配sa-6、sa-666，不能匹配sa-|不支持|+|+|\n|*|匹配之前的项0次或者多次|co*l匹配cl、col、cool、coool等|*|*|*|\n|()|匹配表达式，创建一个用于匹配的子串|ma(tri)?匹配max或maxtrix|不支持|()|()|\n|{n}|匹配之前的项n次，n是可以为0的正整数|[0-9]{3}匹配任意一个三位数，可以扩展为[0-9][0-9][0-9]|不支持|{n}|{n}|\n|{n,}|之前的项至少需要匹配n次|[0-9]{2,}匹配任意一个两位数或更多位数|不支持|{n,}|{n,}|\n|{n,m}|指定之前的项至少匹配n次，最多匹配m次，n<=m|[0-9]{2,5}匹配从两位数到五位数之间的任意一个数字|不支持|{n,m}|{n,m}|\n|&#124;|交替匹配&#124;两边的任意一项|ab(c&#124;d)匹配abc或abd|不支持|&#124;|&#124;|\n\n### POSIX 字符类\n\nPOSIX字符类是一个形如`[:...:]`的特殊元序列（meta sequence），他可以用于匹配特定的字符范围。\n\n|正则表达式|描述|示例|Basic RegEx|Extended RegEx|Perl RegEx|\n|:--|:--|:--|:--|:--|:--|\n|[:alnum:]|匹配任意一个字母或数字字符|[[:alnum:]]+|[:alnum:]|[:alnum:]|[:alnum:]|\n|[:alpha:]|匹配任意一个字母字符（包括大小写字母）|[[:alpha:]]{4}|[:alpha:]|[:alpha:]|[:alpha:]|\n|[:blank:]|空格与制表符（横向和纵向）|[[:blank:]]*|[:blank:]|[:blank:]|[:blank:]|\n|[:digit:]|匹配任意一个数字字符|[[:digit:]]?|[:digit:]|[:digit:]|[:digit:]|\n|[:lower:]|匹配小写字母|[[:lower:]]{5,}|[:lower:]|[:lower:]|[:lower:]|\n|[:upper:]|匹配大写字母|([[:upper:]]+)?|[:upper:]|[:upper:]|[:upper:]|\n|[:punct:]|匹配标点符号|[[:punct:]]|[:punct:]|[:punct:]|[:punct:]|\n|[:space:]|匹配一个包括换行符、回车等在内的所有空白符|[[:space:]]+|[:space:]|[:space:]|[:space:]|\n|[:graph:]|匹配任何一个可以看得见的且可以打印的字符|[[:graph:]]|[:graph:]|[:graph:]|[:graph:]|\n|[:xdigit:]|任何一个十六进制数（即：0-9，a-f，A-F）|[[:xdigit:]]+|[:xdigit:]|[:xdigit:]|[:xdigit:]|\n|[:cntrl:]|任何一个控制字符（ASCII字符集中的前32个字符)|[[:cntrl:]]|[:cntrl:]|[:cntrl:]|[:cntrl:]|\n|[:print:]|任何一个可以打印的字符|[[:print:]]|[:print:]|[:print:]|[:print:]|\n\n### 元字符\n\n元字符（meta character）是一种 Perl 风格的正则表达式，只有一部分文本处理工具支持它，并不是所有的文本处理工具都支持。\n\n|正则表达式|描述|示例|Basic RegEx|Extended RegEx|Perl RegEx|\n|:--|:--|:--|:--|:--|:--|\n|\\b|单词边界|\\bcool\\b 匹配cool，不匹配coolant|\\b|\\b|\\b|\n|\\B|非单词边界|cool\\B 匹配coolant，不匹配cool|\\B|\\B|\\B|\n|\\d|单个数字字符|b\\db 匹配b2b，不匹配bcb|不支持|不支持|\\d|\n|\\D|单个非数字字符|b\\Db 匹配bcb，不匹配b2b|不支持|不支持|\\D|\n|\\w|单个单词字符（字母、数字与_）|\\w 匹配1或a，不匹配&|\\w|\\w|\\w|\n|\\W|单个非单词字符|\\W 匹配&，不匹配1或a|\\W|\\W|\\W|\n|\\n|换行符|\\n 匹配一个新行|不支持|不支持|\\n|\n|\\s|单个空白字符|x\\sx 匹配x x，不匹配xx|不支持|不支持|\\s|\n|\\S|单个非空白字符|x\\S\\x 匹配xkx，不匹配xx|不支持|不支持|\\S|\n|\\r|回车|\\r 匹配回车|不支持|不支持|\\r|\n|\\t|横向制表符|\\t 匹配一个横向制表符|不支持|不支持|\\t|\n|\\v|垂直制表符|\\v 匹配一个垂直制表符|不支持|不支持|\\v|\n|\\f|换页符|\\f 匹配一个换页符|不支持|不支持|\\f|\n\n## 常见命令中的使用\n\n|命令|Basic RegEx|Extended RegEx|Perl RegEx|\n|:--|:--|:--|:--|\n|grep|支持|需加 `-E` 参数|需加 `-P` 参数|\n|egrep|支持|支持|需加 `-P` 参数|\n|sed|支持|需加 `-r` 参数|不支持|\n|awk|支持|支持|不支持|\n",contentRendered:'<p>我经常会在命令行使用 <code>grep</code> 等命令处理一些文本查找的问题。在使用正则表达式的时候经常会碰到一些令人困惑的问题，比如同样的正则表达式在一个命令中可以用，在另一个命令中却不可以用。</p>\n<p>今天我们来好好整理下 shell 中的正则表达式，这样在使用的时候能够轻车熟路。</p>\n<h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h2>\n<p><a href="https://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="noopener noreferrer">正则表达式<OutboundLink/></a>最早在 1950 年代由美国数学家 Stephen Cole Kleene 提出，后来被 Unix 操作系统的文本处理工具广泛使用。</p>\n<p>经过多年的发展和实践，最终形成两大标准，一个是 POSIX 标准，另一个是 Perl 标准。后者本是为 Perl 语言实现的，由于其功能非常强大，被 Java、JavaScript 等语言广泛借鉴，从而被广泛使用。</p>\n<p>我们这里将正则表达式分为三类：</p>\n<ul>\n<li>基本正则表达式（Basic Regular Expression 简称 BRE），由 POSIX 标准定义。</li>\n<li>扩展正则表达式（Extended Regular Expression 简称 ERE），也由 POSIX 标准定义。</li>\n<li>Perl 的正则表达式（Perl Regular Expression 简称 PRE），由 Perl 语言定义。</li>\n</ul>\n<h2 id="组成部分" tabindex="-1"><a class="header-anchor" href="#组成部分" aria-hidden="true">#</a> 组成部分</h2>\n<h3 id="基本组成部分" tabindex="-1"><a class="header-anchor" href="#基本组成部分" aria-hidden="true">#</a> 基本组成部分</h3>\n<p>下表展示了正则表达式的基本组成部分。</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">正则表达式</th>\n<th style="text-align:left">描述</th>\n<th style="text-align:left">示例</th>\n<th style="text-align:left">Basic RegEx</th>\n<th style="text-align:left">Extended RegEx</th>\n<th style="text-align:left">Perl regEx</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left"><code>\\</code></td>\n<td style="text-align:left">转义符，将特殊字符进行转义，忽略其特殊意义</td>\n<td style="text-align:left">a.b匹配a.b，但不能匹配ajb，.被转义为特殊意义</td>\n<td style="text-align:left"><code>\\</code></td>\n<td style="text-align:left"><code>\\</code></td>\n<td style="text-align:left"><code>\\</code></td>\n</tr>\n<tr>\n<td style="text-align:left">^</td>\n<td style="text-align:left">匹配行首</td>\n<td style="text-align:left">^tux匹配以tux开头的行</td>\n<td style="text-align:left">^</td>\n<td style="text-align:left">^</td>\n<td style="text-align:left">^</td>\n</tr>\n<tr>\n<td style="text-align:left">$</td>\n<td style="text-align:left">匹配行尾</td>\n<td style="text-align:left">tux$匹配以tux结尾的行</td>\n<td style="text-align:left">$</td>\n<td style="text-align:left">$</td>\n<td style="text-align:left">$</td>\n</tr>\n<tr>\n<td style="text-align:left">.</td>\n<td style="text-align:left">匹配除换行符\\n之外的任意单个字符</td>\n<td style="text-align:left">ab.匹配abc或bad，不可匹配abcd或abde，只能匹配单字符</td>\n<td style="text-align:left">.</td>\n<td style="text-align:left">.</td>\n<td style="text-align:left">.</td>\n</tr>\n<tr>\n<td style="text-align:left">[]</td>\n<td style="text-align:left">匹配包含在[字符]之中的任意一个字符</td>\n<td style="text-align:left">coo[kl]可以匹配cook或cool</td>\n<td style="text-align:left">[]</td>\n<td style="text-align:left">[]</td>\n<td style="text-align:left">[]</td>\n</tr>\n<tr>\n<td style="text-align:left">[^]</td>\n<td style="text-align:left">匹配[^字符]之外的任意一个字符</td>\n<td style="text-align:left">123[^45]不可以匹配1234或1235，1236、1237都可以</td>\n<td style="text-align:left">[^]</td>\n<td style="text-align:left">[^]</td>\n<td style="text-align:left">[^]</td>\n</tr>\n<tr>\n<td style="text-align:left">[-]</td>\n<td style="text-align:left">匹配[]中指定范围内的任意一个字符，要写成递增</td>\n<td style="text-align:left">[0-9]可以匹配1、2或3等其中任意一个数字</td>\n<td style="text-align:left">[-]</td>\n<td style="text-align:left">[-]</td>\n<td style="text-align:left">[-]</td>\n</tr>\n<tr>\n<td style="text-align:left">?</td>\n<td style="text-align:left">匹配之前的项1次或者0次</td>\n<td style="text-align:left">colou?r可以匹配color或者colour，不能匹配colouur</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">?</td>\n<td style="text-align:left">?</td>\n</tr>\n<tr>\n<td style="text-align:left">+</td>\n<td style="text-align:left">匹配之前的项1次或者多次</td>\n<td style="text-align:left">sa-6+匹配sa-6、sa-666，不能匹配sa-</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">+</td>\n<td style="text-align:left">+</td>\n</tr>\n<tr>\n<td style="text-align:left">*</td>\n<td style="text-align:left">匹配之前的项0次或者多次</td>\n<td style="text-align:left">co*l匹配cl、col、cool、coool等</td>\n<td style="text-align:left">*</td>\n<td style="text-align:left">*</td>\n<td style="text-align:left">*</td>\n</tr>\n<tr>\n<td style="text-align:left">()</td>\n<td style="text-align:left">匹配表达式，创建一个用于匹配的子串</td>\n<td style="text-align:left">ma(tri)?匹配max或maxtrix</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">()</td>\n<td style="text-align:left">()</td>\n</tr>\n<tr>\n<td style="text-align:left">{n}</td>\n<td style="text-align:left">匹配之前的项n次，n是可以为0的正整数</td>\n<td style="text-align:left">[0-9]{3}匹配任意一个三位数，可以扩展为[0-9][0-9][0-9]</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">{n}</td>\n<td style="text-align:left">{n}</td>\n</tr>\n<tr>\n<td style="text-align:left">{n,}</td>\n<td style="text-align:left">之前的项至少需要匹配n次</td>\n<td style="text-align:left">[0-9]{2,}匹配任意一个两位数或更多位数</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">{n,}</td>\n<td style="text-align:left">{n,}</td>\n</tr>\n<tr>\n<td style="text-align:left">{n,m}</td>\n<td style="text-align:left">指定之前的项至少匹配n次，最多匹配m次，n&lt;=m</td>\n<td style="text-align:left">[0-9]{2,5}匹配从两位数到五位数之间的任意一个数字</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">{n,m}</td>\n<td style="text-align:left">{n,m}</td>\n</tr>\n<tr>\n<td style="text-align:left">|</td>\n<td style="text-align:left">交替匹配|两边的任意一项</td>\n<td style="text-align:left">ab(c|d)匹配abc或abd</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">|</td>\n<td style="text-align:left">|</td>\n</tr>\n</tbody>\n</table>\n<h3 id="posix-字符类" tabindex="-1"><a class="header-anchor" href="#posix-字符类" aria-hidden="true">#</a> POSIX 字符类</h3>\n<p>POSIX字符类是一个形如<code>[:...:]</code>的特殊元序列（meta sequence），他可以用于匹配特定的字符范围。</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">正则表达式</th>\n<th style="text-align:left">描述</th>\n<th style="text-align:left">示例</th>\n<th style="text-align:left">Basic RegEx</th>\n<th style="text-align:left">Extended RegEx</th>\n<th style="text-align:left">Perl RegEx</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">[:alnum:]</td>\n<td style="text-align:left">匹配任意一个字母或数字字符</td>\n<td style="text-align:left">[[:alnum:]]+</td>\n<td style="text-align:left">[:alnum:]</td>\n<td style="text-align:left">[:alnum:]</td>\n<td style="text-align:left">[:alnum:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:alpha:]</td>\n<td style="text-align:left">匹配任意一个字母字符（包括大小写字母）</td>\n<td style="text-align:left">[[:alpha:]]{4}</td>\n<td style="text-align:left">[:alpha:]</td>\n<td style="text-align:left">[:alpha:]</td>\n<td style="text-align:left">[:alpha:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:blank:]</td>\n<td style="text-align:left">空格与制表符（横向和纵向）</td>\n<td style="text-align:left">[[:blank:]]*</td>\n<td style="text-align:left">[:blank:]</td>\n<td style="text-align:left">[:blank:]</td>\n<td style="text-align:left">[:blank:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:digit:]</td>\n<td style="text-align:left">匹配任意一个数字字符</td>\n<td style="text-align:left">[[:digit:]]?</td>\n<td style="text-align:left">[:digit:]</td>\n<td style="text-align:left">[:digit:]</td>\n<td style="text-align:left">[:digit:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:lower:]</td>\n<td style="text-align:left">匹配小写字母</td>\n<td style="text-align:left">[[:lower:]]{5,}</td>\n<td style="text-align:left">[:lower:]</td>\n<td style="text-align:left">[:lower:]</td>\n<td style="text-align:left">[:lower:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:upper:]</td>\n<td style="text-align:left">匹配大写字母</td>\n<td style="text-align:left">([[:upper:]]+)?</td>\n<td style="text-align:left">[:upper:]</td>\n<td style="text-align:left">[:upper:]</td>\n<td style="text-align:left">[:upper:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:punct:]</td>\n<td style="text-align:left">匹配标点符号</td>\n<td style="text-align:left">[[:punct:]]</td>\n<td style="text-align:left">[:punct:]</td>\n<td style="text-align:left">[:punct:]</td>\n<td style="text-align:left">[:punct:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:space:]</td>\n<td style="text-align:left">匹配一个包括换行符、回车等在内的所有空白符</td>\n<td style="text-align:left">[[:space:]]+</td>\n<td style="text-align:left">[:space:]</td>\n<td style="text-align:left">[:space:]</td>\n<td style="text-align:left">[:space:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:graph:]</td>\n<td style="text-align:left">匹配任何一个可以看得见的且可以打印的字符</td>\n<td style="text-align:left">[[:graph:]]</td>\n<td style="text-align:left">[:graph:]</td>\n<td style="text-align:left">[:graph:]</td>\n<td style="text-align:left">[:graph:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:xdigit:]</td>\n<td style="text-align:left">任何一个十六进制数（即：0-9，a-f，A-F）</td>\n<td style="text-align:left">[[:xdigit:]]+</td>\n<td style="text-align:left">[:xdigit:]</td>\n<td style="text-align:left">[:xdigit:]</td>\n<td style="text-align:left">[:xdigit:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:cntrl:]</td>\n<td style="text-align:left">任何一个控制字符（ASCII字符集中的前32个字符)</td>\n<td style="text-align:left">[[:cntrl:]]</td>\n<td style="text-align:left">[:cntrl:]</td>\n<td style="text-align:left">[:cntrl:]</td>\n<td style="text-align:left">[:cntrl:]</td>\n</tr>\n<tr>\n<td style="text-align:left">[:print:]</td>\n<td style="text-align:left">任何一个可以打印的字符</td>\n<td style="text-align:left">[[:print:]]</td>\n<td style="text-align:left">[:print:]</td>\n<td style="text-align:left">[:print:]</td>\n<td style="text-align:left">[:print:]</td>\n</tr>\n</tbody>\n</table>\n<h3 id="元字符" tabindex="-1"><a class="header-anchor" href="#元字符" aria-hidden="true">#</a> 元字符</h3>\n<p>元字符（meta character）是一种 Perl 风格的正则表达式，只有一部分文本处理工具支持它，并不是所有的文本处理工具都支持。</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">正则表达式</th>\n<th style="text-align:left">描述</th>\n<th style="text-align:left">示例</th>\n<th style="text-align:left">Basic RegEx</th>\n<th style="text-align:left">Extended RegEx</th>\n<th style="text-align:left">Perl RegEx</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">\\b</td>\n<td style="text-align:left">单词边界</td>\n<td style="text-align:left">\\bcool\\b 匹配cool，不匹配coolant</td>\n<td style="text-align:left">\\b</td>\n<td style="text-align:left">\\b</td>\n<td style="text-align:left">\\b</td>\n</tr>\n<tr>\n<td style="text-align:left">\\B</td>\n<td style="text-align:left">非单词边界</td>\n<td style="text-align:left">cool\\B 匹配coolant，不匹配cool</td>\n<td style="text-align:left">\\B</td>\n<td style="text-align:left">\\B</td>\n<td style="text-align:left">\\B</td>\n</tr>\n<tr>\n<td style="text-align:left">\\d</td>\n<td style="text-align:left">单个数字字符</td>\n<td style="text-align:left">b\\db 匹配b2b，不匹配bcb</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">\\d</td>\n</tr>\n<tr>\n<td style="text-align:left">\\D</td>\n<td style="text-align:left">单个非数字字符</td>\n<td style="text-align:left">b\\Db 匹配bcb，不匹配b2b</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">\\D</td>\n</tr>\n<tr>\n<td style="text-align:left">\\w</td>\n<td style="text-align:left">单个单词字符（字母、数字与_）</td>\n<td style="text-align:left">\\w 匹配1或a，不匹配&amp;</td>\n<td style="text-align:left">\\w</td>\n<td style="text-align:left">\\w</td>\n<td style="text-align:left">\\w</td>\n</tr>\n<tr>\n<td style="text-align:left">\\W</td>\n<td style="text-align:left">单个非单词字符</td>\n<td style="text-align:left">\\W 匹配&amp;，不匹配1或a</td>\n<td style="text-align:left">\\W</td>\n<td style="text-align:left">\\W</td>\n<td style="text-align:left">\\W</td>\n</tr>\n<tr>\n<td style="text-align:left">\\n</td>\n<td style="text-align:left">换行符</td>\n<td style="text-align:left">\\n 匹配一个新行</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">\\n</td>\n</tr>\n<tr>\n<td style="text-align:left">\\s</td>\n<td style="text-align:left">单个空白字符</td>\n<td style="text-align:left">x\\sx 匹配x x，不匹配xx</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">\\s</td>\n</tr>\n<tr>\n<td style="text-align:left">\\S</td>\n<td style="text-align:left">单个非空白字符</td>\n<td style="text-align:left">x\\S\\x 匹配xkx，不匹配xx</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">\\S</td>\n</tr>\n<tr>\n<td style="text-align:left">\\r</td>\n<td style="text-align:left">回车</td>\n<td style="text-align:left">\\r 匹配回车</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">\\r</td>\n</tr>\n<tr>\n<td style="text-align:left">\\t</td>\n<td style="text-align:left">横向制表符</td>\n<td style="text-align:left">\\t 匹配一个横向制表符</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">\\t</td>\n</tr>\n<tr>\n<td style="text-align:left">\\v</td>\n<td style="text-align:left">垂直制表符</td>\n<td style="text-align:left">\\v 匹配一个垂直制表符</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">\\v</td>\n</tr>\n<tr>\n<td style="text-align:left">\\f</td>\n<td style="text-align:left">换页符</td>\n<td style="text-align:left">\\f 匹配一个换页符</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">不支持</td>\n<td style="text-align:left">\\f</td>\n</tr>\n</tbody>\n</table>\n<h2 id="常见命令中的使用" tabindex="-1"><a class="header-anchor" href="#常见命令中的使用" aria-hidden="true">#</a> 常见命令中的使用</h2>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">命令</th>\n<th style="text-align:left">Basic RegEx</th>\n<th style="text-align:left">Extended RegEx</th>\n<th style="text-align:left">Perl RegEx</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">grep</td>\n<td style="text-align:left">支持</td>\n<td style="text-align:left">需加 <code>-E</code> 参数</td>\n<td style="text-align:left">需加 <code>-P</code> 参数</td>\n</tr>\n<tr>\n<td style="text-align:left">egrep</td>\n<td style="text-align:left">支持</td>\n<td style="text-align:left">支持</td>\n<td style="text-align:left">需加 <code>-P</code> 参数</td>\n</tr>\n<tr>\n<td style="text-align:left">sed</td>\n<td style="text-align:left">支持</td>\n<td style="text-align:left">需加 <code>-r</code> 参数</td>\n<td style="text-align:left">不支持</td>\n</tr>\n<tr>\n<td style="text-align:left">awk</td>\n<td style="text-align:left">支持</td>\n<td style="text-align:left">支持</td>\n<td style="text-align:left">不支持</td>\n</tr>\n</tbody>\n</table>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-12-09",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/shell-regexp.html",pathLocale:"/",permalink:"/posts/2021/12/09/shell-regexp.html",slug:"shell-regexp",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/shell-regexp.md",filePathRelative:"posts/shell-regexp.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/12/09/shell-regexp.html.vue",componentFilePathRelative:"pages/posts/2021/12/09/shell-regexp.html.vue",componentFileChunkName:"v-09002744",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/12/09/shell-regexp.html.js",dataFilePathRelative:"pages/posts/2021/12/09/shell-regexp.html.js",dataFileChunkName:"v-09002744",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/12/09/shell-regexp.html",htmlFilePathRelative:"posts/2021/12/09/shell-regexp.html"},{key:"v-15e0d1af",path:"/posts/2021/06/24/solid.html",title:"SOLID 原则",lang:"zh-CN",frontmatter:{title:"SOLID 原则",description:"软件设计原则，solid 原则",keywords:["solid"],date:"2021-06-24T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"单一职责原则（Single Responsibility Principle）",slug:"单一职责原则-single-responsibility-principle",children:[]},{level:2,title:"开闭原则（Open/Closed Principle）",slug:"开闭原则-open-closed-principle",children:[]},{level:2,title:"里氏替换原则（Liskov Substitution Principle）",slug:"里氏替换原则-liskov-substitution-principle",children:[]},{level:2,title:"接口隔离原则（Interface Segregation Principle）",slug:"接口隔离原则-interface-segregation-principle",children:[]},{level:2,title:"依赖倒置原则（Dependency Inversion Principle）",slug:"依赖倒置原则-dependency-inversion-principle",children:[]},{level:2,title:"小结",slug:"小结",children:[]},{level:2,title:"参考文献",slug:"参考文献",children:[]}],content:'\nSOLID 原则是五个面向对象程序设计基本原则的首字母简写，应用 SOLID 原则可以帮助我们开发出更容易维护、更灵活的软件。从而，在软件规模逐渐变大的时候，降低软件的复杂度，节省开发维护成本。\n\nSOLID 原则由如下五个原则组成：\n\n- 单一职责原则（Single Responsibility）\n- 开闭原则（Open/Closed 原则）\n- 里氏替换原则（Liskov Substitution）\n- 接口隔离原则（Interface Segregation）\n- 依赖倒置原则（Dependency Inversion）\n\n看名字有些原则可能不太好理解，下面我们通过一些代码示例来逐一说明。\n\n## 单一职责原则（Single Responsibility Principle）\n\n通过名字就可以知道，这个原则的含义是一个类应该只有一种职责。换句话说，我们只能有一个原因来改变这个类。\n\n应用了单一职责的类，有如下几个优点：\n\n- 易测试。只有单一职责的类需要的测试 case 非常少，非常容易测试。\n- 低耦合。一个类的功能越少，需要的外部依赖越少。\n- 易管理。功能单一的类比功能复杂的类更容易进行组织。\n\n举个例子，我们有一个 Book 类：\n\n```typescript\nclass Book {\n  private name: string;\n  private author: string;\n  private text: string;\n}\n```\n\n在这个类中，我们保存了书名、作者和书的文本三个字段。\n\n现在我们添加一些操作文本的函数。\n\n```typescript\nclass Book {\n  private name: string;\n  private author: string;\n  private text: string;\n\n  replaceWordInText(word: string): string {\n    return text.replaceAll(word, text);\n  }\n\n  isWordInText(word: string): boolean {\n    return text.indexOf(word) !== -1;\n  }\n}\n```\n\n现在假如说我们要把书的内容输出到控制台，我们可以给 Book 类加一个 print 方法：\n\n```typescript\n    // ....\n    printTextToConsole() {\n        // 输出内容函数实现\n    }\n```\n\n这个时候，新添加的方法就破坏了单一职责原则。\n\n我们应该再定义一个类，BookPrinter 来专门输出书的内容：\n\n```typescript\nclass BookPrinter {\n  printTextToConsole(text: string) {\n    //输出到控制台\n  }\n\n  printTextToAnotherMedium(text: string) {\n    // 输出到其他媒体类型\n  }\n}\n```\n\n通过 BookPrinter 类，我们不断实现了输出书的内容到控制台的功能，我们还可以支持将书的内容输出到其他媒体类型。不管是输出到邮件、日志还是什么其他地方，我们都有一个单独的类来处理这个问题。\n\n## 开闭原则（Open/Closed Principle）\n\n开闭原则可以描述为”对扩展开放，对修改关闭“。也就是说，一个类只应该对扩展开放，对修改应该是关闭的。\n\n我们通过一个例子来说明。假设我们有一个生产电脑的类：\n\n```typescript\nclass MacOSComputer {}\n\nclass WindowsComputer {}\n\nclass ComputerFactory {\n  computerTypes = ["macos", "windows"];\n\n  createComputer(type) {\n    switch (type) {\n      case "macos":\n        return new MacOSComputer();\n      case "windows":\n        return new WindowsComputer();\n    }\n  }\n}\n```\n\n现在，假如我们需要创建一个 linux 系统的电脑，我们应该怎么办呢？最直接的办法是修改 ComputerFactory 这个类，来支持新电脑的创建。但是这么做我们可能会影响到其他两种类型电脑的创建。结合开闭原则，我们可以做一些改造。\n\n```typescript\nabstract class ComputerFactory {\n  createComputer() {}\n}\n\nclass MacOSFactory extends ComputerFactory {\n  createComputer() {\n    return new MacOSComputer();\n  }\n}\n\nclass WindowsFactory extends ComputerFactory {\n  createComputer() {\n    return new WindowsComputer();\n  }\n}\n```\n\n这个时候，如果我们新增一个 Linux 类型的电脑，就非常的方便。\n\n```typescript\nclass LinuxComputer {}\n\nclass LinuxFactory extends ComputerFactory {\n  createComputer() {\n    return new LinuxComputer();\n  }\n}\n```\n\n## 里氏替换原则（Liskov Substitution Principle）\n\n里氏替换原则则简单的说，就是如果类 A 是类 B 的子类，那么我们可以在系统内将 B 替换成 A，且不改变软件行为。\n\n我们还是通过例子来说明。\n\n```typescript\ninterface Car {\n  turnOnEngine(): void;\n  accelerate(): void;\n}\n```\n\n我们定义了一个 Car 接口，提供了一些函数需要实现类来实现。\n\n```typescript\nclass MotorCar implements Car {\n  private engine: Engine;\n\n  turnOnEngine() {\n    this.engine.on();\n  }\n\n  accelerate() {\n    this.engine.powerOn(1000);\n  }\n}\n```\n\n假如现在需要实现一个电动车：\n\n```typescript\nclass ElectricCar implements Car {\n  turnOnEngine() {\n    throw new Error("No engine");\n  }\n\n  accelerate() {\n    //\n  }\n}\n```\n\n这时候，如果我们将新实现的电动车放到系统中的话，就会改变系统的行为，导致出错。\n\n我们需要重新定义一个没有引擎的 Car 接口：\n\n```typescript\ninterface Car {\n  accelerate(): void;\n}\n```\n\n## 接口隔离原则（Interface Segregation Principle）\n\n接口隔离原则要求我们将大的接口拆分成小的接口，这样可以保证实现类能聚焦在它需要关心的接口上面。\n\n我们以动物饲养员为例。\n\n```typescript\ninterface BearKeeper {\n  washTheBear(): void;\n  feedTheBear(): void;\n  petTheBear(): void;\n}\n```\n\n假如现在有一个熊饲养员只关心 `washTheBear` 和 `petTheBear`，那么在现在的接口设计中，还需要被迫实现 `petTheBear`。\n\n我们可以把这个大的接口进行拆分。\n\n```typescript\ninterface BearCleaner {\n  washTheBear(): void;\n}\n\ninterface BearFeeder {\n  feedTheBear(): void;\n}\n\ninterface BearPetter {\n  petTheBear(): void;\n}\n```\n\n那么这时候不同的熊饲养员就可以自由的实现关心的接口了。\n\n```typescript\nclass BearCarer implements BearCleaner, BearFeeder {\n  washTheBear() {}\n  feedTheBear() {}\n}\n```\n\n> 在前面单一职责的例子中，我们还可以将 BookPrinter 进行拆分。\n\n## 依赖倒置原则（Dependency Inversion Principle）\n\n依赖倒置原则主要用于模块间的解耦。通常说，应用了依赖倒置原则的设计，高层模块将不会再直接依赖低层模块，而是依赖于抽象。\n\n举个例子。我们有一个 Computer 类：\n\n```typescript\nclass Computer {\n  private keyboard: StandardKeyboard;\n\n  constructor() {\n    this.keyboard = new StandardKeyboard();\n  }\n}\n```\n\n在 Computer 的构造函数中，我们将 StandardKeyboard 类和 Computer 类耦合在了一起。现在加入我们要新增一种键盘，那 Computer 的构造函数将会难以处理。\n\n使用依赖倒置的方法，我们可以抽象出一个 Keyboard 接口来进行解耦：\n\n```typescript\ninterface Keyboard {}\n\nclass Computer {\n  private keyboard: Keyboard;\n\n  constructor(keyboard: Keyboard) {\n    this.keyboard = keyboard;\n  }\n}\n```\n\n这时候重新实现 StandardKeyboard 类：\n\n```typescript\nclass StandardKeyboard implements Keyboard {}\n```\n\n重构后的代码，实现了 StandardKeyboard 和 Computer 的解耦，我们可以根据需要自由实现 Keyboard 接口。\n\n## 小结\n\nSOLID 原则是面向对象程序设计中非常经典的设计原则，同时也非常简单。理解和掌握这些原则，不仅对我们日常的开发维护工作帮助很大，也能提高自身的软件设计能力。\n\n## 参考文献\n\n- [Design Principles and Design Patterns](https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf)\n',contentRendered:'<p>SOLID 原则是五个面向对象程序设计基本原则的首字母简写，应用 SOLID 原则可以帮助我们开发出更容易维护、更灵活的软件。从而，在软件规模逐渐变大的时候，降低软件的复杂度，节省开发维护成本。</p>\n<p>SOLID 原则由如下五个原则组成：</p>\n<ul>\n<li>单一职责原则（Single Responsibility）</li>\n<li>开闭原则（Open/Closed 原则）</li>\n<li>里氏替换原则（Liskov Substitution）</li>\n<li>接口隔离原则（Interface Segregation）</li>\n<li>依赖倒置原则（Dependency Inversion）</li>\n</ul>\n<p>看名字有些原则可能不太好理解，下面我们通过一些代码示例来逐一说明。</p>\n<h2 id="单一职责原则-single-responsibility-principle" tabindex="-1"><a class="header-anchor" href="#单一职责原则-single-responsibility-principle" aria-hidden="true">#</a> 单一职责原则（Single Responsibility Principle）</h2>\n<p>通过名字就可以知道，这个原则的含义是一个类应该只有一种职责。换句话说，我们只能有一个原因来改变这个类。</p>\n<p>应用了单一职责的类，有如下几个优点：</p>\n<ul>\n<li>易测试。只有单一职责的类需要的测试 case 非常少，非常容易测试。</li>\n<li>低耦合。一个类的功能越少，需要的外部依赖越少。</li>\n<li>易管理。功能单一的类比功能复杂的类更容易进行组织。</li>\n</ul>\n<p>举个例子，我们有一个 Book 类：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n  <span class="token keyword">private</span> author<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n  <span class="token keyword">private</span> text<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在这个类中，我们保存了书名、作者和书的文本三个字段。</p>\n<p>现在我们添加一些操作文本的函数。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n  <span class="token keyword">private</span> author<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n  <span class="token keyword">private</span> text<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n\n  <span class="token function">replaceWordInText</span><span class="token punctuation">(</span>word<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> text<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">isWordInText</span><span class="token punctuation">(</span>word<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> text<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>现在假如说我们要把书的内容输出到控制台，我们可以给 Book 类加一个 print 方法：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code>    <span class="token comment">// ....</span>\n    <span class="token function">printTextToConsole</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 输出内容函数实现</span>\n    <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个时候，新添加的方法就破坏了单一职责原则。</p>\n<p>我们应该再定义一个类，BookPrinter 来专门输出书的内容：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">BookPrinter</span> <span class="token punctuation">{</span>\n  <span class="token function">printTextToConsole</span><span class="token punctuation">(</span>text<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//输出到控制台</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">printTextToAnotherMedium</span><span class="token punctuation">(</span>text<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 输出到其他媒体类型</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>通过 BookPrinter 类，我们不断实现了输出书的内容到控制台的功能，我们还可以支持将书的内容输出到其他媒体类型。不管是输出到邮件、日志还是什么其他地方，我们都有一个单独的类来处理这个问题。</p>\n<h2 id="开闭原则-open-closed-principle" tabindex="-1"><a class="header-anchor" href="#开闭原则-open-closed-principle" aria-hidden="true">#</a> 开闭原则（Open/Closed Principle）</h2>\n<p>开闭原则可以描述为”对扩展开放，对修改关闭“。也就是说，一个类只应该对扩展开放，对修改应该是关闭的。</p>\n<p>我们通过一个例子来说明。假设我们有一个生产电脑的类：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">MacOSComputer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">WindowsComputer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">ComputerFactory</span> <span class="token punctuation">{</span>\n  computerTypes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"macos"</span><span class="token punctuation">,</span> <span class="token string">"windows"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n  <span class="token function">createComputer</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">case</span> <span class="token string">"macos"</span><span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacOSComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">case</span> <span class="token string">"windows"</span><span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WindowsComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>现在，假如我们需要创建一个 linux 系统的电脑，我们应该怎么办呢？最直接的办法是修改 ComputerFactory 这个类，来支持新电脑的创建。但是这么做我们可能会影响到其他两种类型电脑的创建。结合开闭原则，我们可以做一些改造。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ComputerFactory</span> <span class="token punctuation">{</span>\n  <span class="token function">createComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">MacOSFactory</span> <span class="token keyword">extends</span> <span class="token class-name">ComputerFactory</span> <span class="token punctuation">{</span>\n  <span class="token function">createComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacOSComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">WindowsFactory</span> <span class="token keyword">extends</span> <span class="token class-name">ComputerFactory</span> <span class="token punctuation">{</span>\n  <span class="token function">createComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WindowsComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这个时候，如果我们新增一个 Linux 类型的电脑，就非常的方便。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">LinuxComputer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">LinuxFactory</span> <span class="token keyword">extends</span> <span class="token class-name">ComputerFactory</span> <span class="token punctuation">{</span>\n  <span class="token function">createComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LinuxComputer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="里氏替换原则-liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#里氏替换原则-liskov-substitution-principle" aria-hidden="true">#</a> 里氏替换原则（Liskov Substitution Principle）</h2>\n<p>里氏替换原则则简单的说，就是如果类 A 是类 B 的子类，那么我们可以在系统内将 B 替换成 A，且不改变软件行为。</p>\n<p>我们还是通过例子来说明。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>\n  <span class="token function">turnOnEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  <span class="token function">accelerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们定义了一个 Car 接口，提供了一些函数需要实现类来实现。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">MotorCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> engine<span class="token operator">:</span> Engine<span class="token punctuation">;</span>\n\n  <span class="token function">turnOnEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>engine<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">accelerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>engine<span class="token punctuation">.</span><span class="token function">powerOn</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>假如现在需要实现一个电动车：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">ElectricCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>\n  <span class="token function">turnOnEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"No engine"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">accelerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这时候，如果我们将新实现的电动车放到系统中的话，就会改变系统的行为，导致出错。</p>\n<p>我们需要重新定义一个没有引擎的 Car 接口：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>\n  <span class="token function">accelerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="接口隔离原则-interface-segregation-principle" tabindex="-1"><a class="header-anchor" href="#接口隔离原则-interface-segregation-principle" aria-hidden="true">#</a> 接口隔离原则（Interface Segregation Principle）</h2>\n<p>接口隔离原则要求我们将大的接口拆分成小的接口，这样可以保证实现类能聚焦在它需要关心的接口上面。</p>\n<p>我们以动物饲养员为例。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">BearKeeper</span> <span class="token punctuation">{</span>\n  <span class="token function">washTheBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  <span class="token function">feedTheBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n  <span class="token function">petTheBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>假如现在有一个熊饲养员只关心 <code>washTheBear</code> 和 <code>petTheBear</code>，那么在现在的接口设计中，还需要被迫实现 <code>petTheBear</code>。</p>\n<p>我们可以把这个大的接口进行拆分。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">BearCleaner</span> <span class="token punctuation">{</span>\n  <span class="token function">washTheBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">BearFeeder</span> <span class="token punctuation">{</span>\n  <span class="token function">feedTheBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">BearPetter</span> <span class="token punctuation">{</span>\n  <span class="token function">petTheBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>那么这时候不同的熊饲养员就可以自由的实现关心的接口了。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">BearCarer</span> <span class="token keyword">implements</span> <span class="token class-name">BearCleaner</span><span class="token punctuation">,</span> BearFeeder <span class="token punctuation">{</span>\n  <span class="token function">washTheBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token function">feedTheBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote>\n<p>在前面单一职责的例子中，我们还可以将 BookPrinter 进行拆分。</p>\n</blockquote>\n<h2 id="依赖倒置原则-dependency-inversion-principle" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则-dependency-inversion-principle" aria-hidden="true">#</a> 依赖倒置原则（Dependency Inversion Principle）</h2>\n<p>依赖倒置原则主要用于模块间的解耦。通常说，应用了依赖倒置原则的设计，高层模块将不会再直接依赖低层模块，而是依赖于抽象。</p>\n<p>举个例子。我们有一个 Computer 类：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Computer</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> keyboard<span class="token operator">:</span> StandardKeyboard<span class="token punctuation">;</span>\n\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>keyboard <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardKeyboard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在 Computer 的构造函数中，我们将 StandardKeyboard 类和 Computer 类耦合在了一起。现在加入我们要新增一种键盘，那 Computer 的构造函数将会难以处理。</p>\n<p>使用依赖倒置的方法，我们可以抽象出一个 Keyboard 接口来进行解耦：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Keyboard</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Computer</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> keyboard<span class="token operator">:</span> Keyboard<span class="token punctuation">;</span>\n\n  <span class="token function">constructor</span><span class="token punctuation">(</span>keyboard<span class="token operator">:</span> Keyboard<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>keyboard <span class="token operator">=</span> keyboard<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这时候重新实现 StandardKeyboard 类：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">StandardKeyboard</span> <span class="token keyword">implements</span> <span class="token class-name">Keyboard</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>重构后的代码，实现了 StandardKeyboard 和 Computer 的解耦，我们可以根据需要自由实现 Keyboard 接口。</p>\n<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>SOLID 原则是面向对象程序设计中非常经典的设计原则，同时也非常简单。理解和掌握这些原则，不仅对我们日常的开发维护工作帮助很大，也能提高自身的软件设计能力。</p>\n<h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2>\n<ul>\n<li><a href="https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf" target="_blank" rel="noopener noreferrer">Design Principles and Design Patterns<OutboundLink/></a></li>\n</ul>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-06-24",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/solid.html",pathLocale:"/",permalink:"/posts/2021/06/24/solid.html",slug:"solid",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/solid.md",filePathRelative:"posts/solid.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/06/24/solid.html.vue",componentFilePathRelative:"pages/posts/2021/06/24/solid.html.vue",componentFileChunkName:"v-15e0d1af",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/06/24/solid.html.js",dataFilePathRelative:"pages/posts/2021/06/24/solid.html.js",dataFileChunkName:"v-15e0d1af",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/06/24/solid.html",htmlFilePathRelative:"posts/2021/06/24/solid.html"},{key:"v-21105912",path:"/posts/2021/07/06/virtual-dom.html",title:"如何快速实现一个虚拟 DOM 系统",lang:"zh-CN",frontmatter:{title:"如何快速实现一个虚拟 DOM 系统",description:"描述如何快速实现一个简单的虚拟 DOM 系统。阐述一个虚拟 DOM 系统的组成部分。",keywords:["Virtual DOM","虚拟 DOM","diff 算法"],date:"2021-07-06T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"为什么需要虚拟 DOM？",slug:"为什么需要虚拟-dom",children:[]},{level:2,title:"如何实现虚拟 DOM",slug:"如何实现虚拟-dom",children:[]}],content:'\n::: tip\n虚拟 DOM 是目前主流前端框架的技术核心之一，本文阐述如何实现一个简单的虚拟 DOM 系统。\n:::\n\n## 为什么需要虚拟 DOM？\n\n虚拟 DOM 就是一棵由虚拟节点组成的树，这棵树展现了真实 DOM 的结构。这些虚拟节点是轻量的、无状态的，一般是字符串或者仅仅包含必要字段的 JavaScript 对象。虚拟节点可以被组装成节点树树，通过特定的 "diff" 算法对两个节点树进行对比，找出其中细微的变更点，然后更新到真实 DOM 上去。\n\n之所以会有虚拟 DOM，是因为直接更新真实 DOM 非常昂贵。通过新比对虚拟 DOM，然后只将变化的部分更新到真实 DOM 上去。这么做都是操作纯 JavaScript 对象，尽量避免了直接操作 DOM，读写成本低很多。\n\n## 如何实现虚拟 DOM\n\n在开始之前，我们需要明确一个虚拟 DOM 系统应该包含哪些必要的组成部分？\n\n首先，我们要定义清楚什么是虚拟节点。一个虚拟节点可以是一个普通 JavaScript 对象，也可以是一个字符串。\n\n我们定义一个函数 `createNode` 来创建虚拟节点。一个虚拟节点至少包含三个信息：\n\n- `tag`：保存虚拟节点的标签名，字符串\n- `props`：保存虚拟节点的 properties/attributes，普通对象\n- `children`：保存虚拟节点的子节点，数组\n\n下面的代码是 `createNode` 实现样例：\n\n```ts\nconst createNode = (tag, props, children) => ({\n  tag,\n  props,\n  children,\n});\n```\n\n我们通过 `createNode` 可以轻松的创建虚拟节点：\n\n```ts\ncreateNode(\'div\', { id: \'app\' }, [\'Hello World\']);\n\n// 返回如下：\n{\n  tag: \'div\',\n  props: { id: \'app\' },\n  children: [\'Hello World\'],\n}\n```\n\n现在，我们需要定义一个 `createElement` 函数来根据虚拟节点创建真实的 DOM 元素。\n\n在 `createElement` 中，我们需要创建一个新的 DOM 元素，然后遍历虚拟节点的 props 属性，将其中的属性添加到 DOM 元素上去，之后再遍历 children 属性。如下代码是一个实现样例：\n\n```ts\nconst createElement = vnode => {\n  if (typof vnode === \'string\') {\n    return document.createTextNode(vnode); // 如果是字符串就直接返回文本元素\n  }\n  const el = document.createElement(vnode.tag);\n  if (vnode.props) {\n    Object.entries(vnode.props).forEach(([name, value]) => {\n      el[name] = value;\n    });\n  }\n  if (vnode.children) {\n    vnode.children.forEach(child => {\n      el.appendChild(createElement(child));\n    });\n  }\n  return el;\n}\n```\n\n现在，我们可以通过 `createElement` 将虚拟节点转变成真实 DOM 了。\n\n```ts\ncreateElement(createNode("div", { id: "app" }, ["Hello World"]));\n\n// 输出： <div id="app">Hello World</div>\n```\n\n我们再来定义一个 `diff` 函数来实现 \'diff\' 算法。这个 `diff` 函数接收三个参数，一个是已经存在的 DOM 元素，一个是旧的虚拟节点，一个是新的虚拟节点。在这个函数中，我们将对比两个虚拟节点，在需要的时候，将旧的元素替换掉。\n\n```ts\nconst diff = (el, oldVNode, newVNode) => {\n  const replace = () => el.replaceWith(createElement(newVNode));\n  if (!newVNode) return el.remove();\n  if (!oldVNode) return el.appendChild(createElement(newVNode));\n  // 处理纯文本的情况\n  if (typeof oldVNode === \'string\' || typeof newVNode === \'string\') {\n    if (oldVNode !== newVNode) return replace();\n  } else {\n    // 对比标签名\n    if (oldVNode.tag !== newVNode.tag) return replace();\n    // 对比 props\n    if (!oldVNode.props?.some((prop) => oldVNode.props?.[prop] === newVNode.props?.[prop])) return replace();\n    // 对比 children\n    [...el.childNodes].forEach((child, i) => {\n      diff(child, oldVNode.children?.[i], newVNode.children?.[i]);\n    });\n  }\n}\n```\n\n在这个函数中，我们先处理纯文本的情况，如果新旧两个字符串不相同，则直接替换。之后，我们就可以假定两个虚拟节点都是对象了。我们先对比两个节点的标签名是否相同，不同则直接替换。之后对比两个节点的 props 是否相同，不同也直接替换。最后我们在递归的使用 `diff` 函数对比两个虚拟节点的 children。\n\n至此，我们就实现了一个简版虚拟 DOM 系统所必须的所有功能。下面是使用样例：\n\n```ts\nconst oldVNode = createNode("div", { id: "app" }, ["Hello World"]);\nconst newVNode = createNode("div", { id: "app" }, ["Goodbye World"]);\nconst el = createElement(oldVNode);\n// <div id="app">Hello World</div>\n\ndiff(el, oldVNode, newVNode);\n// el will become: <div id="app">Goodbye World</div>\n```\n\n> 文中的实现侧重于展示虚拟 DOM 的实现原理，在实现代码中并未考虑性能等其他因素。\n',contentRendered:'<div class="custom-container tip"><p class="custom-container-title">TIP</p>\n<p>虚拟 DOM 是目前主流前端框架的技术核心之一，本文阐述如何实现一个简单的虚拟 DOM 系统。</p>\n</div>\n<h2 id="为什么需要虚拟-dom" tabindex="-1"><a class="header-anchor" href="#为什么需要虚拟-dom" aria-hidden="true">#</a> 为什么需要虚拟 DOM？</h2>\n<p>虚拟 DOM 就是一棵由虚拟节点组成的树，这棵树展现了真实 DOM 的结构。这些虚拟节点是轻量的、无状态的，一般是字符串或者仅仅包含必要字段的 JavaScript 对象。虚拟节点可以被组装成节点树树，通过特定的 &quot;diff&quot; 算法对两个节点树进行对比，找出其中细微的变更点，然后更新到真实 DOM 上去。</p>\n<p>之所以会有虚拟 DOM，是因为直接更新真实 DOM 非常昂贵。通过新比对虚拟 DOM，然后只将变化的部分更新到真实 DOM 上去。这么做都是操作纯 JavaScript 对象，尽量避免了直接操作 DOM，读写成本低很多。</p>\n<h2 id="如何实现虚拟-dom" tabindex="-1"><a class="header-anchor" href="#如何实现虚拟-dom" aria-hidden="true">#</a> 如何实现虚拟 DOM</h2>\n<p>在开始之前，我们需要明确一个虚拟 DOM 系统应该包含哪些必要的组成部分？</p>\n<p>首先，我们要定义清楚什么是虚拟节点。一个虚拟节点可以是一个普通 JavaScript 对象，也可以是一个字符串。</p>\n<p>我们定义一个函数 <code>createNode</code> 来创建虚拟节点。一个虚拟节点至少包含三个信息：</p>\n<ul>\n<li><code>tag</code>：保存虚拟节点的标签名，字符串</li>\n<li><code>props</code>：保存虚拟节点的 properties/attributes，普通对象</li>\n<li><code>children</code>：保存虚拟节点的子节点，数组</li>\n</ul>\n<p>下面的代码是 <code>createNode</code> 实现样例：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">const</span> <span class="token function-variable function">createNode</span> <span class="token operator">=</span> <span class="token punctuation">(</span>tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n  tag<span class="token punctuation">,</span>\n  props<span class="token punctuation">,</span>\n  children<span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们通过 <code>createNode</code> 可以轻松的创建虚拟节点：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token function">createNode</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">\'app\'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'Hello World\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 返回如下：</span>\n<span class="token punctuation">{</span>\n  tag<span class="token operator">:</span> <span class="token string">\'div\'</span><span class="token punctuation">,</span>\n  props<span class="token operator">:</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">\'app\'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'Hello World\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>现在，我们需要定义一个 <code>createElement</code> 函数来根据虚拟节点创建真实的 DOM 元素。</p>\n<p>在 <code>createElement</code> 中，我们需要创建一个新的 DOM 元素，然后遍历虚拟节点的 props 属性，将其中的属性添加到 DOM 元素上去，之后再遍历 children 属性。如下代码是一个实现样例：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">const</span> <span class="token function-variable function">createElement</span> <span class="token operator">=</span> vnode <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>typof vnode <span class="token operator">===</span> <span class="token string">\'string\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果是字符串就直接返回文本元素</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>name<span class="token punctuation">,</span> value<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      el<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    vnode<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>child <span class="token operator">=></span> <span class="token punctuation">{</span>\n      el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">createElement</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> el<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>现在，我们可以通过 <code>createElement</code> 将虚拟节点转变成真实 DOM 了。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token function">createNode</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">"app"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"Hello World"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 输出： &lt;div id="app">Hello World&lt;/div></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们再来定义一个 <code>diff</code> 函数来实现 \'diff\' 算法。这个 <code>diff</code> 函数接收三个参数，一个是已经存在的 DOM 元素，一个是旧的虚拟节点，一个是新的虚拟节点。在这个函数中，我们将对比两个虚拟节点，在需要的时候，将旧的元素替换掉。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">const</span> <span class="token function-variable function">diff</span> <span class="token operator">=</span> <span class="token punctuation">(</span>el<span class="token punctuation">,</span> oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token function-variable function">replace</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> el<span class="token punctuation">.</span><span class="token function">replaceWith</span><span class="token punctuation">(</span><span class="token function">createElement</span><span class="token punctuation">(</span>newVNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newVNode<span class="token punctuation">)</span> <span class="token keyword">return</span> el<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldVNode<span class="token punctuation">)</span> <span class="token keyword">return</span> el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">createElement</span><span class="token punctuation">(</span>newVNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 处理纯文本的情况</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> oldVNode <span class="token operator">===</span> <span class="token string">\'string\'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> newVNode <span class="token operator">===</span> <span class="token string">\'string\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVNode <span class="token operator">!==</span> newVNode<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 对比标签名</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVNode<span class="token punctuation">.</span>tag <span class="token operator">!==</span> newVNode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 对比 props</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldVNode<span class="token punctuation">.</span>props<span class="token operator">?.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span> <span class="token operator">=></span> oldVNode<span class="token punctuation">.</span>props<span class="token operator">?.</span><span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">===</span> newVNode<span class="token punctuation">.</span>props<span class="token operator">?.</span><span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// 对比 children</span>\n    <span class="token punctuation">[</span><span class="token operator">...</span>el<span class="token punctuation">.</span>childNodes<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">diff</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> oldVNode<span class="token punctuation">.</span>children<span class="token operator">?.</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> newVNode<span class="token punctuation">.</span>children<span class="token operator">?.</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在这个函数中，我们先处理纯文本的情况，如果新旧两个字符串不相同，则直接替换。之后，我们就可以假定两个虚拟节点都是对象了。我们先对比两个节点的标签名是否相同，不同则直接替换。之后对比两个节点的 props 是否相同，不同也直接替换。最后我们在递归的使用 <code>diff</code> 函数对比两个虚拟节点的 children。</p>\n<p>至此，我们就实现了一个简版虚拟 DOM 系统所必须的所有功能。下面是使用样例：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">const</span> oldVNode <span class="token operator">=</span> <span class="token function">createNode</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">"app"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"Hello World"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newVNode <span class="token operator">=</span> <span class="token function">createNode</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">"app"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"Goodbye World"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token function">createElement</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// &lt;div id="app">Hello World&lt;/div></span>\n\n<span class="token function">diff</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// el will become: &lt;div id="app">Goodbye World&lt;/div></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote>\n<p>文中的实现侧重于展示虚拟 DOM 的实现原理，在实现代码中并未考虑性能等其他因素。</p>\n</blockquote>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2021-07-06",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/virtual-dom.html",pathLocale:"/",permalink:"/posts/2021/07/06/virtual-dom.html",slug:"virtual-dom",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/virtual-dom.md",filePathRelative:"posts/virtual-dom.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/06/virtual-dom.html.vue",componentFilePathRelative:"pages/posts/2021/07/06/virtual-dom.html.vue",componentFileChunkName:"v-21105912",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2021/07/06/virtual-dom.html.js",dataFilePathRelative:"pages/posts/2021/07/06/virtual-dom.html.js",dataFileChunkName:"v-21105912",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2021/07/06/virtual-dom.html",htmlFilePathRelative:"posts/2021/07/06/virtual-dom.html"},{key:"v-204692c7",path:"/posts/2022/01/13/vite-and-microfrontend.html",title:"使用 vite 构建项目并实现接入微前端",lang:"zh-CN",frontmatter:{title:"使用 vite 构建项目并实现接入微前端",description:"本文是在项目中使用 vite 构建的经验记录，同时给出如何构建微前端应用的方案。",keywords:["vite","micro frontend","qiankun"],date:"2022-01-13T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["经验总结"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"基础配置",slug:"基础配置",children:[]},{level:2,title:"支持微前端构建",slug:"支持微前端构建",children:[]},{level:2,title:"其他说明",slug:"其他说明",children:[{level:3,title:"1. 老旧浏览器的支持",slug:"_1-老旧浏览器的支持",children:[]},{level:3,title:"2. 关于 TypeScript 的说明",slug:"_2-关于-typescript-的说明",children:[]},{level:3,title:"3. 对接 CDN",slug:"_3-对接-cdn",children:[]},{level:3,title:"4. 构建出错",slug:"_4-构建出错",children:[]}]},{level:2,title:"小结",slug:"小结",children:[]}],content:"\n得益于 [esbuild 的超高性能](https://esbuild.github.io/faq/#why-is-esbuild-fast)，vite 在诞生之初就备受关注，且一直保持着活跃的开发迭代。截至目前，vite 已经迭代到了 2.7.10 版本，各方面也基本具备了在生产使用的条件。这段时间，我在项目中尝试了使用 vite 进行打包构建，本文就是这次构建的过程记录。\n\n## 基础配置\n\n首先使用[vite 官方脚手架](https://vitejs.dev/guide/#scaffolding-your-first-vite-project)生成项目。\n\n```bash\nyarn create vite vite-demo --template react-ts\n```\n\n> 上面这行命令使用 `react-ts` 模板创建了一个叫 `vite-demo` 的项目。由于我在的团队日常使用 react 和 typescript 开发居多，因此选择了 `react-ts` 这个模板，vite 官方支持的模板还有很多，可以在 [create-vite](https://github.com/vitejs/vite/tree/main/packages/create-vite) 中查看。\n\n项目初始化完成以后，目录结构如下：\n\n```txt\n.\n|____index.html\n|____.gitignore\n|____package.json\n|____tsconfig.json\n|____vite.config.ts\n|____src\n| |____App.tsx\n| |____main.tsx\n| |____App.css\n| |____index.css\n| |____vite-env.d.ts\n| |____logo.svg\n| |____favicon.svg\n```\n\n其中 vite.config.ts 内容如下：\n\n```ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()]\n})\n```\n\n> 可以看出，vite 官方已经做了比较完善的封装，相较于之前版本，开发体验提升了很多。\n\n按照指示安装完依赖，启动应用以后，速度确实很快。现在我们来做一些基本改造。\n\n我通常使用 less 来写样式，vite 已经做了很好的支持，在安装完依赖以后，只需要直接在代码中引用 `xxx.less` 即可。对于一个久经考验的开发者来说，样式还是要引入作用域的，通常使用 css modules。\n\n安装 less 预处理器，\n\n```bash\nyarn add --dev less\n```\n\n然后修改 `vite.config.ts` 文件，添加 css modules 配置：\n\n```ts\nexport default defineConfig({\n  ...\n  css: {\n    modules: {\n      localsConvention: 'camelCaseOnly', // 我们使用驼峰形式\n    },\n  },\n  ...\n})\n```\n\n添加完配置以后，只要将原来的 `xxx.less` 改成 `xxx.module.less` 即可，这点与 create-react-app 是一样的。\n\n> 这里推荐一个 vscode 插件 [clinyong.vscode-css-modules](https://marketplace.visualstudio.com/items?itemName=clinyong.vscode-css-modules) 可以实现编码时样式类名的智能提示，同时点击样式类名可以跳转到样式定义的地方，非常好用。如果在编写样式时使用的是中划线形式的命名方式，比如 `.xxx-container`，那么需要额外配置这个 vscode 插件，如下：\n> ```json\n> {\n>   \"cssModules.camelCase\": true\n> }\n> ```\n> 这样可以实现编写样式时使用中划线形式，在代码中使用的还是驼峰式的。\n\n由于我开发的是一个中后台项目，使用了 antd 和 lodash，大家都知道，这两个是按需加载大户，以前我们使用 [babel-plugin-import](https://www.npmjs.com/package/babel-plugin-import) 来处理，vite 生态里也有很多类似的方案。我选用了 [vite-plugin-imp](https://www.npmjs.com/package/vite-plugin-imp) 这个插件，修改 `vite.config.ts` 如下：\n\n```ts\nimport vitePluginImp from 'vite-plugin-imp';\n\nexport default defineConfig({\n  ...\n  plugins: [\n    ...\n    vitePluginImp({\n      libList: [\n        {\n          libName: 'lodash',\n          libDirectory: '',\n          camel2DashComponentName: false,\n        },\n        {\n          libName: 'antd',\n          style(name) {\n              // use less\n              return `antd/es/${name}/style/index.js`;\n          },\n        },\n      ],\n    }),\n  ],\n  css: {\n    ...\n    preprocessorOptions: {\n      less: {\n        javascriptEnabled: true,\n      },\n    },\n  },\n});\n```\n\n> antd 已经默认支持了 Tree Shaking，上面的配置最终只会处理样式的按需加载。lodash 不支持 Tree Shaking，我们也可以使用 ESM 版本 [lodash-es](https://www.npmjs.com/package/lodash-es)，这样就可以不使用 vite-plugin-imp 了，配置如下：\n> ```ts\n> export default defineConfig({\n>   resolve: {\n>     alias: [{\n>       find: /^lodash$/,\n>       replacement: 'lodash-es',\n>     }],\n>   },\n> });\n> ```\n\n通常，我们在开发前端项目时，需要一些代理来调用后端 API 接口，vite 配置如下：\n\n```ts\nexport default defineConfig({\n    ...\n    server: {\n      proxy: {\n        '/api_path/': {\n          target: 'http://xxx.server.domain.com/',\n          changeOrigin: true,\n        },\n      },\n    },\n});\n```\n\n> 代理底层都是基于 [http-proxy](https://www.npmjs.com/package/http-proxy) 实现，这里不做过多说明了。\n\n现在可以愉快的开发代码了。\n\n## 支持微前端构建\n\n因为我们的中后台应用是使用微前端（qiankun）来管理的，上面的配置，打包完成后不能被 qiankun 识别，主要原因可以看看[这里](https://github.com/umijs/qiankun/issues/1257)，我们需要做一些额外处理。\n\n我们知道，使用 webpack 构建微前端是，需要添加如下三个配置项：\n\n```js\n{\n  output: {\n    libraryTarget: 'umd',\n    library: `${APP_NAME}-[name]`,\n    jsonpFunction: `webpackJsonp_${APP_NAME}`,\n  }\n}\n```\n\n在 vite 中，可以直接通过设置 `build.rollupOptions.format` 为 `umd` 来设置 UMD 规范，但是实际构建结果却不能被 qiankun 识别，猜想是可能跟 vite 使用 html entry 有关系。\n\n换一个思路，我们把当前整个应用当做一个 library 来构建，输出为 UMD 规范，然后手动写入一个 html 文件，加载这个输出的 JS。\n\n修改配置如下：\n\n```ts\nexport default defineConfig({\n  ...\n  build: {\n    lib: {\n      name,\n      entry: path.resolve(__dirname, 'src/index.tsx'),\n      formats: ['umd'],\n    },\n  },\n  ...\n})\n```\n\n配置完成之后，执行 `yarn build` 提示如下错误：\n\n```txt\nUMD and IIFE output formats are not supported for code-splitting builds.\n```\n\n因为我们的应用中有路由，使用了按需加载。我们将 rollup 的 `inlineDynamicImports` 配置打开：\n\n```ts\nexport default defineConfig({\n  ...\n  build: {\n    rollupOptions: {\n      output: {\n        inlineDynamicImports: true,\n      },\n    },\n  },\n  ...\n})\n```\n这样，构建完成之后，dist 目录下有两个文件 `style.css` 和 `xxx.umd.js`。\n\n现在我们要生成 `index.html` 了。\n\n因为 vite 在开发态直接使用 ES Modules，是不打包的，因此生成开发态的 `index.html` 和生产的 `index.html` 是不同的。\n\n我们修改项目根目录下的 `index.html` 为：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/src/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Vite App</title>\n    \x3c!-- style placeholder --\x3e\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    \x3c!-- script placeholder --\x3e\n  </body>\n</html>\n```\n\n注意当中的两行注释，我们会在开发态和生产构建做不同的处理。\n\nvite 插件 API 中有一个 [`transformindexhtml`](https://vitejs.dev/guide/api-plugin.html#transformindexhtml) 可以定制开发态的 html 内容，因此，我们开发态的配置如下：\n\n```ts\n// https://vitejs.dev/config/\nexport default defineConfig({\n  ...\n  plugins: [\n    ...\n    {\n      name: 'dev html',\n      apply: 'serve',\n      transformIndexHtml(indexHtml: string) {\n        return indexHtml\n          .replace('\x3c!-- style placeholder --\x3e', '')\n          .replace('\x3c!-- script placeholder --\x3e', '<script type=\"module\" src=\"/src/index.tsx\"><\/script>');\n      },\n    },\n    ...\n  ],\n});\n```\n\n生产构建需要借助于 [`@rollup/plugin-html`](https://www.npmjs.com/package/@rollup/plugin-html) 这个插件来实现定制 html 内容。\n\n```ts\nimport html from '@rollup/plugin-html';\nimport fs from 'fs';\n\nconst entryHtml = fs.readFileSync('./index.html', { encoding: 'utf-8' });\n\nexport default defineConfig({\n  ...\n  plugins: [\n    ...\n    {\n      name: 'build html',\n      apply: 'build',\n      ...html({\n        template: () => {\n          return entryHtml\n            .replace(\n              '\x3c!-- style placeholder --\x3e',\n              '<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" />',\n            )\n            .replace(\n              '\x3c!-- script placeholder --\x3e',\n              `<script type=\"text/javascript\" src=\"${name}.umd.js\"><\/script>`,\n            );\n        },\n      }),\n    },\n    ...\n  ],\n});\n```\n\n通过上面的配置，再次构建，qiankun 可以加载这个子应用了。\n\n## 其他说明\n\n### 1. 老旧浏览器的支持\n\n由于我这次的项目是中后台项目，对老旧浏览器的支持诉求不强烈，就没有在项目中做处理。其实 vite 官方也是给了解决方案的，就是 [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) 这个插件。\n\n原理也非常简单，就是通过 `<script nomodule>` 来实现在不支持 ES Modules 的浏览器执行相关脚本，同时使用 [`SystemJS`](https://github.com/systemjs/systemjs) 来加载模块。\n\n### 2. 关于 TypeScript 的说明\n\n脚手架初始化完成以后就可以用 TypeScript 开发，这里格外说明一点，就是需要开启编译器选项 `isolatedModules:true`，因为 vite 使用 esbuild 处理 ts 文件，只将 ts转换成 js 而不做类型检查（依赖编辑器处理类型检查，比如 vscode）。因此，当遇到一些纯类型的导入导出时，会出错，需要开启  `isolatedModules:true` 来避免这个问题。如果因为一些原因无法开启这个选项，则可以使用 [rollup-plugin-friendly-type-imports](https://www.npmjs.com/package/rollup-plugin-friendly-type-imports) 这个包来处理，这个包的 README 里也说明了为什么会有这样的问题。\n\n### 3. 对接 CDN\n\n基于上面的配置构建出来的结果，浏览器在加载资源的时候，都是使用的根路径（`/`）加载，如果使用 CDN 的话会出现资源加载 404 的问题。\n\n我们可以配置 `base` 来设置基础路径，类似于 webpack 的 `PUBLIC_PATH`。\n\n```ts\nexport default defineConfig({\n  base: '/some/public/path',\n})\n```\n\n### 4. 构建出错\n\n#### 4.1 找不到包\n\n报错信息为：\n\n```txt\n[plugin: vite:dep-scan] Failed to resolve entry for package \"xxx\"\n```\n\n通常是依赖包未在 package.json 正确配置 main、module 等字段，导致 vite 无法找到包的入口。\n\n可以设置通过设置别名的方式，将其映射到正确的文件上。\n\n```ts\nexport default defineConfig({\n  resolve: {\n    alias: [{\n      find: /^SOME_PACKAGE_NAME$/,\n      replacement: 'SOME_PACKAGE_NAME/dist/xxx.es.js',\n    }],\n  },\n});\n```\n\n#### 4.2 请求超时\n\n报错信息为：\n\n```txt\nnet::ERR_ABORTED 408 (Request Timeout)\n```\n\n启动开发服务器后，浏览器出现请求超时错误。是因为 vite 检测到对依赖包的请求，且该依赖尚未被 vite 处理过，这时候会会触发预构建，导致请求超时以及页面重载。\n\n我们可以多刷新几次等 vite 完成预构建，也可以将依赖加入 `optimizeDeps.include` 来提前处理。\n\n#### 4.3 导入模块出错\n\n报错信息为：\n\n```txt\nInternal server error: Failed to resolve import \"./chunk-7L3SPMWF.js\" from \"node_modules/.vite/antd.js?v=7bec0e27\". Does the file exist?\n```\n\n可能是因为一些依赖包输出的格式 vite 还不支持，可以看看这个 [issue](https://github.com/vitejs/vite/issues/3308)。\n\n这个错误只在开发服务器运行处理过程中存在，待页面正常展示后就不出现了，忽略这个错误之后，目前看也没产生什么影响。\n\n## 小结\n\n总体来说，vite 已经基本具备了生产使用的条件。如果是常规的应用开发，vite 的配置非常简单，可以说是开箱即用。如果需要添加额外的配置也非常方便。\n\n目前比较大的问题是周边生态还不是特别成熟，很多已经成熟的包对于 vite（ES Modules）的支持比较弱。同时，如果团队内基建氛围比较浓厚的话，自己开发的工具包也要考虑这方面的问题。\n",contentRendered:'<p>得益于 <a href="https://esbuild.github.io/faq/#why-is-esbuild-fast" target="_blank" rel="noopener noreferrer">esbuild 的超高性能<OutboundLink/></a>，vite 在诞生之初就备受关注，且一直保持着活跃的开发迭代。截至目前，vite 已经迭代到了 2.7.10 版本，各方面也基本具备了在生产使用的条件。这段时间，我在项目中尝试了使用 vite 进行打包构建，本文就是这次构建的过程记录。</p>\n<h2 id="基础配置" tabindex="-1"><a class="header-anchor" href="#基础配置" aria-hidden="true">#</a> 基础配置</h2>\n<p>首先使用<a href="https://vitejs.dev/guide/#scaffolding-your-first-vite-project" target="_blank" rel="noopener noreferrer">vite 官方脚手架<OutboundLink/></a>生成项目。</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> create vite vite-demo --template react-ts\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><blockquote>\n<p>上面这行命令使用 <code>react-ts</code> 模板创建了一个叫 <code>vite-demo</code> 的项目。由于我在的团队日常使用 react 和 typescript 开发居多，因此选择了 <code>react-ts</code> 这个模板，vite 官方支持的模板还有很多，可以在 <a href="https://github.com/vitejs/vite/tree/main/packages/create-vite" target="_blank" rel="noopener noreferrer">create-vite<OutboundLink/></a> 中查看。</p>\n</blockquote>\n<p>项目初始化完成以后，目录结构如下：</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>.\n|____index.html\n|____.gitignore\n|____package.json\n|____tsconfig.json\n|____vite.config.ts\n|____src\n| |____App.tsx\n| |____main.tsx\n| |____App.css\n| |____index.css\n| |____vite-env.d.ts\n| |____logo.svg\n| |____favicon.svg\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>其中 vite.config.ts 内容如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vite\'</span>\n<span class="token keyword">import</span> react <span class="token keyword">from</span> <span class="token string">\'@vitejs/plugin-react\'</span>\n\n<span class="token comment">// https://vitejs.dev/config/</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote>\n<p>可以看出，vite 官方已经做了比较完善的封装，相较于之前版本，开发体验提升了很多。</p>\n</blockquote>\n<p>按照指示安装完依赖，启动应用以后，速度确实很快。现在我们来做一些基本改造。</p>\n<p>我通常使用 less 来写样式，vite 已经做了很好的支持，在安装完依赖以后，只需要直接在代码中引用 <code>xxx.less</code> 即可。对于一个久经考验的开发者来说，样式还是要引入作用域的，通常使用 css modules。</p>\n<p>安装 less 预处理器，</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> --dev <span class="token function">less</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>然后修改 <code>vite.config.ts</code> 文件，添加 css modules 配置：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  css<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token keyword">module</span>s<span class="token operator">:</span> <span class="token punctuation">{</span>\n      localsConvention<span class="token operator">:</span> <span class="token string">\'camelCaseOnly\'</span><span class="token punctuation">,</span> <span class="token comment">// 我们使用驼峰形式</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>添加完配置以后，只要将原来的 <code>xxx.less</code> 改成 <code>xxx.module.less</code> 即可，这点与 create-react-app 是一样的。</p>\n<blockquote>\n<p>这里推荐一个 vscode 插件 <a href="https://marketplace.visualstudio.com/items?itemName=clinyong.vscode-css-modules" target="_blank" rel="noopener noreferrer">clinyong.vscode-css-modules<OutboundLink/></a> 可以实现编码时样式类名的智能提示，同时点击样式类名可以跳转到样式定义的地方，非常好用。如果在编写样式时使用的是中划线形式的命名方式，比如 <code>.xxx-container</code>，那么需要额外配置这个 vscode 插件，如下：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"cssModules.camelCase"</span><span class="token operator">:</span> <span class="token boolean">true</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样可以实现编写样式时使用中划线形式，在代码中使用的还是驼峰式的。</p>\n</blockquote>\n<p>由于我开发的是一个中后台项目，使用了 antd 和 lodash，大家都知道，这两个是按需加载大户，以前我们使用 <a href="https://www.npmjs.com/package/babel-plugin-import" target="_blank" rel="noopener noreferrer">babel-plugin-import<OutboundLink/></a> 来处理，vite 生态里也有很多类似的方案。我选用了 <a href="https://www.npmjs.com/package/vite-plugin-imp" target="_blank" rel="noopener noreferrer">vite-plugin-imp<OutboundLink/></a> 这个插件，修改 <code>vite.config.ts</code> 如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> vitePluginImp <span class="token keyword">from</span> <span class="token string">\'vite-plugin-imp\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token operator">...</span>\n    <span class="token function">vitePluginImp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      libList<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n          libName<span class="token operator">:</span> <span class="token string">\'lodash\'</span><span class="token punctuation">,</span>\n          libDirectory<span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span>\n          camel2DashComponentName<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token punctuation">{</span>\n          libName<span class="token operator">:</span> <span class="token string">\'antd\'</span><span class="token punctuation">,</span>\n          <span class="token function">style</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n              <span class="token comment">// use less</span>\n              <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">antd/es/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/style/index.js</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n          <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  css<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>\n    preprocessorOptions<span class="token operator">:</span> <span class="token punctuation">{</span>\n      less<span class="token operator">:</span> <span class="token punctuation">{</span>\n        javascriptEnabled<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><blockquote>\n<p>antd 已经默认支持了 Tree Shaking，上面的配置最终只会处理样式的按需加载。lodash 不支持 Tree Shaking，我们也可以使用 ESM 版本 <a href="https://www.npmjs.com/package/lodash-es" target="_blank" rel="noopener noreferrer">lodash-es<OutboundLink/></a>，这样就可以不使用 vite-plugin-imp 了，配置如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  resolve<span class="token operator">:</span> <span class="token punctuation">{</span>\n    alias<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>\n      find<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^lodash$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>\n      replacement<span class="token operator">:</span> <span class="token string">\'lodash-es\'</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></blockquote>\n<p>通常，我们在开发前端项目时，需要一些代理来调用后端 API 接口，vite 配置如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token operator">...</span>\n    server<span class="token operator">:</span> <span class="token punctuation">{</span>\n      proxy<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token string">\'/api_path/\'</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n          target<span class="token operator">:</span> <span class="token string">\'http://xxx.server.domain.com/\'</span><span class="token punctuation">,</span>\n          changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote>\n<p>代理底层都是基于 <a href="https://www.npmjs.com/package/http-proxy" target="_blank" rel="noopener noreferrer">http-proxy<OutboundLink/></a> 实现，这里不做过多说明了。</p>\n</blockquote>\n<p>现在可以愉快的开发代码了。</p>\n<h2 id="支持微前端构建" tabindex="-1"><a class="header-anchor" href="#支持微前端构建" aria-hidden="true">#</a> 支持微前端构建</h2>\n<p>因为我们的中后台应用是使用微前端（qiankun）来管理的，上面的配置，打包完成后不能被 qiankun 识别，主要原因可以看看<a href="https://github.com/umijs/qiankun/issues/1257" target="_blank" rel="noopener noreferrer">这里<OutboundLink/></a>，我们需要做一些额外处理。</p>\n<p>我们知道，使用 webpack 构建微前端是，需要添加如下三个配置项：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">{</span>\n  output<span class="token operator">:</span> <span class="token punctuation">{</span>\n    libraryTarget<span class="token operator">:</span> <span class="token string">\'umd\'</span><span class="token punctuation">,</span>\n    library<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">APP_NAME</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">-[name]</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n    jsonpFunction<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">webpackJsonp_</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">APP_NAME</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在 vite 中，可以直接通过设置 <code>build.rollupOptions.format</code> 为 <code>umd</code> 来设置 UMD 规范，但是实际构建结果却不能被 qiankun 识别，猜想是可能跟 vite 使用 html entry 有关系。</p>\n<p>换一个思路，我们把当前整个应用当做一个 library 来构建，输出为 UMD 规范，然后手动写入一个 html 文件，加载这个输出的 JS。</p>\n<p>修改配置如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  build<span class="token operator">:</span> <span class="token punctuation">{</span>\n    lib<span class="token operator">:</span> <span class="token punctuation">{</span>\n      name<span class="token punctuation">,</span>\n      entry<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">\'src/index.tsx\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      formats<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'umd\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>配置完成之后，执行 <code>yarn build</code> 提示如下错误：</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>UMD and IIFE output formats are not supported for code-splitting builds.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>因为我们的应用中有路由，使用了按需加载。我们将 rollup 的 <code>inlineDynamicImports</code> 配置打开：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  build<span class="token operator">:</span> <span class="token punctuation">{</span>\n    rollupOptions<span class="token operator">:</span> <span class="token punctuation">{</span>\n      output<span class="token operator">:</span> <span class="token punctuation">{</span>\n        inlineDynamicImports<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这样，构建完成之后，dist 目录下有两个文件 <code>style.css</code> 和 <code>xxx.umd.js</code>。</p>\n<p>现在我们要生成 <code>index.html</code> 了。</p>\n<p>因为 vite 在开发态直接使用 ES Modules，是不打包的，因此生成开发态的 <code>index.html</code> 和生产的 <code>index.html</code> 是不同的。</p>\n<p>我们修改项目根目录下的 <code>index.html</code> 为：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>icon<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>image/svg+xml<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/src/favicon.svg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Vite App<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- style placeholder --\x3e</span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- script placeholder --\x3e</span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>注意当中的两行注释，我们会在开发态和生产构建做不同的处理。</p>\n<p>vite 插件 API 中有一个 <a href="https://vitejs.dev/guide/api-plugin.html#transformindexhtml" target="_blank" rel="noopener noreferrer"><code>transformindexhtml</code><OutboundLink/></a> 可以定制开发态的 html 内容，因此，我们开发态的配置如下：</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token comment">// https://vitejs.dev/config/</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token operator">...</span>\n    <span class="token punctuation">{</span>\n      name<span class="token operator">:</span> <span class="token string">\'dev html\'</span><span class="token punctuation">,</span>\n      apply<span class="token operator">:</span> <span class="token string">\'serve\'</span><span class="token punctuation">,</span>\n      <span class="token function">transformIndexHtml</span><span class="token punctuation">(</span>indexHtml<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> indexHtml\n          <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">\'&lt;!-- style placeholder --\x3e\'</span><span class="token punctuation">,</span> <span class="token string">\'\'</span><span class="token punctuation">)</span>\n          <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">\'&lt;!-- script placeholder --\x3e\'</span><span class="token punctuation">,</span> <span class="token string">\'&lt;script type="module" src="/src/index.tsx">&lt;/script>\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token operator">...</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>生产构建需要借助于 <a href="https://www.npmjs.com/package/@rollup/plugin-html" target="_blank" rel="noopener noreferrer"><code>@rollup/plugin-html</code><OutboundLink/></a> 这个插件来实现定制 html 内容。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">import</span> html <span class="token keyword">from</span> <span class="token string">\'@rollup/plugin-html\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> fs <span class="token keyword">from</span> <span class="token string">\'fs\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> entryHtml <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">\'./index.html\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> encoding<span class="token operator">:</span> <span class="token string">\'utf-8\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token operator">...</span>\n    <span class="token punctuation">{</span>\n      name<span class="token operator">:</span> <span class="token string">\'build html\'</span><span class="token punctuation">,</span>\n      apply<span class="token operator">:</span> <span class="token string">\'build\'</span><span class="token punctuation">,</span>\n      <span class="token operator">...</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token function-variable function">template</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          <span class="token keyword">return</span> entryHtml\n            <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>\n              <span class="token string">\'&lt;!-- style placeholder --\x3e\'</span><span class="token punctuation">,</span>\n              <span class="token string">\'&lt;link rel="stylesheet" type="text/css" href="style.css" />\'</span><span class="token punctuation">,</span>\n            <span class="token punctuation">)</span>\n            <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>\n              <span class="token string">\'&lt;!-- script placeholder --\x3e\'</span><span class="token punctuation">,</span>\n              <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;script type="text/javascript" src="</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.umd.js">&lt;/script></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n            <span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token operator">...</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>通过上面的配置，再次构建，qiankun 可以加载这个子应用了。</p>\n<h2 id="其他说明" tabindex="-1"><a class="header-anchor" href="#其他说明" aria-hidden="true">#</a> 其他说明</h2>\n<h3 id="_1-老旧浏览器的支持" tabindex="-1"><a class="header-anchor" href="#_1-老旧浏览器的支持" aria-hidden="true">#</a> 1. 老旧浏览器的支持</h3>\n<p>由于我这次的项目是中后台项目，对老旧浏览器的支持诉求不强烈，就没有在项目中做处理。其实 vite 官方也是给了解决方案的，就是 <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy" target="_blank" rel="noopener noreferrer">@vitejs/plugin-legacy<OutboundLink/></a> 这个插件。</p>\n<p>原理也非常简单，就是通过 <code>&lt;script nomodule&gt;</code> 来实现在不支持 ES Modules 的浏览器执行相关脚本，同时使用 <a href="https://github.com/systemjs/systemjs" target="_blank" rel="noopener noreferrer"><code>SystemJS</code><OutboundLink/></a> 来加载模块。</p>\n<h3 id="_2-关于-typescript-的说明" tabindex="-1"><a class="header-anchor" href="#_2-关于-typescript-的说明" aria-hidden="true">#</a> 2. 关于 TypeScript 的说明</h3>\n<p>脚手架初始化完成以后就可以用 TypeScript 开发，这里格外说明一点，就是需要开启编译器选项 <code>isolatedModules:true</code>，因为 vite 使用 esbuild 处理 ts 文件，只将 ts转换成 js 而不做类型检查（依赖编辑器处理类型检查，比如 vscode）。因此，当遇到一些纯类型的导入导出时，会出错，需要开启  <code>isolatedModules:true</code> 来避免这个问题。如果因为一些原因无法开启这个选项，则可以使用 <a href="https://www.npmjs.com/package/rollup-plugin-friendly-type-imports" target="_blank" rel="noopener noreferrer">rollup-plugin-friendly-type-imports<OutboundLink/></a> 这个包来处理，这个包的 README 里也说明了为什么会有这样的问题。</p>\n<h3 id="_3-对接-cdn" tabindex="-1"><a class="header-anchor" href="#_3-对接-cdn" aria-hidden="true">#</a> 3. 对接 CDN</h3>\n<p>基于上面的配置构建出来的结果，浏览器在加载资源的时候，都是使用的根路径（<code>/</code>）加载，如果使用 CDN 的话会出现资源加载 404 的问题。</p>\n<p>我们可以配置 <code>base</code> 来设置基础路径，类似于 webpack 的 <code>PUBLIC_PATH</code>。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  base<span class="token operator">:</span> <span class="token string">\'/some/public/path\'</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_4-构建出错" tabindex="-1"><a class="header-anchor" href="#_4-构建出错" aria-hidden="true">#</a> 4. 构建出错</h3>\n<h4 id="_4-1-找不到包" tabindex="-1"><a class="header-anchor" href="#_4-1-找不到包" aria-hidden="true">#</a> 4.1 找不到包</h4>\n<p>报错信息为：</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>[plugin: vite:dep-scan] Failed to resolve entry for package "xxx"\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>通常是依赖包未在 package.json 正确配置 main、module 等字段，导致 vite 无法找到包的入口。</p>\n<p>可以设置通过设置别名的方式，将其映射到正确的文件上。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  resolve<span class="token operator">:</span> <span class="token punctuation">{</span>\n    alias<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>\n      find<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^SOME_PACKAGE_NAME$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>\n      replacement<span class="token operator">:</span> <span class="token string">\'SOME_PACKAGE_NAME/dist/xxx.es.js\'</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_4-2-请求超时" tabindex="-1"><a class="header-anchor" href="#_4-2-请求超时" aria-hidden="true">#</a> 4.2 请求超时</h4>\n<p>报错信息为：</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>net::ERR_ABORTED 408 (Request Timeout)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>启动开发服务器后，浏览器出现请求超时错误。是因为 vite 检测到对依赖包的请求，且该依赖尚未被 vite 处理过，这时候会会触发预构建，导致请求超时以及页面重载。</p>\n<p>我们可以多刷新几次等 vite 完成预构建，也可以将依赖加入 <code>optimizeDeps.include</code> 来提前处理。</p>\n<h4 id="_4-3-导入模块出错" tabindex="-1"><a class="header-anchor" href="#_4-3-导入模块出错" aria-hidden="true">#</a> 4.3 导入模块出错</h4>\n<p>报错信息为：</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>Internal server error: Failed to resolve import "./chunk-7L3SPMWF.js" from "node_modules/.vite/antd.js?v=7bec0e27". Does the file exist?\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>可能是因为一些依赖包输出的格式 vite 还不支持，可以看看这个 <a href="https://github.com/vitejs/vite/issues/3308" target="_blank" rel="noopener noreferrer">issue<OutboundLink/></a>。</p>\n<p>这个错误只在开发服务器运行处理过程中存在，待页面正常展示后就不出现了，忽略这个错误之后，目前看也没产生什么影响。</p>\n<h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2>\n<p>总体来说，vite 已经基本具备了生产使用的条件。如果是常规的应用开发，vite 的配置非常简单，可以说是开箱即用。如果需要添加额外的配置也非常方便。</p>\n<p>目前比较大的问题是周边生态还不是特别成熟，很多已经成熟的包对于 vite（ES Modules）的支持比较弱。同时，如果团队内基建氛围比较浓厚的话，自己开发的工具包也要考虑这方面的问题。</p>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-01-13",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/vite-and-microfrontend.html",pathLocale:"/",permalink:"/posts/2022/01/13/vite-and-microfrontend.html",slug:"vite-and-microfrontend",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/vite-and-microfrontend.md",filePathRelative:"posts/vite-and-microfrontend.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/01/13/vite-and-microfrontend.html.vue",componentFilePathRelative:"pages/posts/2022/01/13/vite-and-microfrontend.html.vue",componentFileChunkName:"v-204692c7",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/01/13/vite-and-microfrontend.html.js",dataFilePathRelative:"pages/posts/2022/01/13/vite-and-microfrontend.html.js",dataFileChunkName:"v-204692c7",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2022/01/13/vite-and-microfrontend.html",htmlFilePathRelative:"posts/2022/01/13/vite-and-microfrontend.html"},{key:"v-2cc50f46",path:"/posts/2022/01/28/web-selection.html",title:"网页里的“选中复制”到底选了个啥？",lang:"zh-CN",frontmatter:{title:"网页里的“选中复制”到底选了个啥？",description:"介绍用户选中相关的规范定义，并结合 deeplink 库说明在实际中的使用。",keywords:["selection","range","deeplink","选中"],date:"2022-01-28T00:00:00.000Z",permalinkPattern:"posts/:year/:month/:day/:slug.html",tags:["通用知识"]},excerpt:'<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',headers:[{level:2,title:"如何定义选中的范围",slug:"如何定义选中的范围",children:[{level:3,title:"边界点",slug:"边界点",children:[]},{level:3,title:"范围",slug:"范围",children:[]},{level:3,title:"选中",slug:"选中",children:[]}]},{level:2,title:"deeplinks 中的使用",slug:"deeplinks-中的使用",children:[]}],content:"\n当我们在网页中选中某一段内容的时候，浏览器会添加选中效果来标识选中的范围。我们可以从左到右选，也可以从右到左选。我们可以选择文字，也可以选择图片，或者选择图片加文字。浏览器是如何处理我们的选中操作的呢？\n\n我最近在处理一个网页选中的问题，顺便研究了一下规范中是如何定义选中的，发现还是蛮有趣的，分享一下。\n\n## 如何定义选中的范围\n\n不管是从左到右，还是从右到左，又或者是单单选择一个字，我们都选中了一个范围。范围由两个边界点构成。\n\n### 边界点\n\n规范中是这么定义边界点（boundary point）的：\n\n> A [boundary point](https://dom.spec.whatwg.org/#boundary-points) is a tuple consisting of a node (a node) and an offset (a non-negative integer).\n\n边界点由两部分组成，一个是边界点所在节点（node），另一个是边界点在节点中的偏移量。\n\n```html\n<p>Hello, everfind!</p>\n```\n举个例子，上面的文本中，如果我们选择了 `everfind` 这段，那么边界点就是 `(p, 7)` 和 `(p, 15)`。\n\n边界点之间有三种位置关系：前面、相等和后面。具体的[位置计算方法](https://dom.spec.whatwg.org/#concept-range-bp-position)可以参考规范定义。\n\n\n\n### 范围\n\n范围（[range](https://dom.spec.whatwg.org/#ranges)）由两个边界点来定义，两个边界点被称为开始（start）节点和结束（end）节点。\n\n![range 样例](/posts/images/web-selection/node-tree-c.png)\n\n上图展示了一段 DOM 结构，如果我们选中了 `syndata is awes` 这段文字，那么范围可以表示如下：\n\n```js\nconst range = new Range();\nconst firstText = p.childNodes[1]; // 假设 p 指向 P 元素\nconst secondText = em.firstChild; // 假设 em 指向 EM 元素\nrange.setStart(firstText, 9); // 前面有一个空格\nrange.setEnd(secondText, 4);\n```\n\n注意，在一个范围中，开始节点不能在结束节点的后面。如果开始节点与结束节点相等，则认为范围是折叠的（collapsed）。如果开始节点在结束节点后面，则范围会被强制置为折叠的。\n\n在上面的样例中，我们使用了 `Range` 类，其实还有一个 `StaticRange` 类。`Range` 定义的范围会随着节点树的变化而变化，比如用户节点改变了节点树中的内容，那么通过 `Range` 定义的范围内容也会随着变化。而 `StaticRange` 定义的范围比较轻量，不会随着节点树的变化而变化。\n\n### 选中\n\n定义清楚“范围”以后，就能够定义“选中”这个概念了。在[关于“选中”的规范](https://w3c.github.io/selection-api/)中，规范要求，“选中”是一个单例对象，且只能与一个“范围”对象关联。如果“选中”没有与任何“范围”对象关联，那么“选中”就是空的（empty）。“选中”在初始状态下都是空的。\n\n```typescript\ninterface Selection {\n  readonly attribute Node? anchorNode;\n  readonly attribute unsigned long anchorOffset;\n  readonly attribute Node? focusNode;\n  readonly attribute unsigned long focusOffset;\n  readonly attribute boolean isCollapsed;\n  readonly attribute unsigned long rangeCount;\n  readonly attribute DOMString type;\n  Range getRangeAt(unsigned long index);\n  undefined addRange(Range range);\n  undefined removeRange(Range range);\n  undefined removeAllRanges();\n  ...\n};\n```\n\n上面摘录了一些 [`Selection` 接口](https://w3c.github.io/selection-api/#selection-interface) 的字段说明，我们可以看到，Selection 对象中并不是直接保存 `Range` 对象，而是通过 `anchorNode`、`anchorOffset`、`focusNode`、`focusOffset` 来标识选中的范围。\n\n我们知道，用户选择是有方向的，而 `Range` 中的开始节点与结束节点是严格按照 DOM 顺序的，因此 `Selection` 做了变通。`anchorNode` 是用户开始选择的位置，`focusNode` 是用户结束选择的位置。如果您使用桌面鼠标进行选择，则 `anchorNode` 放置在您按下鼠标按钮的位置，`focusNode` 放置在您释放鼠标按钮的位置。千万不要将 `anchorNode`、`focusNode` 与 `Range` 的开始节点、结束节点相混淆。\n\n> 我们看到，在 `Selection` 接口中定义了一些 `Range` 操作函数，看着像是可以有多个 `Range`。其实 `Selection` API 最初由 Netscape 创建并允许多个范围（例如，允许用户从 `<table>` 中选择一列）。但是，Gecko 以外的浏览器并没有实现多个范围。规范最终要求 `Selection` 始终具有单个 `Range`。\n\n在浏览器中，我们可以通过 `document.getSelection()` 和 `window.getSelection()` 来获取选中的内容，这两个 API 是相等的。通过 `Selection` 接口中定义的操作函数，我们可以动态需改选中的内容。\n\n## deeplinks 中的使用\n\n[deeplinks](https://github.com/WesleyAC/deeplinks) 是一个选中内容分享工具。它通过 `Selection` API，将用户选中的文本计算出一个 hash 值，然后将这个 hash 值放到 URL 中的 fragment 部分。用户打开这个新的 URL 时，deeplinks 会通过 fragment 计算出选中的范围，通过 `Selection` API 高亮选中的文字。\n\n在其核心 API [`selectionToFragment`](https://github.com/WesleyAC/deeplinks/blob/main/src/versions/2.ts#L104) 函数中，\n\n```typescript\nexport function selectionToFragment(selection: Selection): string {\n  type HashNodeOffset = [string, Text, string];\n  type DupeData = [boolean[], number, number];\n  const ranges: [HashNodeOffset, HashNodeOffset, DupeData][] = [];\n  for (let i = 0; i < selection.rangeCount; i++) {\n    const range = normalizeRange(selection.getRangeAt(i)); // normalizeRange 去除非 Text 节点\n    if (range && !range.collapsed) {\n      const [startNode, endNode] = [range.startContainer, range.endContainer];\n      if (startNode.nodeType == TEXT_NODE && endNode.nodeType == TEXT_NODE) {\n        ranges.push([\n          [hashNode(startNode as Text), startNode as Text, fromNumber(Math.max(range.startOffset - countLeadingWhitespace(startNode as Text), 0))],\n          [hashNode(endNode as Text), endNode as Text, fromNumber(Math.max(Math.min(range.endOffset - countLeadingWhitespace(endNode as Text), (endNode as Text).wholeText.trim().length), 0))],\n          [[], 0, 0],\n        ]);\n      }\n    }\n  }\n  ...\n}\n```\n我们可以看到，通过 `selection.getRangeAt(i)` 获取当前选中范围，然后通过一些操作过滤掉非 Text 节点，拿到只包含文本的新的 `Range`。之后经过一些计算，标记出用户选中的真实范围。\n\n> 由于 deeplinks 本身实现逻辑较为复杂，与本篇主题有一些偏离，这里没有详细说明，感兴趣的同学可以自行阅读源码。\n",contentRendered:'<p>当我们在网页中选中某一段内容的时候，浏览器会添加选中效果来标识选中的范围。我们可以从左到右选，也可以从右到左选。我们可以选择文字，也可以选择图片，或者选择图片加文字。浏览器是如何处理我们的选中操作的呢？</p>\n<p>我最近在处理一个网页选中的问题，顺便研究了一下规范中是如何定义选中的，发现还是蛮有趣的，分享一下。</p>\n<h2 id="如何定义选中的范围" tabindex="-1"><a class="header-anchor" href="#如何定义选中的范围" aria-hidden="true">#</a> 如何定义选中的范围</h2>\n<p>不管是从左到右，还是从右到左，又或者是单单选择一个字，我们都选中了一个范围。范围由两个边界点构成。</p>\n<h3 id="边界点" tabindex="-1"><a class="header-anchor" href="#边界点" aria-hidden="true">#</a> 边界点</h3>\n<p>规范中是这么定义边界点（boundary point）的：</p>\n<blockquote>\n<p>A <a href="https://dom.spec.whatwg.org/#boundary-points" target="_blank" rel="noopener noreferrer">boundary point<OutboundLink/></a> is a tuple consisting of a node (a node) and an offset (a non-negative integer).</p>\n</blockquote>\n<p>边界点由两部分组成，一个是边界点所在节点（node），另一个是边界点在节点中的偏移量。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Hello, everfind!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>举个例子，上面的文本中，如果我们选择了 <code>everfind</code> 这段，那么边界点就是 <code>(p, 7)</code> 和 <code>(p, 15)</code>。</p>\n<p>边界点之间有三种位置关系：前面、相等和后面。具体的<a href="https://dom.spec.whatwg.org/#concept-range-bp-position" target="_blank" rel="noopener noreferrer">位置计算方法<OutboundLink/></a>可以参考规范定义。</p>\n<h3 id="范围" tabindex="-1"><a class="header-anchor" href="#范围" aria-hidden="true">#</a> 范围</h3>\n<p>范围（<a href="https://dom.spec.whatwg.org/#ranges" target="_blank" rel="noopener noreferrer">range<OutboundLink/></a>）由两个边界点来定义，两个边界点被称为开始（start）节点和结束（end）节点。</p>\n<p><img src="/posts/images/web-selection/node-tree-c.png" alt="range 样例"></p>\n<p>上图展示了一段 DOM 结构，如果我们选中了 <code>syndata is awes</code> 这段文字，那么范围可以表示如下：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> range <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> firstText <span class="token operator">=</span> p<span class="token punctuation">.</span>childNodes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 假设 p 指向 P 元素</span>\n<span class="token keyword">const</span> secondText <span class="token operator">=</span> em<span class="token punctuation">.</span>firstChild<span class="token punctuation">;</span> <span class="token comment">// 假设 em 指向 EM 元素</span>\nrange<span class="token punctuation">.</span><span class="token function">setStart</span><span class="token punctuation">(</span>firstText<span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 前面有一个空格</span>\nrange<span class="token punctuation">.</span><span class="token function">setEnd</span><span class="token punctuation">(</span>secondText<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>注意，在一个范围中，开始节点不能在结束节点的后面。如果开始节点与结束节点相等，则认为范围是折叠的（collapsed）。如果开始节点在结束节点后面，则范围会被强制置为折叠的。</p>\n<p>在上面的样例中，我们使用了 <code>Range</code> 类，其实还有一个 <code>StaticRange</code> 类。<code>Range</code> 定义的范围会随着节点树的变化而变化，比如用户节点改变了节点树中的内容，那么通过 <code>Range</code> 定义的范围内容也会随着变化。而 <code>StaticRange</code> 定义的范围比较轻量，不会随着节点树的变化而变化。</p>\n<h3 id="选中" tabindex="-1"><a class="header-anchor" href="#选中" aria-hidden="true">#</a> 选中</h3>\n<p>定义清楚“范围”以后，就能够定义“选中”这个概念了。在<a href="https://w3c.github.io/selection-api/" target="_blank" rel="noopener noreferrer">关于“选中”的规范<OutboundLink/></a>中，规范要求，“选中”是一个单例对象，且只能与一个“范围”对象关联。如果“选中”没有与任何“范围”对象关联，那么“选中”就是空的（empty）。“选中”在初始状态下都是空的。</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Selection</span> <span class="token punctuation">{</span>\n  <span class="token keyword">readonly</span> attribute Node<span class="token operator">?</span> anchorNode<span class="token punctuation">;</span>\n  <span class="token keyword">readonly</span> attribute unsigned long anchorOffset<span class="token punctuation">;</span>\n  <span class="token keyword">readonly</span> attribute Node<span class="token operator">?</span> focusNode<span class="token punctuation">;</span>\n  <span class="token keyword">readonly</span> attribute unsigned long focusOffset<span class="token punctuation">;</span>\n  <span class="token keyword">readonly</span> attribute <span class="token builtin">boolean</span> isCollapsed<span class="token punctuation">;</span>\n  <span class="token keyword">readonly</span> attribute unsigned long rangeCount<span class="token punctuation">;</span>\n  <span class="token keyword">readonly</span> attribute DOMString type<span class="token punctuation">;</span>\n  Range <span class="token function">getRangeAt</span><span class="token punctuation">(</span>unsigned long index<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">undefined</span> <span class="token function">addRange</span><span class="token punctuation">(</span>Range range<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">undefined</span> <span class="token function">removeRange</span><span class="token punctuation">(</span>Range range<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">undefined</span> <span class="token function">removeAllRanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>上面摘录了一些 <a href="https://w3c.github.io/selection-api/#selection-interface" target="_blank" rel="noopener noreferrer"><code>Selection</code> 接口<OutboundLink/></a> 的字段说明，我们可以看到，Selection 对象中并不是直接保存 <code>Range</code> 对象，而是通过 <code>anchorNode</code>、<code>anchorOffset</code>、<code>focusNode</code>、<code>focusOffset</code> 来标识选中的范围。</p>\n<p>我们知道，用户选择是有方向的，而 <code>Range</code> 中的开始节点与结束节点是严格按照 DOM 顺序的，因此 <code>Selection</code> 做了变通。<code>anchorNode</code> 是用户开始选择的位置，<code>focusNode</code> 是用户结束选择的位置。如果您使用桌面鼠标进行选择，则 <code>anchorNode</code> 放置在您按下鼠标按钮的位置，<code>focusNode</code> 放置在您释放鼠标按钮的位置。千万不要将 <code>anchorNode</code>、<code>focusNode</code> 与 <code>Range</code> 的开始节点、结束节点相混淆。</p>\n<blockquote>\n<p>我们看到，在 <code>Selection</code> 接口中定义了一些 <code>Range</code> 操作函数，看着像是可以有多个 <code>Range</code>。其实 <code>Selection</code> API 最初由 Netscape 创建并允许多个范围（例如，允许用户从 <code>&lt;table&gt;</code> 中选择一列）。但是，Gecko 以外的浏览器并没有实现多个范围。规范最终要求 <code>Selection</code> 始终具有单个 <code>Range</code>。</p>\n</blockquote>\n<p>在浏览器中，我们可以通过 <code>document.getSelection()</code> 和 <code>window.getSelection()</code> 来获取选中的内容，这两个 API 是相等的。通过 <code>Selection</code> 接口中定义的操作函数，我们可以动态需改选中的内容。</p>\n<h2 id="deeplinks-中的使用" tabindex="-1"><a class="header-anchor" href="#deeplinks-中的使用" aria-hidden="true">#</a> deeplinks 中的使用</h2>\n<p><a href="https://github.com/WesleyAC/deeplinks" target="_blank" rel="noopener noreferrer">deeplinks<OutboundLink/></a> 是一个选中内容分享工具。它通过 <code>Selection</code> API，将用户选中的文本计算出一个 hash 值，然后将这个 hash 值放到 URL 中的 fragment 部分。用户打开这个新的 URL 时，deeplinks 会通过 fragment 计算出选中的范围，通过 <code>Selection</code> API 高亮选中的文字。</p>\n<p>在其核心 API <a href="https://github.com/WesleyAC/deeplinks/blob/main/src/versions/2.ts#L104" target="_blank" rel="noopener noreferrer"><code>selectionToFragment</code><OutboundLink/></a> 函数中，</p>\n<div class="language-typescript ext-ts line-numbers-mode"><pre v-pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">selectionToFragment</span><span class="token punctuation">(</span>selection<span class="token operator">:</span> Selection<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>\n  <span class="token keyword">type</span> <span class="token class-name">HashNodeOffset</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> Text<span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">type</span> <span class="token class-name">DupeData</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> ranges<span class="token operator">:</span> <span class="token punctuation">[</span>HashNodeOffset<span class="token punctuation">,</span> HashNodeOffset<span class="token punctuation">,</span> DupeData<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>rangeCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> range <span class="token operator">=</span> <span class="token function">normalizeRange</span><span class="token punctuation">(</span>selection<span class="token punctuation">.</span><span class="token function">getRangeAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// normalizeRange 去除非 Text 节点</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>range <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>range<span class="token punctuation">.</span>collapsed<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> <span class="token punctuation">[</span>startNode<span class="token punctuation">,</span> endNode<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>range<span class="token punctuation">.</span>startContainer<span class="token punctuation">,</span> range<span class="token punctuation">.</span>endContainer<span class="token punctuation">]</span><span class="token punctuation">;</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>startNode<span class="token punctuation">.</span>nodeType <span class="token operator">==</span> <span class="token constant">TEXT_NODE</span> <span class="token operator">&amp;&amp;</span> endNode<span class="token punctuation">.</span>nodeType <span class="token operator">==</span> <span class="token constant">TEXT_NODE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        ranges<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n          <span class="token punctuation">[</span><span class="token function">hashNode</span><span class="token punctuation">(</span>startNode <span class="token keyword">as</span> Text<span class="token punctuation">)</span><span class="token punctuation">,</span> startNode <span class="token keyword">as</span> Text<span class="token punctuation">,</span> <span class="token function">fromNumber</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>range<span class="token punctuation">.</span>startOffset <span class="token operator">-</span> <span class="token function">countLeadingWhitespace</span><span class="token punctuation">(</span>startNode <span class="token keyword">as</span> Text<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n          <span class="token punctuation">[</span><span class="token function">hashNode</span><span class="token punctuation">(</span>endNode <span class="token keyword">as</span> Text<span class="token punctuation">)</span><span class="token punctuation">,</span> endNode <span class="token keyword">as</span> Text<span class="token punctuation">,</span> <span class="token function">fromNumber</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>range<span class="token punctuation">.</span>endOffset <span class="token operator">-</span> <span class="token function">countLeadingWhitespace</span><span class="token punctuation">(</span>endNode <span class="token keyword">as</span> Text<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>endNode <span class="token keyword">as</span> Text<span class="token punctuation">)</span><span class="token punctuation">.</span>wholeText<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n          <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n        <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>我们可以看到，通过 <code>selection.getRangeAt(i)</code> 获取当前选中范围，然后通过一些操作过滤掉非 Text 节点，拿到只包含文本的新的 <code>Range</code>。之后经过一些计算，标记出用户选中的真实范围。</p>\n<blockquote>\n<p>由于 deeplinks 本身实现逻辑较为复杂，与本篇主题有一些偏离，这里没有详细说明，感兴趣的同学可以自行阅读源码。</p>\n</blockquote>\n<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align: center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />关注微信公众号，获取最新推送~</p><p style="text-align: center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;" />加微信，深入交流~</p></div>',date:"2022-01-28",deps:[],hoistedTags:[],links:[],pathInferred:"/posts/web-selection.html",pathLocale:"/",permalink:"/posts/2022/01/28/web-selection.html",slug:"web-selection",filePath:"/Users/bingooo/workspace/everfind/website/docs/posts/web-selection.md",filePathRelative:"posts/web-selection.md",componentFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/01/28/web-selection.html.vue",componentFilePathRelative:"pages/posts/2022/01/28/web-selection.html.vue",componentFileChunkName:"v-2cc50f46",dataFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/.temp/pages/posts/2022/01/28/web-selection.html.js",dataFilePathRelative:"pages/posts/2022/01/28/web-selection.html.js",dataFileChunkName:"v-2cc50f46",htmlFilePath:"/Users/bingooo/workspace/everfind/website/docs/.vuepress/dist/posts/2022/01/28/web-selection.html",htmlFilePathRelative:"posts/2022/01/28/web-selection.html"}]}},4071:(n,s,a)=>{a.r(s),a.d(s,{default:()=>o});var e=a(6252);const t=(0,e.Wm)("div",{class:"custom-container tip"},[(0,e.Wm)("p",{class:"custom-container-title"},"TIP"),(0,e.Wm)("p",null,"大道至简，千里之行始于足下。")],-1),p=(0,e.uE)('<div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div>',1),o={render:function(n,s){const a=(0,e.up)("ArticleList");return(0,e.wg)(),(0,e.j4)(e.HY,null,[t,(0,e.Wm)(a),p],64)}}}}]);