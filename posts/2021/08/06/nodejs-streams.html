<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.webmanifest"><meta name="theme-color" content="#5397d2"><script>
      var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e772d8d7735057378a672ae311e9bf20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
    </script><title>图解 NodeJS 流 | 众里千寻</title><meta name="description" content="以图形化的形式，介绍 NodeJS 中流的类型、工作原理，以及如何使用流。"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.fa50ff6a.js" as="script"><link rel="preload" href="/assets/css/styles.e0095a00.css" as="style"><link rel="preload" href="/assets/js/3767.b5b9e7ce.js" as="script"><link rel="preload" href="/assets/js/app.8de2a662.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.e0095a00.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><img class="logo" src="/hero-c.png" alt="众里千寻"><span class="site-name can-hide">众里千寻</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link router-link-active" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link router-link-active" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">图解 NodeJS 流</p><ul class=""><li><!--[--><a aria-current="page" href="/posts/2021/08/06/nodejs-streams.html#水流-信息流" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="水流，信息流"><!--[--><!--]--> 水流，信息流 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/06/nodejs-streams.html#可读流-readable-stream" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="可读流（Readable Stream）"><!--[--><!--]--> 可读流（Readable Stream） <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/06/nodejs-streams.html#可写流-writable-stream" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="可写流（Writable Stream）"><!--[--><!--]--> 可写流（Writable Stream） <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/06/nodejs-streams.html#双工流-duplex-streams" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="双工流（Duplex Streams）"><!--[--><!--]--> 双工流（Duplex Streams） <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/06/nodejs-streams.html#转换流-transform-stream" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="转换流（Transform Stream）"><!--[--><!--]--> 转换流（Transform Stream） <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/06/nodejs-streams.html#管道-pipe" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="管道（Pipe）"><!--[--><!--]--> 管道（Pipe） <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/posts/2021/08/06/nodejs-streams.html#使用流复制数据" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="使用流复制数据"><!--[--><!--]--> 使用流复制数据 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/06/nodejs-streams.html#高水位线控制-highwatermark" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="高水位线控制（highWaterMark）"><!--[--><!--]--> 高水位线控制（highWaterMark） <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/06/nodejs-streams.html#流的应用" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="流的应用"><!--[--><!--]--> 流的应用 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><p>假设我们现在要盖一座房子，我们买了一些砖块，厂家正在送货。现在我们有两个选择，一是等所有砖块都到了以后再开始动工；二是到一批砖块就开始动工，砖块到多少我们就用多少。</p><p>这两种方式哪种效率更高呢？显然是第二种。这就是流（stream）的理念。在计算机科学中，流是随时间可用的一系列数据元素。就像传送带运输物品一样，使用流可以实现一次处理一个数据元素。</p><p>在 NodeJS 中，<a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener noreferrer">stream<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 模块实现了流的功能。即使我们没有直接使用过这个模块，我们也间接使用过流，比如读写文件、网络等。</p><h2 id="水流-信息流" tabindex="-1"><a class="header-anchor" href="#水流-信息流" aria-hidden="true">#</a> 水流，信息流</h2><p>信息就像水流一样，以比特流（strem of bits）的形式从一个地方流到另一个地方。比如读取文件，信息就从磁盘流向了应用程序。</p><p>但是，流的两端处理信息的速度是不同的，通常流的一端会比另一端要慢，因此就需要一个缓存来作为缓冲（buffer）。</p><p>如下图所示，上面的水龙头水流较大，下面的水龙头水流较小，因此需要一个容器来暂时存储下面的水龙头来不及处理的水。</p><p><img src="/posts/images/node-streams/stream-c.png" alt="流与缓存"></p><p>NodeJS 中流的基本原理也是这样的，stream 模块实现了这些能力。</p><p>在 NodeJS 中有两种基本的流可以使用：</p><ul><li>可读流（Readable Streams）</li><li>可写流（Writable Streams）</li></ul><p>同时还有两种读写混合的流：</p><ul><li>双工流（Duplex Streams）-- 可读可写的流</li><li>转换流（Transform Streams）-- 可以转换数据的双工流</li></ul><h2 id="可读流-readable-stream" tabindex="-1"><a class="header-anchor" href="#可读流-readable-stream" aria-hidden="true">#</a> 可读流（Readable Stream）</h2><p>可读流可以从一个地方读取数据，比如从文件中读取信息。读取的数据可以暂时存放在可读流中的<a href="https://nodejs.org/api/stream.html#stream_buffering" target="_blank" rel="noopener noreferrer">缓存（Buffer）<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>里，防止应用程序无法及时处理。</p><p><img src="/posts/images/node-streams/readable-c.png" alt="可读流"></p><p>常见的可读流有 <a href="https://nodejs.org/api/process.html#process_process_stdin" target="_blank" rel="noopener noreferrer"><code>process.stdin</code><span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>、<a href="https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options" target="_blank" rel="noopener noreferrer"><code>fs.createReadStream</code><span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 以及 HTTP 服务中的 <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage" target="_blank" rel="noopener noreferrer"><code>IncomingMessage</code><span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 对象。</p><h2 id="可写流-writable-stream" tabindex="-1"><a class="header-anchor" href="#可写流-writable-stream" aria-hidden="true">#</a> 可写流（Writable Stream）</h2><p>可写流可以将数据写到一个地方，比如将数据写入文件中。为了防止因为写入目标处理速度太慢导致数据丢失，写入的数据可以暂存在可写流内部的缓存（Buffer）中。</p><p><img src="/posts/images/node-streams/writable-c.png" alt="可写流"></p><p>常用的可写流有 <a href="https://nodejs.org/api/process.html#process_process_stdout" target="_blank" rel="noopener noreferrer"><code>process.stdout</code><span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>、<a href="https://nodejs.org/api/process.html#process_process_stderr" target="_blank" rel="noopener noreferrer"><code>process.stderr</code><span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 和 <a href="https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options" target="_blank" rel="noopener noreferrer"><code>fs.createWriteStream</code><span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p><h2 id="双工流-duplex-streams" tabindex="-1"><a class="header-anchor" href="#双工流-duplex-streams" aria-hidden="true">#</a> 双工流（Duplex Streams）</h2><p>双工流是可读流和可写流的混合体。连接到双工流之后，应用程序既可以从流中读取数据，也可以向流中写入数据。在双工流中，可读流和可写流有各自独立的缓存（Buffer）。</p><p><img src="/posts/images/node-streams/duplex-c.png" alt="双工流"></p><p>最常用的双工流就是 <a href="https://nodejs.org/api/net.html#net_class_net_socket" target="_blank" rel="noopener noreferrer"><code>net.Socket</code><span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>。</p><h2 id="转换流-transform-stream" tabindex="-1"><a class="header-anchor" href="#转换流-transform-stream" aria-hidden="true">#</a> 转换流（Transform Stream）</h2><p>转换流是更加特殊的混合流，在转换流中，可读流是通过某种方式连接到可写流上的。</p><p><img src="/posts/images/node-streams/transform-c.png" alt="转换流"></p><p>最常见的转换流是有 <a href="https://nodejs.org/api/stream.html#stream_buffering" target="_blank" rel="noopener noreferrer"><code>Cipher</code><span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 创建的流。在这个流中，应用程序写入数据，然后再从流中读取加密后的数据。</p><h2 id="管道-pipe" tabindex="-1"><a class="header-anchor" href="#管道-pipe" aria-hidden="true">#</a> 管道（Pipe）</h2><p>通常流在连接到一起之后才能发挥更大的作用。我们通过管道来连接流。</p><p>比如我们可以将一个可读流连接到一个可写流或者双工流上，仅仅使用可读流的 <code>pipe()</code> 方法即可。</p><p>常见的管道场景就是复制文件。将 <code>fs.createReadStream()</code> 创建的流通过 <code>pipe()</code> 方法连接到 <code>fs.createWriteStream()</code> 创建的流上去。</p><h3 id="使用流复制数据" tabindex="-1"><a class="header-anchor" href="#使用流复制数据" aria-hidden="true">#</a> 使用流复制数据</h3><p>我们可以将流连接到多个其他流上。这在一些需要重复读取原始数据的场景中非常有用。因为可读流只能读取一次数据，因此我们可以通过 <code>pipe()</code> 方法将可读流连接到多个流上，这样这些被连接的流就可以直接消费数据，不需要创建多个可读流。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> original <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">&#39;./original.txt&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> copy1 <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">&#39;./copy1.txt&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> copy2 <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">&#39;./copy2.txt&#39;</span><span class="token punctuation">)</span>

original<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>copy1<span class="token punctuation">)</span>
original<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>copy2<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><img src="/posts/images/node-streams/copy-file-c.png" alt="使用流复制数据"></p><h2 id="高水位线控制-highwatermark" tabindex="-1"><a class="header-anchor" href="#高水位线控制-highwatermark" aria-hidden="true">#</a> 高水位线控制（highWaterMark）</h2><p>在最开始的例子中，我们通过水箱蓄水的例子描述了流的缓存特性。因为上方的水流始终比下方的水流快，水箱中的水越来越多，终究会超过水箱的容积而溢出。</p><p>因此我们需要一个高水位警戒线，当水箱中的水位高于这个警戒线的时候，就需要通知上方的水龙头暂时停止放水了。</p><p><img src="/posts/images/node-streams/high-water-mark-c.png" alt="高水位线控制"></p><p>在流中也是同样的原理，可读流和可写流内部都有缓存，这些缓存的最大可存储量是系统的可用内存量。NodeJS 流通过 <code>highWaterMark</code> 这个配置项来控制缓存中的水位线。</p><p>举个例子，如下图，可读流连接到可写流之后，可写流通过 <code>highWaterMark</code> 来检测缓存中的水位是否过高，高于这条线之后，可写流会通知可读流暂停写入数据。</p><p><img src="/posts/images/node-streams/read-write-high-water-mark-c.png" alt="高水位线控制"></p><p>需要注意的是，<code>highWaterMark</code> 只是一个警示线，并不是一个硬性约束条件。也就是说，如果自定义的流没有正确处理这个警示线的话，可能会导致数据丢失。</p><h2 id="流的应用" tabindex="-1"><a class="header-anchor" href="#流的应用" aria-hidden="true">#</a> 流的应用</h2><p>我们来举个例子综合说明如何使用流。</p><p>假设我们有一个裁减图片的应用程序。用户将图片的地址告诉应用程序，应用程序从网络上读取原始图片，裁减之后再返回给用户。那么我们可以借助于流来实现这个应用程序的功能，如下图。</p><p><img src="/posts/images/node-streams/stream-usage-c.png" alt="裁减图片的应用"></p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><!----><!--[--><!--]--></main></div><!----><!----><!--]--></div>
    <script src="/assets/js/runtime~app.fa50ff6a.js" defer></script><script src="/assets/js/3767.b5b9e7ce.js" defer></script><script src="/assets/js/app.8de2a662.js" defer></script>
  </body>
</html>
