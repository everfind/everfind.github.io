<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.webmanifest"><meta name="theme-color" content="#5397d2"><script>
      var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e772d8d7735057378a672ae311e9bf20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
    </script><title>NodeJS 的事件循环详解 | 众里千寻</title><meta name="description" content="什么是 NodeJS 的事件循环？事件循环是如何工作的？setTimeout 和 setImmediate 如何工作？"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.fa50ff6a.js" as="script"><link rel="preload" href="/assets/css/styles.e0095a00.css" as="style"><link rel="preload" href="/assets/js/3767.b5b9e7ce.js" as="script"><link rel="preload" href="/assets/js/app.8de2a662.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.e0095a00.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><img class="logo" src="/hero-c.png" alt="众里千寻"><span class="site-name can-hide">众里千寻</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link router-link-active" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link router-link-active" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">NodeJS 的事件循环详解</p><ul class=""><li><!--[--><a aria-current="page" href="/posts/2021/08/15/nodejs-event-loop.html#libuv-的事件循环" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="libuv 的事件循环"><!--[--><!--]--> libuv 的事件循环 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/15/nodejs-event-loop.html#nodejs-的事件循环" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="NodeJS 的事件循环"><!--[--><!--]--> NodeJS 的事件循环 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/15/nodejs-event-loop.html#setimmediate、settimeout-和-process-nexttick" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="setImmediate、setTimeout 和 process.nextTick"><!--[--><!--]--> setImmediate、setTimeout 和 process.nextTick <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/15/nodejs-event-loop.html#promise" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Promise"><!--[--><!--]--> Promise <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/08/15/nodejs-event-loop.html#总结" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><p>事件循环是 NodeJS 处理非阻塞 I/O 操作的和核心机制。NodeJS 的事件循环脱胎于 <a href="http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop" target="_blank" rel="noopener noreferrer">libuv<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 的事件循环，因此，要搞清楚 NodeJS 的事件循环，还需要先了解 libuv 的事件循环是如何工作的。</p><h2 id="libuv-的事件循环" tabindex="-1"><a class="header-anchor" href="#libuv-的事件循环" aria-hidden="true">#</a> libuv 的事件循环</h2><p>我们先来了解两个基本概念：句柄（handle）和请求（request）.</p><ul><li>句柄是指在整个事件循环活跃时间内能够执行某些操作的长期对象。比如一个 TCP 服务句柄，每当有新的联接建立时，这个句柄的 <code>connected</code> 回调就会被调用。</li><li>请求是通常指短期操作。比如向某个句柄中写入数据的操作。</li></ul><p>了解了这两个概念以后，我们来看看 libuv 的事件循环是如何工作的。</p><p>下面这张图可以清楚的展示事件循环的执行过程：</p><p><img src="/posts/images/nodejs-event-loop/libuv-loop-c.png" alt="libuv 的事件循环"></p><p>结合这张图我们简单描述一下一次循环过程中各个步骤做了什么。</p><ol><li>首先更新循环内的当前时间（now），避免在循环过程中多次发生与时间相关的系统调用。</li><li>检查当前事件循环是否还是活跃（active）的。检查的表示是当前事件循环是否还有活跃的句柄、活跃的请求操作，或者还有“关闭”回调的话，就视为是活跃的。如果判断当前循环不是活跃的，则直接退出。</li><li>执行所有的到期回调。即所有的到期时间在循环当前时间之前的回调都会被执行。</li><li>执行所有的挂起回调（pending callbacks）。所谓挂起回调，就是在上一个循环周期中设置的到下一循环周期在执行的回调。</li><li>执行空闲句柄回调（idle handle callbacks）。虽然名字中包含空闲二字，实际上每个循环周期都会执行。</li><li>执行准备句柄回调（prepare handle callbacks）。</li><li>在这一步会暂停循环，轮询等待 I/O 事件一段时间。这个时间长度是根据一个算法算出，这里不做详细说明。在轮询期间，所有 I/O 相关的回调会被执行（前提是系统通知到 libuv）。</li><li>执行检查句柄回调（check handle callbacks）。检查句柄回调往往与准备句柄回调相对应。这两个回调可以方便我们在 I/O 之前做一些准备工作，然后在 I/O 之后做相应的检查。</li><li>执行关闭回调（close callbacks）。比如通过 <code>uv_close()</code> 设置的回调。</li></ol><p>整个事件循环就是 1 - 9 的循环执行。</p><p>值得说明的是，libuv 会在轮询阶段中断事件循环，等待系统通知。比如某个文件 I/O 已经完成，或者接收到一个网络连接等。在接收到系统通知后，事件循环会调用相关的回调执行操作。</p><p>不同的平台（windows\linux 等），异步 I/O 的机制不同，libuv 底层会根据不同平台，采用不同的 I/O 轮询机制，比如 epoll（linux）、kqueue（OSX）、IOCP（windows）等，上层不需要关注异步 I/O 的实现机制。</p><h2 id="nodejs-的事件循环" tabindex="-1"><a class="header-anchor" href="#nodejs-的事件循环" aria-hidden="true">#</a> NodeJS 的事件循环</h2><p>现在我们来看 NodeJS 的事件循环。同样，我们放一张 NodeJS 事件循环的过程图。</p><p><img src="/posts/images/nodejs-event-loop/nodejs-loop-c.png" alt="NodeJS 的事件循环"></p><p>在 NodeJS 中，事件循环的每一步成为一个阶段，每个阶段都有一个 FIFO 队列来执行回调。通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列清空或达到最大回调数限制。当队列清空或者达到最大限制，事件循环进入下一阶段。</p><p>对比两个事件循环的图，我们可以看到，具体过程基本相同。因此，NodeJS 的事件循环过程我们简述如下：</p><ol><li>定时器阶段，执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 调度的回调函数。</li><li>挂起的回调，执行（在上一个循环中被设置）延迟到下一个循环迭代的 I/O 回调。</li><li>idle, prepare 阶段，仅 NodeJS 系统内部使用。</li><li>轮询阶段，检索新的 I/O 事件，执行与 I/O 相关的回调。与 libuv 一样，NodeJS 还在这个阶段暂停循环一段时间。</li><li>检测阶段，执行被 <code>setImmediate()</code> 调度的回调函数。</li><li>关闭的回调函数，执行一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code>。</li></ol><p>我们对轮询阶段做个详细说明。</p><p>轮询阶段有两个重要的功能：</p><ul><li>计算应该阻塞和轮询 I/O 的时间。</li><li>处理轮询队列里的事件。</li></ul><p>一旦事件循环进入轮询阶段并且没有到期的定时器回调时，事件循环将做如下判断：</p><ul><li>如果轮询队列不是空的，那么事件循环将循环访问回调队列并同步执行它们，直到清空队列，或者达到了最大限制。</li><li>如果轮询队列是空的，则再做如下判断： <ul><li>如果有代码是被 <code>setImmediate()</code> 调度的，那么事件循环将结束轮询阶段，并到检查阶段以执行那些被调度的代码。</li><li>如果没有代码被 <code>setImmediate()</code> 调度，那么事件循环将等待回调被添加到队列中，然后立即执行。</li></ul></li></ul><p>在轮询阶段的执行过程中，一旦轮询队列为空，事件循环将检查是否有到期的定制器。如果一个或多个定时器已准备就绪，则事件循环将绕回定时器阶段以执行这些定时器的回调。</p><p>这里要特别对 <code>setImmediate()</code> 进行一些说明。</p><p>在 libuv 的事件循环中，允许开发人员在轮询阶段之前做些准备操作，然后在轮询阶段之后立即对这些操作进行检查。NodeJS 中 <code>setImmediate()</code> 实际上是一个在事件循环的单独阶段运行的特殊定时器。它使用一个 libuv API 来安排回调在轮询阶段完成后执行。</p><h2 id="setimmediate、settimeout-和-process-nexttick" tabindex="-1"><a class="header-anchor" href="#setimmediate、settimeout-和-process-nexttick" aria-hidden="true">#</a> <code>setImmediate</code>、<code>setTimeout</code> 和 <code>process.nextTick</code></h2><ul><li><code>setImmediate()</code> 被设计为一旦在当前轮询阶段完成，就执行代码。</li><li><code>setTimeout()</code> 是在最小阈值（ms 单位）过后执行代码。</li><li><code>process.nextTick()</code> 严格意义上讲并不属于事件循环的一部分。它不管事件循环的当前阶段如何，它都将在当前操作完成后处理 <code>nextTickQueue</code> 中排队的代码。</li></ul><p><code>setImmediate()</code> 和 <code>setTimeout()</code> 很类似，但是基于被调用的时机，他们也有不同表现。</p><p>我们看下面这段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;timeout&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;immediate&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这两个函数调用都在主模块中被调用，则他们的回调执行顺序是不定的，受进程的性能影响很大(进程会受到系统中运行其他应用程序影响)。</p><p>但是一旦将这两个函数放到 I/O 轮询调用内，那么 <code>setImmediate()</code> 一定会在 <code>setTimeout()</code> 之前被执行，不管有多个定制器已经到期。比如下面这段代码，总是会先输出 &quot;immediate&quot;。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;timeout&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;immediate&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>process.nextTick()</code> 和 <code>setImmediate()</code> 严格意义上来说，应该将名称互换。因为 <code>process.nextTick()</code> 比 <code>setImmediate()</code> 触发得更快。</p><p>任何时候在给定的阶段中调用 <code>process.nextTick()</code>，所有传递到 <code>process.nextTick()</code> 的回调将在事件循环继续之前解析。之所以这么设计，是考虑到这些使用场景：</p><ul><li>允许开发者处理错误，清理任何不需要的资源，或者在事件循环继续之前重试请求。</li><li>有时有让回调在栈展开后，但在事件循环继续之前运行的必要。</li></ul><p>比如下面这段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;listening&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>只有传递端口时，端口才会立即被绑定，然后立即调用 <code>&#39;listening&#39;</code> 回调。问题是 <code>.on(&#39;listening&#39;)</code> 的回调在那个时间点尚未被设置。</p><p>为了绕过这个问题，<code>&#39;listening&#39;</code> 事件被排在 <code>nextTick()</code> 中，以允许脚本运行完成。这让用户设置所想设置的任何事件处理器。</p><h2 id="promise" tabindex="-1"><a class="header-anchor" href="#promise" aria-hidden="true">#</a> Promise</h2><p>这里在补充说明一下 NodeJS 中 Promise 是如何处理的。我们之前说过，在浏览器的事件循环里，会有一个微任务的队列来防止所有的微任务，并且在每个操作之后，都尝试清空微任务队列。</p><p>在 NodeJS 中，做法类似，NodeJS 的事件循环中也有一个微任务队列，工作机制与 <code>process.nextTick()</code> 类似，在每个操作之后，事件循环都会尝试清空微任务队列。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>我们结合 libuv 的事件循环，详细说明了 NodeJS 事件循环的每一阶段的具体职能。同时，我们还分析了常用的几个异步代码函数的原理。</p><p>我们用一张图归纳如下：</p><p><img src="/posts/images/nodejs-event-loop/event-loop-c.png" alt="事件循环"></p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><!----><!--[--><!--]--></main></div><!----><!----><!--]--></div>
    <script src="/assets/js/runtime~app.fa50ff6a.js" defer></script><script src="/assets/js/3767.b5b9e7ce.js" defer></script><script src="/assets/js/app.8de2a662.js" defer></script>
  </body>
</html>
