<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.webmanifest"><meta name="theme-color" content="#5397d2"><script>
      var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e772d8d7735057378a672ae311e9bf20";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
    </script><title>NodeJS 进程是如何退出的 | 众里千寻</title><meta name="description" content="描述导致 NodeJS 进程退出的几种情况，以及如何处理。"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.fa50ff6a.js" as="script"><link rel="preload" href="/assets/css/styles.e0095a00.css" as="style"><link rel="preload" href="/assets/js/3767.b5b9e7ce.js" as="script"><link rel="preload" href="/assets/js/app.8de2a662.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.e0095a00.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><img class="logo" src="/hero-c.png" alt="众里千寻"><span class="site-name can-hide">众里千寻</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link router-link-active" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/courses/" class="nav-link" aria-label="学习笔记"><!--[--><!--]--> 学习笔记 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/solutions/" class="nav-link" aria-label="解决方案"><!--[--><!--]--> 解决方案 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/tools/" class="nav-link" aria-label="开发利器"><!--[--><!--]--> 开发利器 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/code-reading/" class="nav-link" aria-label="源码解读"><!--[--><!--]--> 源码解读 <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/posts/" class="nav-link router-link-active" aria-label="最新消息"><!--[--><!--]--> 最新消息 <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/everfind" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item">NodeJS 进程是如何退出的</p><ul class=""><li><!--[--><a aria-current="page" href="/posts/2021/07/06/how-process-exit.html#主动退出" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="主动退出"><!--[--><!--]--> 主动退出 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/07/06/how-process-exit.html#exceptions-rejections-和-emitted-errors" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="Exceptions, Rejections 和 Emitted Errors"><!--[--><!--]--> Exceptions, Rejections 和 Emitted Errors <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/07/06/how-process-exit.html#信号" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="信号"><!--[--><!--]--> 信号 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/posts/2021/07/06/how-process-exit.html#小结" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="小结"><!--[--><!--]--> 小结 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><p>有几种因素可以导致 NodeJS 进程退出。在这些因素中，有些是可预防的，比如代码抛出了一个异常；有些是不可预防的，比如内存耗尽。<code>process</code> 这个全局变量是一个 Event Emitter 实例，如果进程优雅退出，<code>process</code> 会派发一个 <code>exit</code> 事件。应用代码可以监听这个事件，来做最后的清理工作。</p><p>下面的表格列举了可以导致进程退出的因素。</p><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">举例</th></tr></thead><tbody><tr><td style="text-align:left;">手动退出</td><td style="text-align:left;"><code>process.exit(1)</code></td></tr><tr><td style="text-align:left;">未捕获的异常</td><td style="text-align:left;"><code>throw new Error()</code></td></tr><tr><td style="text-align:left;">未处理的 promise rejection</td><td style="text-align:left;"><code>Promise.reject()</code></td></tr><tr><td style="text-align:left;">未处理的 error 事件</td><td style="text-align:left;"><code>EventEmitter#emit(&#39;error&#39;)</code></td></tr><tr><td style="text-align:left;">未处理的信号</td><td style="text-align:left;"><code>kill &lt;PROCESS_ID&gt;</code></td></tr></tbody></table><h2 id="主动退出" tabindex="-1"><a class="header-anchor" href="#主动退出" aria-hidden="true">#</a> 主动退出</h2><p><code>process.exit(code)</code> 是最直接的结束进程的方法。<code>code</code> 参数是可选的，可以为 0 ~ 255 之间任何数字，默认为 0。0 表示进程执行成功，非 0 数字表示进程执行失败。</p><p>当 <code>process.exit()</code> 被使用时，控制台不会有任何输出，如果我们想在进程推出的时候像控制台输出一些错误说明信息，则需要在调用之前显示的输出错误信息。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>node -e <span class="token string">&quot;process.exit(42)&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面的代码直接退出了 NodeJS 进程，命令行没有任何输出信息。用户在遭遇进程退出的时候，无法获取有效的错误信息。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">checkConfig</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>config<span class="token punctuation">.</span>host<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;Configuration is missing &#39;host&#39; parameter!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上面的代码中，我们在进程退出之前输出的明确的错误信息。</p><p><code>process.exit()</code> 的功能非常强大，但是我们不应该在工具库中使用。如果在工具库中遇到的错误，我们应该以异常的形式抛出，从而让应用代码决定如何处理这个错误。</p><h2 id="exceptions-rejections-和-emitted-errors" tabindex="-1"><a class="header-anchor" href="#exceptions-rejections-和-emitted-errors" aria-hidden="true">#</a> Exceptions, Rejections 和 Emitted Errors</h2><p><code>process.exit()</code> 在应用启动配置检查等场景中非常有用，但是在处理运行时异常时，它并不适用，我们需要其他的工具。</p><p>比如当应用在处理一个 HTTP 请求时，一个错误不应该导致进程终止，相反，我们应该返回一个含有错误信息的响应。</p><p><code>Error</code> 类可以包含描述错误发生的详细信息的数据，比如调用堆栈和错误文本。通常我们会定义特定场景的 XXXError，这些 XXXError 都继承制 <code>Error</code> 类。</p><p>当我们使用 <code>throw</code> 关键字，或者代码逻辑出错时，一个错误就会被抛出。此时，系统调用栈会释放，每个函数会退出，直到遇到一个 包裹了当前调用的 try/catch 语句。如果没有 try/catch 语句，则这个错误会被认为是未捕获的异常。</p><blockquote><p>通常，在 NodeJS 应用中，我们会给 Error 类定义一个 <code>code</code> 属性，作为用来描述具体错误的错误码，这么做的优点是可以使错误码保持唯一，同时还能使得错误码是可读的。同时，我们也可以配合 <code>message</code> 属性来描述具体的错误信息。</p></blockquote><p>当一个未捕获的异常抛出时，控制台会打印调用堆栈，同时进程退出，退出状态码为 1.</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/tmp/foo.js:1
throw new TypeError(&#39;invalid foo&#39;);
^
Error: invalid foo
    at Object.&lt;anonymous&gt; (/tmp/foo.js:2:11)
    ... TRUNCATED ...
    at internal/main/run_main_module.js:17:47
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这段控制台输出信息说明，错误发生在 <code>foo.js</code> 中的第 2 行第 11 列。</p><p>全局变量 <code>process</code> 是个 Event Emitter 实例，可以通过监听 <code>uncaughtException</code> 事件来处理这些未捕获异常。下面的代码展示了如何使用：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> logger <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./lib/logger.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;uncaughtException&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  logger<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;An uncaught exception has occured&quot;</span><span class="token punctuation">,</span> error<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Promise Rejection 与抛出异常类似。我们可以通过调用 <code>reject()</code> 函数或者在 <code>async</code> 函数中抛出异常来是的 promise 到达 rejected 状态。下面的两段代码功能是相似的。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;oh no&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;oh no&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>目前，在 NodeJS 14 中，Promise Rejection 不会导致进程退出，在后续的版本中，Promise Rejection 可能会导致进程退出。</p><p>下面是一段未捕获的 Promise Rejection 的控制台输出样例。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>(node:52298) UnhandledPromiseRejectionWarning: Error: oh no
    at Object.&lt;anonymous&gt; (/tmp/reject.js:1:16)
    ... TRUNCATED ...
    at internal/main/run_main_module.js:17:47
(node:52298) UnhandledPromiseRejectionWarning: Unhandled promise
  rejection. This error originated either by throwing inside of an
  async function without a catch block, or by rejecting a promise
  which was not handled with .catch().
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>我们可以通过监听 <code>unhandledRejection</code> 事件来处理未捕获的 Rejection. 样例代码如下：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;unhandledRejection&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">reason<span class="token punctuation">,</span> promise</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Event Emitter 是 NodeJS 中的基础模块，应用广泛。当 Event Emitter 的 <code>error</code> 事件未被处理时，Event Emitter 就会抛出一个错误，同时会导致进程退出。下面是一个 Event Emitter <code>error</code> 的控制台输出。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>events.js:306
    throw err; // Unhandled &#39;error&#39; event
    ^
Error [ERR_UNHANDLED_ERROR]: Unhandled error. (undefined)
    at EventEmitter.emit (events.js:304:17)
    at Object.&lt;anonymous&gt; (/tmp/foo.js:1:40)
    ... TRUNCATED ...
    at internal/main/run_main_module.js:17:47 {
  code: &#39;ERR_UNHANDLED_ERROR&#39;,
  context: undefined
}
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>因此，我们在使用 Event Emitter 的时候，要确保监听了 <code>error</code> 事件，这样在发生错误的时候，可以使得应用能够处理这些错误，避免奔溃。</p><h2 id="信号" tabindex="-1"><a class="header-anchor" href="#信号" aria-hidden="true">#</a> 信号</h2><p>信号是操作信息提供了进程间通信机制。信号通常是一个数字，同时也可以使用一个字符串来标识。比如 <code>SIGKILL</code> 标识数字 9。不同的操作系统对信号的定义不同。下面表格里罗列的是基本通用的信号定义。</p><table><thead><tr><th style="text-align:left;">名称</th><th style="text-align:left;">数字</th><th style="text-align:left;">是否可处理</th><th style="text-align:left;">NodeJS 默认行为</th><th style="text-align:left;">信号的含义</th></tr></thead><tbody><tr><td style="text-align:left;"><code>SIGHUP</code></td><td style="text-align:left;">1</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">父命令行被关闭</td></tr><tr><td style="text-align:left;"><code>SIGINT</code></td><td style="text-align:left;">2</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">命令行尝试中断，即 Ctrl + C</td></tr><tr><td style="text-align:left;"><code>SIGQUIT</code></td><td style="text-align:left;">3</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">命令行尝试退出，即 Ctrl + Z</td></tr><tr><td style="text-align:left;"><code>SIGKILL</code></td><td style="text-align:left;">9</td><td style="text-align:left;">No</td><td style="text-align:left;">退出</td><td style="text-align:left;">强制进程退出</td></tr><tr><td style="text-align:left;"><code>SIGUSR1</code></td><td style="text-align:left;">10</td><td style="text-align:left;">Yes</td><td style="text-align:left;">启动调试器</td><td style="text-align:left;">用户自定义信号</td></tr><tr><td style="text-align:left;"><code>SIGUSR2</code></td><td style="text-align:left;">12</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">用户自定义信号</td></tr><tr><td style="text-align:left;"><code>SIGTERM</code></td><td style="text-align:left;">15</td><td style="text-align:left;">Yes</td><td style="text-align:left;">退出</td><td style="text-align:left;">进程优雅的退出</td></tr><tr><td style="text-align:left;"><code>SIGSTOP</code></td><td style="text-align:left;">19</td><td style="text-align:left;">No</td><td style="text-align:left;">退出</td><td style="text-align:left;">进程被强制停止</td></tr></tbody></table><p>这表格里，是否可处理表示这个信号是否可被进程接收并被处理。NodeJS 默认行为表示进程在接收到这个信号以后默认执行的动作。</p><p>我们可以通过如下方式来监听这些信号。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token hashbang comment">#!/usr/bin/env node</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Process ID: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>process<span class="token punctuation">.</span>pid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;SIGHUP&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Received: SIGHUP&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;SIGINT&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Received: SIGINT&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// keep process alive</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在一个命令行窗口中运行这段代码，然后按下 Ctrl + C，此时进程不会退出，而是会在控制台打印一行接收到了 <code>SIGINT</code> 信号的日志信息。新起一个命令行窗口，执行如下命令，PROCESS_ID 为上面程序输出的进程 ID。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">kill</span> -s SIGHUP <span class="token operator">&lt;</span>PROCESS_ID<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>通过新起的命令行，我们向原来的那个程序进程发送了一个 <code>SIGHUP</code> 信号，原来的命令行窗口中会打印一行接收到了 <code>SIGHUP</code> 信号的日志信息。</p><p>在 NodeJS 代码中，进程也可以给其他进程发送信号。比如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>node -e <span class="token string">&quot;process.kill(&lt;PROCESS_ID&gt;, &#39;SIGHUP&#39;)&quot;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这段代码同样会在第一个命令行窗口中输出一行接收到了 <code>SIGHUP</code> 信号的日志。</p><p>如果我们要让第一个命令行窗口的进程退出，则可以通过下面的命令来实现。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">kill</span> -9 <span class="token operator">&lt;</span>PROCESS_ID<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在 NodeJS 中，信号通常被用作控制进程优雅的退出。比如，在 <a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer">Kubernetes<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 中，当一个 pod 要退出时，k8s 会像 pod 内的进程发送一个 <code>SIGTERM</code> 的信号，同时启动一个 30 秒的定时器。应用程序有 30 秒的时间来关闭连接、保存数据等。如果 30 秒之后进程依然存活，k8s 会再发送一个 <code>SIGKILL</code> 来强制关闭进程。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本文讲述了可以导致进程退出的几种因素，分别是：</p><ul><li>主动退出</li><li>未捕获的异常、未处理的 promise rejection、未处理的 Event Emitter error 事件</li><li>系统信号</li></ul><p>我们对每种因素的作用原理和使用方法做了说明。</p><div style="display:flex;align-items:center;justify-content:center;"><p style="text-align:center;margin-top:10px;color:#999;"><img src="/qrcode-c.jpg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">关注微信公众号，获取最新推送~</p><p style="text-align:center;margin-top:10px;color:#999;"><img src="/card-c.jpeg" style="width:200px;height:200px;display:block;margin:10px auto;opacity:0.8;">加微信，深入交流~</p></div><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><!----><!--[--><!--]--></main></div><!----><!----><!--]--></div>
    <script src="/assets/js/runtime~app.fa50ff6a.js" defer></script><script src="/assets/js/3767.b5b9e7ce.js" defer></script><script src="/assets/js/app.8de2a662.js" defer></script>
  </body>
</html>
